<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>战斗模拟器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        h1 {
            color: #333;
            font-size: 2em;
        }

        .version {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
        }

        .config-section {
            margin-bottom: 30px;
        }

        .section-title {
            color: #667eea;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .character-card {
            background: #f8f9ff;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .character-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .character-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .status-alive {
            background: #d4edda;
            color: #155724;
        }

        .status-dead {
            background: #f8d7da;
            color: #721c24;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .monster-config {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
        }

        .monster-config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .battle-area {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
            display: none;
        }

        .battle-area.show {
            display: block;
        }

        /* 波次战斗区域（在tab-battle页签内） */
        #waveBattleArea {
            display: none;
        }

        #waveBattleArea[style*="block"] {
            display: block !important;
        }

        /* 可视化战斗场景 */
        .battle-scene {
            width: 100%;
            min-height: 400px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        /* 主配置页签的战斗场景不显示背景 */
        #battleArea #battleScene {
            background: transparent !important;
            min-height: 0 !important;
            padding: 0 !important;
            margin-bottom: 0 !important;
            display: none !important;
        }

        .battle-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 350px;
            position: relative;
        }

        /* 角色区域 */
        .characters-side {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            max-width: 400px;
        }

        .character-sprite {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 2px solid #fff;
            transition: all 0.3s ease;
            position: relative;
        }

        .character-sprite.dead {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
            position: relative;
            flex-shrink: 0;
        }

        .character-avatar.tank { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .character-avatar.warrior { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .character-avatar.archer { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .character-avatar.support { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }

        .character-info {
            flex: 1;
            min-width: 0;
        }

        .character-name {
            font-weight: 600;
            font-size: 1em;
            margin-bottom: 5px;
        }

        .character-hp-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .character-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #40c057 100%);
            transition: width 0.3s ease;
        }

        .character-hp-fill.low {
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
        }

        /* 怪物区域 */
        .monsters-side {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex: 1;
            justify-content: flex-end;
            align-items: flex-start;
            max-width: 500px;
        }

        .monster-sprite {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 2px solid #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .monster-sprite.dead {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(100%);
        }

        .monster-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .monster-hp-bar {
            width: 70px;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
        }

        .monster-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
            transition: width 0.3s ease;
        }

        .monster-hp-text {
            font-size: 0.65em;
            color: #666;
            margin-top: 2px;
            line-height: 1;
            white-space: nowrap;
        }

        .monster-id {
            font-size: 0.7em;
            color: #666;
            margin-top: 2px;
        }

        /* 攻击动画 */
        @keyframes attackAnimation {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(30px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes monsterAttackAnimation {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(-30px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes hitAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1); }
        }

        @keyframes damageFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .character-sprite.attacking {
            animation: attackAnimation 0.5s ease;
        }

        .monster-sprite.attacking {
            animation: monsterAttackAnimation 0.5s ease;
        }
        
        /* 同一秒刷新的时间标记 */
        .monster-spawn-time-tag {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.65em;
            font-weight: 700;
            line-height: 1;
            padding: 2px 5px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.65);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.25);
            text-shadow: 0 1px 1px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 2;
        }
        
        /* 可攻击倒计时标记（右上角） */
        .monster-attack-countdown {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7em;
            font-weight: 700;
            line-height: 1;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 87, 34, 0.85);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 3;
            min-width: 35px;
            text-align: center;
        }
        
        .monster-attack-countdown.ready {
            background: rgba(76, 175, 80, 0.85);
        }

        .character-sprite.hit {
            animation: hitAnimation 0.3s ease;
        }

        .monster-sprite.hit {
            animation: hitAnimation 0.3s ease;
        }

        .damage-number {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .heal-number {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #51cf66;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* 波次标识 */
        .wave-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            color: #667eea;
            font-size: 1.1em;
            z-index: 100;
        }

        /* 银币和升级UI */
        .battle-ui-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        
        /* 波次战斗的UI面板使用正常布局 */
        #waveBattleUIPanel {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .coins-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #f59f00;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: linear-gradient(135deg, #ffd43b 0%, #f59f00 100%);
            border-radius: 8px;
            color: white;
        }
        
        /* 波次战斗的UI面板（在战斗场景中，波次指示器下方） */
        #waveBattleUIPanel {
            position: relative !important;
            top: auto !important;
            right: auto !important;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px auto 0 auto;
            max-width: 400px;
            width: 100%;
        }

        .upgrade-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .upgrade-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            color: #ffffff !important;
        }

        .upgrade-btn.weapon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff !important;
        }

        .upgrade-btn.skill {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #ffffff !important;
        }

        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .upgrade-info {
            font-size: 0.95em;
            color: #ffffff;
            margin-top: 8px;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .battle-log {
            max-height: 400px;
            overflow-y: auto;
            background: #2d2d2d;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 15px;
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        .log-time {
            color: #888;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #51cf66;
        }

        .log-death {
            color: #ff8787;
            font-weight: bold;
        }

        .battle-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.8em;
            font-weight: bold;
        }

        .message {
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
            text-align: center;
            font-weight: 500;
        }

        .message.show {
            display: block;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .hp-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #ffd43b 50%, #ff6b6b 100%);
            transition: width 0.3s ease;
        }

        .monster-spawn-rate {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .monster-spawn-rate label {
            font-weight: 600;
            color: #333;
        }

        .characters-panel {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
        }

        .characters-panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .char-panel-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            position: relative;
            overflow: visible;
        }

        .char-panel-item.alive {
            border-color: #51cf66;
        }

        .char-panel-item.dead {
            border-color: #ff8787;
            opacity: 0.6;
        }

        .char-panel-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .char-panel-hp {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .char-panel-hp-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .char-panel-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #ffd43b 50%, #ff6b6b 100%);
            transition: width 0.3s ease;
        }

        .damage-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-weight: bold;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }

        .heal-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #51cf66;
            font-weight: bold;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -100px);
            }
        }

        .scheme-manager {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
        }

        /* 标签页样式 */
        .tab-container {
            margin-bottom: 30px;
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0;
        }

        .tab-button {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            top: 2px;
        }

        .tab-button:hover {
            color: #667eea;
            background: #f8f9ff;
        }

        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .scheme-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }

        .scheme-input {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .scheme-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .scheme-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .scheme-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .scheme-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .scheme-item.active {
            border-color: #667eea;
            background: #e8ebff;
        }

        .scheme-item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .scheme-item-meta {
            font-size: 0.8em;
            color: #666;
        }

        .scheme-item-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7em;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .scheme-item:hover .scheme-item-delete {
            opacity: 1;
        }

        .scheme-item-delete:hover {
            background: #c82333;
        }

        .scheme-warning {
            color: #ffc107;
            font-size: 0.85em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚔️ 战斗模拟器</h1>
            <div class="version">v<span id="version">-</span></div>
        </div>

        <!-- 标签页容器 -->
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('main')">⚙️ 主配置</button>
                <button class="tab-button" onclick="switchTab('battle')">⚔️ 局内战斗模拟</button>
                <button class="tab-button" onclick="switchTab('data')">📊 数据表导入</button>
                <button class="tab-button" onclick="switchTab('import')">💾 方案导入</button>
            </div>

            <!-- 主配置标签页 -->
            <div id="tab-main" class="tab-content active">
                <!-- 主配置内容将显示在这里 -->
            </div>

            <!-- 局内战斗模拟标签页 -->
            <div id="tab-battle" class="tab-content">
                <div class="config-section">
                    <div class="section-title">📊 角色最终属性（用于战斗计算）</div>
                    <div id="battleFinalAttributesPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px;"></div>
                </div>

                <div class="config-section">
                    <div class="section-title">🏆 25波怪物数据输入</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                            配置25波怪物数据，可选择怪物ID自动填充攻防血，或手动输入。每5波为一个据点，共5个据点。
                        </div>
                        
                        <!-- 据点奖励配置 -->
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">💰 据点奖励配置（每个据点通过后获得银币奖励）</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">据点1 (1-5波):</label>
                                    <input type="number" id="stronghold1Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(1, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">银币</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">据点2 (6-10波):</label>
                                    <input type="number" id="stronghold2Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(2, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">银币</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">据点3 (11-15波):</label>
                                    <input type="number" id="stronghold3Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(3, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">银币</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">据点4 (16-20波):</label>
                                    <input type="number" id="stronghold4Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(4, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">银币</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">据点5 (21-25波):</label>
                                    <input type="number" id="stronghold5Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(5, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">银币</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 25波怪物数据方案管理 -->
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">💾 25波怪物数据方案管理（最多8个）</div>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px;">
                                <input type="text" id="battleWaveSchemeNameInput" placeholder="方案名称" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 150px;" />
                                <button class="btn btn-primary" onclick="saveBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em;">保存方案</button>
                                <select id="battleWaveSchemeSelect" onchange="loadBattleWaveScheme(this.value)" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 150px;">
                                    <option value="">选择方案...</option>
                                </select>
                                <button class="btn btn-secondary" onclick="copyBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white;">复制方案</button>
                                <button class="btn btn-danger" onclick="deleteBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em; background: #ff6b6b;">删除方案</button>
                            </div>
                            <div id="battleWaveSchemeStatus" style="font-size: 0.85em; color: #666;"></div>
                        </div>
                        
                        <div id="battleWaveDataGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 15px;"></div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">⚔️ 可视化战斗模拟</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                            按照配置的25波怪物数据，逐波出怪并进行可视化战斗模拟。每个据点所有怪物死亡后才能开始下一个据点。
                        </div>
                        <div style="margin-bottom: 10px; font-size: 0.85em; color: #555; display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                            <span>怪物生成后前</span>
                            <input type="number" id="monsterAttackDelayInput" min="0" max="60" step="0.5" value="3" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>秒不攻击；角色攻击频率</span>
                            <input type="number" id="characterAttackIntervalInput" min="0.01" max="5" step="0.01" value="0.1" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>秒/次，伤害系数</span>
                            <input type="number" id="characterDamageScaleInput" min="0.01" max="10" step="0.01" value="0.1" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>倍（均可配置）</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button class="btn btn-primary" id="startWaveBattleBtn" onclick="startWaveBattle()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; background: #667eea;">
                                🎮 开始可视化模拟
                            </button>
                            <button class="btn btn-secondary" id="stopWaveBattleBtn" onclick="stopWaveBattle()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; display: none;">
                                ⏹️ 停止模拟
                            </button>
                            <div id="waveBattleStatus" style="font-size: 0.9em; color: #666; margin-left: 10px;"></div>
                        </div>
                        <div id="waveBattleInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666; display: none;">
                            <div>当前据点: <span id="currentStrongholdNumber">-</span> / 5</div>
                            <div>当前波次: <span id="currentWaveNumber">-</span> / 25</div>
                            <div>已出怪物数: <span id="currentWaveSpawned">-</span> / <span id="currentWaveTotal">-</span></div>
                            <div>存活怪物数: <span id="currentWaveAlive">-</span></div>
                        </div>
                    </div>
                </div>

                <!-- 可视化战斗场景和相关信息（在tab-battle页签内） -->
                <div class="battle-area" id="waveBattleArea" style="display: none;">
                    <div class="section-title">⚔️ 战斗进行中</div>
                    <div class="battle-stats" id="waveBattleStats"></div>
                    
                    <!-- 可视化战斗场景 -->
                    <div class="battle-scene" id="waveBattleScene">
                        <div class="wave-indicator" id="waveIndicator" style="display: none;">第 0 波</div>
                        
                        <!-- 银币和升级按钮（在波次指示器下方） -->
                        <div class="battle-ui-panel" id="waveBattleUIPanel" style="margin-top: 15px; display: none;">
                            <div class="coins-display">
                                💰 <span id="waveCoinsDisplay">0</span>
                            </div>
                            <div class="upgrade-buttons">
                                <button class="upgrade-btn weapon" id="waveUpgradeWeaponBtn" onclick="upgradeWeapon()">
                                    ⚔️ 武器升级
                                    <div class="upgrade-info" id="waveWeaponUpgradeInfo">Lv.0</div>
                                </button>
                                <button class="upgrade-btn skill" id="waveUpgradeSkillBtn" onclick="upgradeSkill()">
                                    ✨ 技能升级
                                    <div class="upgrade-info" id="waveSkillUpgradeInfo">Lv.0</div>
                                </button>
                            </div>
                        </div>
                        <div class="battle-field">
                            <div class="characters-side" id="waveCharactersSide"></div>
                            <div class="monsters-side" id="waveMonstersSide"></div>
                        </div>
                    </div>
                    
                    <div class="characters-panel">
                        <div class="section-title" style="margin-bottom: 15px;">👥 角色状态</div>
                        <div class="characters-panel-grid" id="waveCharactersPanel"></div>
                    </div>
                    <div class="battle-log" id="waveBattleLog"></div>
                </div>
            </div>

            <!-- 方案导入标签页 -->
            <div id="tab-import" class="tab-content">
                <div class="scheme-manager">
                    <div class="section-title">☁️ 共享存储配置（所有人共享数据）</div>
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin-bottom: 10px;">
                            <input type="text" id="sharedGistId" placeholder="输入GitHub Gist ID（留空则仅本地存储）" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            <button class="btn btn-primary" onclick="saveSharedGistId()" style="padding: 8px 16px; font-size: 0.9em;">保存Gist ID</button>
                        </div>
                        <div style="font-size: 0.85em; color: #856404; margin-bottom: 8px;">
                            <div>📝 使用说明：</div>
                            <div style="margin-left: 15px; margin-top: 5px;">
                                1. 创建GitHub Gist：访问 <a href="https://gist.github.com" target="_blank" style="color: #667eea;">gist.github.com</a>，创建公开Gist<br/>
                                2. 复制Gist ID（URL中的32位字符，如：abc123def456...）<br/>
                                3. 粘贴到上方输入框并保存<br/>
                                4. 所有人使用同一个Gist ID即可共享数据
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="btn btn-success" onclick="syncFromShared()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66;">🔄 从共享存储同步</button>
                            <button class="btn btn-info" onclick="syncToShared()" style="padding: 8px 16px; font-size: 0.9em; background: #17a2b8;">📤 上传到共享存储</button>
                            <span id="sharedStorageStatus" style="color: #666; font-size: 0.85em; line-height: 32px; margin-left: 10px;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 数据表导入标签页 -->
            <div id="tab-data" class="tab-content">
                <div class="scheme-manager">
                    <div class="section-title">📦 装备表管理</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="equipmentFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadEquipmentTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('equipmentFileInput').click()" style="padding: 8px 20px;">上传装备表</button>
                            <span id="equipmentTableStatus" style="color: #666; font-size: 0.9em;">未加载装备表</span>
                        </div>
                        <div id="equipmentTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">🦸 英雄表管理</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="heroFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadHeroTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('heroFileInput').click()" style="padding: 8px 20px;">上传英雄表</button>
                            <span id="heroTableStatus" style="color: #666; font-size: 0.9em;">未加载英雄表</span>
                        </div>
                        <div id="heroTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">👹 怪物表管理</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="monsterFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadMonsterTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('monsterFileInput').click()" style="padding: 8px 20px;">上传怪物表</button>
                            <span id="monsterTableStatus" style="color: #666; font-size: 0.9em;">未加载怪物表</span>
                        </div>
                        <div id="monsterTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">⚔️ 局内武器技能升级表管理</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="upgradeFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadUpgradeTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('upgradeFileInput').click()" style="padding: 8px 20px;">上传升级表</button>
                            <span id="upgradeTableStatus" style="color: #666; font-size: 0.9em;">未加载升级表</span>
                        </div>
                        
                        <!-- 武器升级系数查看模块 -->
                        <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">🔍 武器升级系数查看</div>
                            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                                <label style="font-size: 0.9em; color: #666;">选择武器升级次数：</label>
                                <select id="weaponLevelViewer" onchange="updateWeaponCoeffViewer()" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 120px;">
                                    <option value="-1">请选择</option>
                                </select>
                            </div>
                            <div id="weaponCoeffInfo" style="display: none; padding: 12px; background: #f8f9ff; border-radius: 6px; font-size: 0.9em;">
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">当前等级：</span>
                                    <span id="currentWeaponLevelView" style="font-weight: 600; color: #667eea;"></span>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">当前伤害系数：</span>
                                    <span id="currentWeaponCoeffView" style="font-weight: 600; color: #51cf66;"></span>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">升级消耗：</span>
                                    <span id="weaponUpgradeCostView" style="font-weight: 600; color: #f59f00;"></span>
                                </div>
                                <div>
                                    <span style="color: #666;">下一级提升值：</span>
                                    <span id="weaponUpgradeRatioView" style="font-weight: 600; color: #f5576c;"></span>
                                </div>
                            </div>
                        </div>
                        <div id="upgradeTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">🔍 英雄属性查看</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="input-group">
                        <label style="font-weight: 600; color: #333; margin-bottom: 8px;">选择英雄</label>
                        <select id="heroSelect" onchange="updateHeroLevelSelect()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">请先上传英雄表</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label style="font-weight: 600; color: #333; margin-bottom: 8px;">选择等级</label>
                        <select id="heroLevelSelect" onchange="updateHeroAttributes()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">请先选择英雄</option>
                        </select>
                    </div>
                </div>
                <div id="heroAttributesDisplay" style="background: white; border-radius: 8px; padding: 20px; border: 2px solid #e0e0e0; display: none;">
                    <div style="font-size: 1.1em; font-weight: 600; color: #667eea; margin-bottom: 15px;" id="heroDisplayName"></div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">攻击力</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #f44336;" id="heroAttrAttack">-</div>
                        </div>
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">防御力</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #2196F3;" id="heroAttrDefense">-</div>
                        </div>
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">生命值</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #4CAF50;" id="heroAttrHp">-</div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;" id="heroAttrInfo"></div>
                </div>
            </div>
        </div>

                <div class="config-section">
                    <div class="section-title">👹 怪物属性查看</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div class="input-group">
                                <label style="font-weight: 600; color: #333; margin-bottom: 8px;">选择怪物</label>
                                <select id="monsterSelect" onchange="updateMonsterAttributes()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                                    <option value="">请先上传怪物表</option>
                                </select>
                            </div>
                        </div>
                        <div id="monsterAttributesDisplay" style="background: white; border-radius: 8px; padding: 20px; border: 2px solid #e0e0e0; display: none;">
                            <div style="font-size: 1.1em; font-weight: 600; color: #667eea; margin-bottom: 15px;" id="monsterDisplayName"></div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">攻击力</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #f44336;" id="monsterAttrAttack">-</div>
                                </div>
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">防御力</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #2196F3;" id="monsterAttrDefense">-</div>
                                </div>
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">生命值</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #4CAF50;" id="monsterAttrHp">-</div>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;" id="monsterAttrInfo"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 主配置内容 -->
        <div id="main-content">
        <div class="scheme-manager">
            <div class="section-title">💾 方案管理（最多10个方案）</div>
            <div class="scheme-controls">
                <input type="text" class="scheme-input" id="schemeNameInput" placeholder="输入方案名称..." maxlength="20" />
                <button class="btn btn-primary" onclick="saveScheme()" style="padding: 8px 20px; flex: 0;">保存方案</button>
                <button class="btn btn-secondary" onclick="newScheme()" style="padding: 8px 20px; flex: 0;">新建方案</button>
                <button class="btn btn-secondary" onclick="clearCurrentScheme()" style="padding: 8px 20px; flex: 0;">清空配置</button>
            </div>
            <div class="scheme-list" id="schemeList"></div>
            <div class="scheme-warning" id="schemeWarning"></div>
        </div>

        <div class="config-section">
            <div class="section-title">👥 角色基础属性配置（5个角色）</div>
            <div class="characters-grid" id="charactersGrid"></div>
        </div>

        <div class="config-section">
            <div class="section-title">⚔️ 职业装备配置</div>
            <div id="jobEquipmentPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;"></div>
        </div>

        <div class="config-section">
            <div class="section-title">📈 平台属性配置</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    平台属性加成公式：最终属性 = 基础属性 + 系数 × (局外英雄数量 + 局外英雄等级和)
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="input-group">
                        <label>局外英雄数量</label>
                        <input type="number" id="platformHeroCount" min="0" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>局外英雄等级和</label>
                        <input type="number" id="platformHeroLevelSum" min="0" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>攻击系数</label>
                        <input type="number" id="platformAttackCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>防御系数</label>
                        <input type="number" id="platformDefenseCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>生命值系数</label>
                        <input type="number" id="platformHpCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                </div>
                <div id="platformBonusInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666;">
                    <div>当前平台加成：攻击 +0，防御 +0，生命 +0</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">🚗 平台属性（车辆）配置</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    车辆属性会直接加到所有角色的最终属性上
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="input-group">
                        <label>攻击力</label>
                        <input type="number" id="vehicleAttack" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>防御力</label>
                        <input type="number" id="vehicleDefense" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>生命值</label>
                        <input type="number" id="vehicleHp" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                </div>
                <div id="vehicleBonusInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666;">
                    <div>当前车辆加成：攻击 +0，防御 +0，生命 +0</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">📊 角色最终属性（用于战斗计算）</div>
            <div id="finalAttributesPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px;"></div>
        </div>

        <div class="config-section">
            <div class="section-title">📊 伤害公式说明</div>
            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                <div style="font-weight: 600; color: #333; margin-bottom: 10px;">当前应用的伤害计算公式：</div>
                <div style="color: #666; font-size: 0.9em; line-height: 1.8;">
                    <div><strong>角色对怪物伤害：</strong>基础伤害 = 攻击力 - 怪物防御力（最小1点）</div>
                    <div style="margin-left: 20px;">• 角色2、3、4：最终伤害 = 基础伤害 × (1 + 技能伤害系数%)</div>
                    <div><strong>怪物对角色伤害：</strong>基础伤害 = 怪物攻击力 - 角色防御力（最小1点）</div>
                    <div style="margin-left: 20px;">• 角色1：最终伤害 = 基础伤害 × (1 - 减伤百分比%)</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">🏆 关卡挑战配置（1-20关）</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; text-align: center;">
                    <button class="btn btn-success" onclick="challengeAllStages()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; background: #51cf66;">
                        ⚡ 一键挑战所有关卡
                    </button>
                    <div id="allStagesProgress" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
                </div>
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    每关可配置一个怪物ID，攻防血从怪物表读取，其他属性手动配置
                </div>
                <div id="stageConfigGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;"></div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">👹 怪物配置</div>
            <div class="monster-config">
                <div class="monster-spawn-rate">
                    <label>每秒刷新数量：</label>
                    <input type="number" id="spawnRate" min="0.1" max="10" step="0.1" value="1" style="width: 100px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px;">
                    <span>个/秒</span>
                </div>
                <div class="monster-config-grid">
                    <div class="input-group">
                        <label>攻击力</label>
                        <input type="number" id="monsterAttack" min="1" value="10" />
                    </div>
                    <div class="input-group">
                        <label>防御力</label>
                        <input type="number" id="monsterDefense" min="0" value="5" />
                    </div>
                    <div class="input-group">
                        <label>血量</label>
                        <input type="number" id="monsterHp" min="1" value="50" />
                    </div>
                    <div class="input-group">
                        <label>攻击速度（次/秒）</label>
                        <input type="number" id="monsterAtkSpeed" min="0.1" max="10" step="0.1" value="1" />
                    </div>
                    <div class="input-group">
                        <label>攻击系数</label>
                        <input type="number" id="monsterDamageCoeff" min="0" step="0.01" value="1" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">最终伤害 = 基础伤害 × 攻击系数</div>
                    </div>
                    <div class="input-group">
                        <label>血量系数</label>
                        <input type="number" id="monsterHpCoeff" min="0" step="0.01" value="0" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">进入战斗时血量 = 基础血量 × (1 + 血量系数)</div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <button class="btn btn-secondary" onclick="resetConfig()">重置配置</button>
            <button class="btn btn-primary" id="startBtn" onclick="startBattle()">开始战斗</button>
            <button class="btn btn-success" id="quickResultBtn" onclick="quickBattle()" style="background: #51cf66;">直接显示结果</button>
            <button class="btn btn-danger" id="stopBtn" onclick="stopBattle()" style="display: none;">停止战斗</button>
        </div>
        </div>

        <div class="message" id="message"></div>

        <div class="battle-area" id="battleArea">
            <div class="section-title">⚔️ 战斗进行中</div>
            <div class="battle-stats" id="battleStats"></div>
            
            <!-- 可视化战斗场景（主配置页签不使用，隐藏背景） -->
            <div class="battle-scene" id="battleScene" style="background: transparent; min-height: 0; padding: 0; display: none;">
                <div class="battle-field">
                    <div class="characters-side" id="charactersSide"></div>
                    <div class="monsters-side" id="monstersSide"></div>
                </div>
            </div>
            
            <div class="characters-panel">
                <div class="section-title" style="margin-bottom: 15px;">👥 角色状态</div>
                <div class="characters-panel-grid" id="charactersPanel"></div>
            </div>
            <div class="battle-log" id="battleLog"></div>
        </div>
    </div>

    <script>
        // 版本号管理
        const VERSION = '2.0.6';
        document.getElementById('version').textContent = VERSION;
        document.title = `战斗模拟器 v${VERSION}`;

        // 职业类型
        const JOB_TYPES = {
            TANK: 1,      // 坦克
            WARRIOR: 2,  // 战士
            ARCHER: 3,   // 射手
            SUPPORT: 4   // 辅助
        };

        const JOB_NAMES = {
            1: '坦克',
            2: '战士',
            3: '射手',
            4: '辅助'
        };

        // 装备表数据
        let equipmentTable = [];
        const EQUIPMENT_STORAGE_KEY = 'battleSimulatorEquipmentTable';
        
        // 英雄表数据
        let heroTable = [];
        let monsterTable = []; // 怪物表数据
        const HERO_STORAGE_KEY = 'battleSimulatorHeroTable';
        const MONSTER_STORAGE_KEY = 'battleSimulatorMonsterTable';
        
        // 部位类型
        const EQUIPMENT_TYPES = {
            HEAD: '头',
            BODY: '身',
            HAND: '手',
            FOOT: '脚'
        };
        
        // 角色装备配置（职业 -> 部位 -> 装备ID）
        let characterEquipment = {
            1: { head: null, body: null, hand: null, foot: null }, // 坦克
            2: { head: null, body: null, hand: null, foot: null }, // 战士
            3: { head: null, body: null, hand: null, foot: null }, // 射手
            4: { head: null, body: null, hand: null, foot: null }  // 辅助
        };

        // 角色数据
        const characters = Array.from({ length: 5 }, (_, i) => {
            let job = JOB_TYPES.SUPPORT; // 默认辅助
            if (i === 0) job = JOB_TYPES.TANK;      // 角色1：坦克
            else if (i === 1) job = JOB_TYPES.WARRIOR; // 角色2：战士
            else if (i === 2 || i === 3) job = JOB_TYPES.ARCHER; // 角色3、4：射手
            else if (i === 4) job = JOB_TYPES.SUPPORT; // 角色5：辅助

            return {
                id: i + 1,
                name: `角色${i + 1}`,
                job: job, // 职业
                equipmentId: null, // 当前装备ID
                baseAttack: 20, // 基础攻击力（不含装备加成）
                baseDefense: 10, // 基础防御力（不含装备加成）
                baseHp: 100, // 基础血量（不含装备加成）
                attack: 20,
                defense: 10,
                hp: 100,
                maxHp: 100,
                atkSpeed: 1, // 每秒1次
                healRate: i === 4 ? 0.05 : 0, // 角色5默认回血系数0.05，其他角色为0
                damageReduction: i === 0 ? 0 : 0, // 角色1减伤百分比（0-100）
                skillDamage: (i === 1 || i === 2 || i === 3) ? 0 : 0, // 角色2、3、4技能伤害系数（百分比）
                isAlive: true
            };
        });

        // 怪物配置
        let monsterConfig = {
            spawnRate: 1, // 每秒x个
            attack: 10,
            defense: 5,
            hp: 50,
            atkSpeed: 1,
            damageCoeff: 1, // 攻击系数，最终伤害 = 基础伤害 × 攻击系数
            hpCoeff: 0 // 血量系数，进入战斗时血量 = 基础血量 × (1 + 血量系数)
        };

        // 关卡配置（1-20关）
        let stageConfig = {};
        for (let i = 1; i <= 20; i++) {
            stageConfig[i] = {
                monsterId: '', // 怪物ID（从怪物表选择）
                atkSpeed: 0.33, // 攻击速度（次/秒）
                damageCoeff: 1, // 攻击系数
                hpCoeff: 0 // 血量系数
            };
        }

        // 25波怪物数据输入配置（用于局内战斗模拟）
        let battleWaveData = {};
        for (let i = 1; i <= 25; i++) {
            battleWaveData[i] = {
                monsterId: '', // 怪物ID（从怪物表选择，为空则手动输入）
                attack: 10, // 攻击力（选择怪物ID时自动填充，也可手动输入）
                defense: 5, // 防御力（选择怪物ID时自动填充，也可手动输入）
                hp: 50, // 生命值（选择怪物ID时自动填充，也可手动输入）
                atkSpeed: 0.33, // 攻速（手动输入）
                damageCoeff: 1, // 伤害系数（手动输入）
                hpCoeff: 1, // 生命值倍率（手动输入）
                spawnRate: 1, // 每秒出几只怪
                duration: 10, // 持续多少秒
                coinReward: 0 // 击杀怪物获得的银币奖励
            };
        }
        
        // 据点系统配置（每5波一个据点，共5个据点）
        let strongholdRewards = {}; // 据点奖励配置 {1: 100, 2: 200, ...} 表示第1、2、3、4、5个据点的银币奖励
        for (let i = 1; i <= 5; i++) {
            strongholdRewards[i] = 0; // 默认奖励为0
        }
        
        // 获取波次所属的据点编号（1-5）
        function getStrongholdForWave(wave) {
            return Math.ceil(wave / 5);
        }
        
        // 获取据点的波次范围
        function getStrongholdWaveRange(stronghold) {
            const startWave = (stronghold - 1) * 5 + 1;
            const endWave = Math.min(stronghold * 5, 25);
            return { start: startWave, end: endWave };
        }

        // 武器和技能升级表
        let weaponCostTable = []; // 武器升级消耗表 [{level: 0, cost: 10, damageCoeff: 1.0}, ...]
        let skillCostTable = []; // 技能升级消耗表 [{level: 0, cost: 10, damageCoeff: 1.0}, ...]

        // 波次战斗中的银币和升级状态
        let waveBattleCoins = 0; // 当前银币
        let weaponLevel = 0; // 当前武器等级
        let skillLevel = 0; // 当前技能等级

        // 怪物生成后开始攻击前的延迟时间（秒），默认3秒，可在界面中配置
        let monsterAttackDelay = 3;
        // 角色攻击频率（秒/次），默认0.1秒攻击一次；以及每次攻击伤害倍率，默认0.1倍，可在界面中配置
        let characterAttackInterval = 0.1;
        let characterDamageScale = 0.1;

        // 平台属性配置
        let platformConfig = {
            heroCount: 0,        // 局外英雄数量
            heroLevelSum: 0,      // 局外英雄等级和
            attackCoeff: 0,       // 攻击系数
            defenseCoeff: 0,      // 防御系数
            hpCoeff: 0            // 生命值系数
        };

        // 平台属性（车辆）配置
        let vehicleConfig = {
            attack: 0,           // 车辆攻击力
            defense: 0,          // 车辆防御力
            hp: 0                // 车辆生命值
        };

        // 战斗状态
        let battleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            totalMonstersSpawned: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            char1NeverDies: false // 标记角色1是否"几乎不会死"（超过200秒仍存活）
        };
        
        // 无浪费模式战斗状态（剩余伤害传递）
        let noWasteBattleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            totalMonstersSpawned: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            overflowDamage: 0 // 溢出伤害，会传递到下一只怪物
        };

        // 波次战斗状态（用于可视化模拟）
        let waveBattleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            currentWave: 0, // 当前波次（1-25）
            currentStronghold: 0, // 当前据点（1-5）
            strongholdCompleted: {}, // 已完成的据点 {1: true, 2: true, ...}
            waveStartTime: 0, // 当前波次开始时间
            waveSpawnedCount: 0, // 当前波次已出怪物数
            waveTotalCount: 0, // 当前波次总怪物数
            nextSpawnTime: 0, // 下次出怪时间（保留用于兼容，实际使用累计机制）
            monsterIdCounter: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            spawnAccumulator: 0, // 怪物生成累计值（用于小数生成率）
            lastSpawnCheckTime: null // 上次检查生成的时间
        };

        // 加载英雄表（全局函数）
        window.loadHeroTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // 查找hero和herolevel页签
                    const heroSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'hero' || name.toLowerCase().includes('hero')
                    );
                    const heroLevelSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'herolevel' || name.toLowerCase().includes('herolevel')
                    );
                    
                    if (!heroSheetName) {
                        showMessage('未找到hero页签', 'error');
                        return;
                    }
                    
                    // 读取hero页签（跳过前5行表头）
                    const heroSheet = workbook.Sheets[heroSheetName];
                    const heroJsonData = XLSX.utils.sheet_to_json(heroSheet, { 
                        header: 1,  // 使用数组格式，保留原始行列信息
                        defval: ''   // 空单元格默认值
                    });
                    
                    // 解析职业
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // 如果是数字，直接转换
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // 如果是文本，转换为数字
                        const textValue = String(heroclassValue).trim();
                        if (textValue === '坦克' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === '战士' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === '射手' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === '辅助' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // 解析hero页签数据（跳过前5行表头）
                    // A列(索引0): 中文名, B列(索引1): ID, I列(索引8): 品质, L列(索引11): 职业
                    const heroMap = new Map();
                    for (let i = 5; i < heroJsonData.length; i++) {
                        const row = heroJsonData[i];
                        if (!row || row.length === 0) continue;
                        
                        const id = String(row[1] || '').trim(); // B列
                        const namecn = String(row[0] || '').trim(); // A列
                        const quality = String(row[8] || '').trim(); // I列
                        const heroclass = parseHeroClass(row[11]); // L列
                        
                        // 跳过空行和ID以119开头的测试数据
                        if (!id || id.startsWith('119')) continue;
                        if (!namecn) continue;
                        
                        heroMap.set(id, {
                            id: id,
                            namecn: namecn,
                            quality: quality,
                            heroclass: heroclass,
                            levels: {} // 存储各等级属性
                        });
                    }
                    
                    // 读取herolevel页签（如果有）
                    if (heroLevelSheetName) {
                        const heroLevelSheet = workbook.Sheets[heroLevelSheetName];
                        const heroLevelJsonData = XLSX.utils.sheet_to_json(heroLevelSheet, {
                            header: 1,
                            defval: ''
                        });
                        
                        // 解析属性字符串：用竖线分割不同属性，用分号分割属性id和属性值
                        // 格式：属性id;属性值|属性id;属性值
                        // 示例：102001;180|103001;50|101001;1400 表示攻击力180，防御力50，生命值1400
                        function parseAttributes(attrStr) {
                            if (!attrStr) return {};
                            
                            const result = {
                                baseAttack: 0,
                                baseDefense: 0,
                                baseHp: 0
                            };
                            
                            // 转换为字符串并去除首尾空格
                            const attrStrClean = String(attrStr).trim();
                            
                            if (!attrStrClean) return result;
                            
                            // 用竖线分割不同的属性
                            const attributes = attrStrClean.split('|');
                            
                            attributes.forEach(attr => {
                                const attrTrimmed = attr.trim();
                                if (!attrTrimmed) return;
                                
                                // 用分号分割属性id和属性值
                                const parts = attrTrimmed.split(';').map(s => s.trim());
                                
                                if (parts.length >= 2) {
                                    const attrId = parts[0];
                                    const value = parts[1];
                                    
                                    if (attrId && value) {
                                        // 将属性ID转换为数字（支持字符串和数字格式）
                                        const attrIdNum = parseInt(attrId);
                                        const numValue = parseFloat(value);
                                        
                                        if (!isNaN(numValue) && !isNaN(attrIdNum)) {
                                            // 属性ID映射：102001=攻击力，103001=防御力，101001=生命值
                                            if (attrIdNum === 102001) {
                                                result.baseAttack = numValue;
                                            } else if (attrIdNum === 103001) {
                                                result.baseDefense = numValue;
                                            } else if (attrIdNum === 101001) {
                                                result.baseHp = numValue;
                                            }
                                        }
                                    }
                                }
                            });
                            
                            return result;
                        }
                        
                        // C列(索引2): 英雄ID, D列(索引3): 等级, L列(索引11): 属性字符串
                        let parsedCount = 0;
                        for (let i = 0; i < heroLevelJsonData.length; i++) {
                            const row = heroLevelJsonData[i];
                            if (!row || row.length === 0) continue;
                            
                            const heroId = String(row[2] || '').trim(); // C列
                            const level = parseInt(row[3] || 0); // D列
                            const attributes = String(row[11] || '').trim(); // L列
                            
                            if (!heroId || !level || !attributes) continue;
                            
                            const hero = heroMap.get(heroId);
                            if (hero) {
                                const parsedAttrs = parseAttributes(attributes);
                                hero.levels[level] = parsedAttrs;
                                parsedCount++;
                                
                                // 调试：显示前几条解析结果
                                if (parsedCount <= 3) {
                                    console.log(`解析英雄等级属性 - ID: ${heroId}, 等级: ${level}, 原始字符串: "${attributes}", 解析结果:`, parsedAttrs);
                                }
                            }
                        }
                        
                        if (parsedCount > 0) {
                            console.log(`成功解析 ${parsedCount} 条英雄等级属性数据`);
                        }
                    }
                    
                    // 转换为数组格式
                    heroTable = Array.from(heroMap.values());
                    
                    // 为每个英雄计算基础属性（使用等级1的属性，如果没有则使用默认值）
                    heroTable.forEach(hero => {
                        const level1Attrs = hero.levels[1] || {};
                        hero.baseAttack = level1Attrs.baseAttack || 0;
                        hero.baseDefense = level1Attrs.baseDefense || 0;
                        hero.baseHp = level1Attrs.baseHp || 0;
                    });

                    // 保存到localStorage（永久保存，直到下次手动上传替换）
                    localStorage.setItem(HERO_STORAGE_KEY, JSON.stringify(heroTable));
                    console.log('英雄表已保存到本地，共', heroTable.length, '个英雄');
                    console.log('英雄表示例（前3个）:', heroTable.slice(0, 3).map(hero => ({
                        id: hero.id,
                        namecn: hero.namecn,
                        heroclass: hero.heroclass,
                        quality: hero.quality,
                        baseAttack: hero.baseAttack,
                        baseDefense: hero.baseDefense,
                        baseHp: hero.baseHp,
                        levelCount: Object.keys(hero.levels || {}).length
                    })));

                    // 更新界面
                    updateHeroTableInfo();
                    
                    showMessage(`成功加载${heroTable.length}个英雄，已保存到本地`, 'success');
                } catch (error) {
                    console.error('读取英雄表失败:', error);
                    showMessage('读取英雄表失败，请检查文件格式: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // 加载怪物表（全局函数）
        window.loadMonsterTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // 查找第一个页签（或monster页签）
                    const monsterSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'monster' || name.toLowerCase().includes('monster')
                    ) || workbook.SheetNames[0];
                    
                    if (!monsterSheetName) {
                        showMessage('未找到怪物表页签', 'error');
                        return;
                    }
                    
                    // 读取怪物表页签（跳过前5行表头）
                    const monsterSheet = workbook.Sheets[monsterSheetName];
                    const monsterJsonData = XLSX.utils.sheet_to_json(monsterSheet, { 
                        header: 1,  // 使用数组格式，保留原始行列信息
                        defval: ''   // 空单元格默认值
                    });
                    
                    // 解析属性字符串：用竖线分割不同属性，用分号分割属性id和属性值
                    // 格式：属性id;属性值|属性id;属性值
                    // 示例：102001;180|103001;50|101001;1400 表示攻击力180，防御力50，生命值1400
                    function parseMonsterAttributes(attrStr) {
                        if (!attrStr) return {};
                        
                        const result = {
                            baseAttack: 0,
                            baseDefense: 0,
                            baseHp: 0
                        };
                        
                        const attrStrClean = String(attrStr).trim();
                        if (!attrStrClean) return result;
                        
                        const attributes = attrStrClean.split('|');
                        attributes.forEach(attr => {
                            if (!attr.trim()) return;
                            const parts = attr.split(';').map(s => s.trim());
                            if (parts.length >= 2) {
                                const attrId = parts[0];
                                const value = parts[1];
                                if (attrId && value) {
                                    const numValue = parseFloat(value);
                                    if (!isNaN(numValue)) {
                                        const attrIdNum = parseInt(attrId);
                                        if (attrIdNum === 102001 || attrId === '102001') {
                                            result.baseAttack = numValue;
                                        } else if (attrIdNum === 103001 || attrId === '103001') {
                                            result.baseDefense = numValue;
                                        } else if (attrIdNum === 101001 || attrId === '101001') {
                                            result.baseHp = numValue;
                                        }
                                    }
                                }
                            }
                        });
                        return result;
                    }
                    
                    // 解析怪物表数据（跳过前5行表头）
                    // B列(索引1): 怪物ID, D列(索引3): 属性字符串
                    monsterTable = [];
                    for (let i = 5; i < monsterJsonData.length; i++) {
                        const row = monsterJsonData[i];
                        if (!row || row.length === 0) continue;
                        
                        const id = String(row[1] || '').trim(); // B列
                        const attrStr = String(row[3] || '').trim(); // D列
                        
                        // 跳过空行
                        if (!id) continue;
                        
                        // 解析属性
                        const attrs = parseMonsterAttributes(attrStr);
                        
                        monsterTable.push({
                            id: id,
                            baseAttack: attrs.baseAttack || 0,
                            baseDefense: attrs.baseDefense || 0,
                            baseHp: attrs.baseHp || 0
                        });
                    }
                    
                    // 保存到localStorage
                    localStorage.setItem(MONSTER_STORAGE_KEY, JSON.stringify(monsterTable));
                    console.log('怪物表已保存到本地，共', monsterTable.length, '个怪物');
                    console.log('怪物表示例（前3个）:', monsterTable.slice(0, 3));

                    // 更新界面
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects(); // 更新关卡怪物选择下拉框
                    updateBattleWaveMonsterSelects(); // 更新波次怪物选择下拉框
                    
                    showMessage(`成功加载${monsterTable.length}个怪物，已保存到本地`, 'success');
                } catch (error) {
                    console.error('读取怪物表失败:', error);
                    showMessage('读取怪物表失败，请检查文件格式: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // 加载武器技能升级表（全局函数）
        window.loadUpgradeTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // 查找RogueWpnCost和RogueSkillCost页签
                    const weaponSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'roguewpncost' || name.toLowerCase().includes('roguewpncost')
                    );
                    const skillSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'rogueskillcost' || name.toLowerCase().includes('rogueskillcost')
                    );
                    
                    if (!weaponSheetName) {
                        showMessage('未找到RogueWpnCost页签', 'error');
                        return;
                    }
                    if (!skillSheetName) {
                        showMessage('未找到RogueSkillCost页签', 'error');
                        return;
                    }
                    
                    // 读取武器升级表（跳过前5行表头）
                    const weaponSheet = workbook.Sheets[weaponSheetName];
                    const weaponJsonData = XLSX.utils.sheet_to_json(weaponSheet, { 
                        header: 1,
                        defval: '',
                        range: 5 // 跳过前5行
                    });
                    
                    weaponCostTable = [];
                    console.log('=== 武器升级表读取 ===');
                    weaponJsonData.forEach((row, index) => {
                        if (row.length >= 3) {
                            const level = parseInt(row[1]) || 0; // B列：第几次购买（从0开始）
                            const cost = parseFloat(row[2]) || 0; // C列：银币消耗
                            const rawEValue = row[4]; // E列原始值
                            const damageCoeff = parseFloat(row[4]) || 1; // E列：武器伤害系数
                            
                            // 输出读取的内容
                            console.log(`行${index + 6} (跳过5行表头): 等级=${level}, 消耗=${cost}, E列原始值=${rawEValue}, 伤害系数=${damageCoeff}`);
                            
                            if (!isNaN(level) && !isNaN(cost)) {
                                weaponCostTable.push({ level, cost, damageCoeff });
                            }
                        }
                    });
                    console.log(`总共读取 ${weaponCostTable.length} 条武器升级数据`);
                    console.log('武器升级表内容:', weaponCostTable);
                    
                    // 读取技能升级表（跳过前5行表头）
                    const skillSheet = workbook.Sheets[skillSheetName];
                    const skillJsonData = XLSX.utils.sheet_to_json(skillSheet, { 
                        header: 1,
                        defval: '',
                        range: 5 // 跳过前5行
                    });
                    
                    skillCostTable = [];
                    console.log('=== 技能升级表读取 ===');
                    skillJsonData.forEach((row, index) => {
                        if (row.length >= 3) {
                            const level = parseInt(row[1]) || 0; // B列：第几次购买（从0开始）
                            const cost = parseFloat(row[2]) || 0; // C列：银币消耗
                            const rawEValue = row[4]; // E列原始值
                            const damageCoeff = parseFloat(row[4]) || 1; // E列：技能升级伤害系数
                            
                            // 输出读取的内容
                            console.log(`行${index + 6} (跳过5行表头): 等级=${level}, 消耗=${cost}, E列原始值=${rawEValue}, 伤害系数=${damageCoeff}`);
                            
                            if (!isNaN(level) && !isNaN(cost)) {
                                skillCostTable.push({ level, cost, damageCoeff });
                            }
                        }
                    });
                    console.log(`总共读取 ${skillCostTable.length} 条技能升级数据`);
                    console.log('技能升级表内容:', skillCostTable);
                    
                    // 保存到本地存储
                    localStorage.setItem('weaponCostTable', JSON.stringify(weaponCostTable));
                    localStorage.setItem('skillCostTable', JSON.stringify(skillCostTable));
                    
                    // 更新显示
                    updateUpgradeTableInfo();
                    
                    showMessage(`成功加载武器升级表（${weaponCostTable.length}条）和技能升级表（${skillCostTable.length}条）`, 'success');
                } catch (error) {
                    console.error('加载升级表失败:', error);
                    showMessage('加载升级表失败: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // 加载保存的升级表
        function loadSavedUpgradeTable() {
            try {
                const savedWeaponTable = localStorage.getItem('weaponCostTable');
                const savedSkillTable = localStorage.getItem('skillCostTable');
                
                if (savedWeaponTable) {
                    weaponCostTable = JSON.parse(savedWeaponTable);
                }
                if (savedSkillTable) {
                    skillCostTable = JSON.parse(savedSkillTable);
                }
                
                if (weaponCostTable.length > 0 || skillCostTable.length > 0) {
                    updateUpgradeTableInfo();
                }
            } catch (error) {
                console.error('加载保存的升级表失败:', error);
            }
        }

        // 更新升级表信息显示
        function updateUpgradeTableInfo() {
            const statusEl = document.getElementById('upgradeTableStatus');
            const infoEl = document.getElementById('upgradeTableInfo');
            
            if (weaponCostTable.length > 0 || skillCostTable.length > 0) {
                statusEl.textContent = `已加载武器表（${weaponCostTable.length}条）和技能表（${skillCostTable.length}条）`;
                statusEl.style.color = '#51cf66';
                
                let infoText = `武器升级表: ${weaponCostTable.length}条记录`;
                if (weaponCostTable.length > 0) {
                    const maxLevel = Math.max(...weaponCostTable.map(w => w.level));
                    const maxCost = Math.max(...weaponCostTable.map(w => w.cost));
                    infoText += ` | 最高等级: ${maxLevel}, 最高消耗: ${maxCost}`;
                    
                    // 显示武器系数详情
                    infoText += `<br><br><strong>武器系数详情（从E列读取）：</strong><br>`;
                    weaponCostTable.sort((a, b) => a.level - b.level).forEach(weapon => {
                        const coeff = (weapon.damageCoeff !== undefined) ? parseFloat(weapon.damageCoeff) : 1.0;
                        infoText += `等级 ${weapon.level}: 消耗 ${weapon.cost} 银币, 伤害系数 ${coeff.toFixed(2)}<br>`;
                    });
                }
                infoText += `<br><br>技能升级表: ${skillCostTable.length}条记录`;
                if (skillCostTable.length > 0) {
                    const maxLevel = Math.max(...skillCostTable.map(s => s.level));
                    const maxCost = Math.max(...skillCostTable.map(s => s.cost));
                    infoText += ` | 最高等级: ${maxLevel}, 最高消耗: ${maxCost}`;
                    
                    // 显示技能系数详情
                    infoText += `<br><br><strong>技能系数详情（从E列读取）：</strong><br>`;
                    skillCostTable.sort((a, b) => a.level - b.level).forEach(skill => {
                        const coeff = (skill.damageCoeff !== undefined) ? parseFloat(skill.damageCoeff) : 1.0;
                        infoText += `等级 ${skill.level}: 消耗 ${skill.cost} 银币, 伤害系数 ${coeff.toFixed(2)}<br>`;
                    });
                }
                
                // 更新武器升级系数查看器的下拉选项
                updateWeaponLevelViewerOptions();
                
                infoEl.innerHTML = infoText;
            } else {
                statusEl.textContent = '未加载升级表';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
            }
        }
        
        // 更新武器升级次数下拉选项
        function updateWeaponLevelViewerOptions() {
            const selectEl = document.getElementById('weaponLevelViewer');
            if (!selectEl) return;
            
            // 清空现有选项（保留"请选择"）
            selectEl.innerHTML = '<option value="-1">请选择</option>';
            
            if (weaponCostTable.length > 0) {
                // 按等级排序
                const sortedTable = [...weaponCostTable].sort((a, b) => a.level - b.level);
                sortedTable.forEach(weapon => {
                    const option = document.createElement('option');
                    option.value = weapon.level;
                    option.textContent = `升级次数 ${weapon.level}`;
                    selectEl.appendChild(option);
                });
            }
        }
        
        // 更新武器升级系数查看器显示
        window.updateWeaponCoeffViewer = function() {
            const selectEl = document.getElementById('weaponLevelViewer');
            const infoEl = document.getElementById('weaponCoeffInfo');
            const levelView = document.getElementById('currentWeaponLevelView');
            const coeffView = document.getElementById('currentWeaponCoeffView');
            const costView = document.getElementById('weaponUpgradeCostView');
            const ratioView = document.getElementById('weaponUpgradeRatioView');
            
            if (!selectEl || !infoEl) return;
            
            const selectedLevel = parseInt(selectEl.value);
            if (selectedLevel === -1) {
                infoEl.style.display = 'none';
                return;
            }
            
            // 查找当前等级的数据
            const currentWeaponData = weaponCostTable.find(w => w.level === selectedLevel);
            if (!currentWeaponData) {
                infoEl.style.display = 'none';
                return;
            }
            
            // 查找下一级的数据
            const nextWeaponData = weaponCostTable.find(w => w.level === selectedLevel + 1);
            
            // 获取当前和下一级的伤害系数
            const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            const nextCoeff = (nextWeaponData && nextWeaponData.damageCoeff !== undefined) ? parseFloat(nextWeaponData.damageCoeff) : currentCoeff;
            const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
            const upgradePercent = ((upgradeRatio - 1) * 100).toFixed(1);
            
            // 更新显示
            if (levelView) levelView.textContent = `Lv.${selectedLevel}`;
            if (coeffView) coeffView.textContent = currentCoeff.toFixed(2);
            if (costView) costView.textContent = `${currentWeaponData.cost} 银币`;
            if (ratioView) {
                if (nextWeaponData) {
                    ratioView.textContent = `${upgradeRatio.toFixed(3)} (提升 ${upgradePercent > 0 ? '+' : ''}${upgradePercent}%)`;
                    ratioView.style.color = upgradePercent > 0 ? '#51cf66' : '#ff6b6b';
                } else {
                    ratioView.textContent = '已达最高等级';
                    ratioView.style.color = '#999';
                }
            }
            
            infoEl.style.display = 'block';
        };

        // 更新怪物表信息显示
        function updateMonsterTableInfo() {
            const statusEl = document.getElementById('monsterTableStatus');
            const infoEl = document.getElementById('monsterTableInfo');
            
            if (monsterTable.length > 0) {
                statusEl.textContent = `已加载 ${monsterTable.length} 个怪物（已保存到本地）`;
                statusEl.style.color = '#51cf66';
                
                // 统计属性范围
                const attacks = monsterTable.map(m => m.baseAttack).filter(a => a > 0);
                const defenses = monsterTable.map(m => m.baseDefense).filter(d => d > 0);
                const hps = monsterTable.map(m => m.baseHp).filter(h => h > 0);
                
                let infoText = `怪物数量: ${monsterTable.length}`;
                if (attacks.length > 0) {
                    infoText += ` | 攻击力范围: ${Math.min(...attacks)} - ${Math.max(...attacks)}`;
                }
                if (defenses.length > 0) {
                    infoText += ` | 防御力范围: ${Math.min(...defenses)} - ${Math.max(...defenses)}`;
                }
                if (hps.length > 0) {
                    infoText += ` | 生命值范围: ${Math.min(...hps)} - ${Math.max(...hps)}`;
                }
                
                infoEl.textContent = infoText;
            } else {
                statusEl.textContent = '未加载怪物表';
                statusEl.style.color = '#666';
                infoEl.textContent = '';
            }
        }

        // 更新怪物选择下拉框
        function updateMonsterSelect() {
            const monsterSelect = document.getElementById('monsterSelect');
            if (!monsterSelect) return;
            
            monsterSelect.innerHTML = '<option value="">请选择怪物</option>';
            
            if (monsterTable.length === 0) {
                monsterSelect.innerHTML = '<option value="">请先上传怪物表</option>';
                return;
            }
            
            // 按ID排序
            const sortedMonsters = [...monsterTable].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedMonsters.forEach(monster => {
                const option = document.createElement('option');
                option.value = monster.id;
                option.textContent = `怪物 #${monster.id} (攻击${monster.baseAttack} 防御${monster.baseDefense} 生命${monster.baseHp})`;
                monsterSelect.appendChild(option);
            });
        }

        // 更新怪物属性显示（全局函数）
        window.updateMonsterAttributes = function() {
            const monsterSelect = document.getElementById('monsterSelect');
            const attributesDisplay = document.getElementById('monsterAttributesDisplay');
            const monsterDisplayName = document.getElementById('monsterDisplayName');
            const monsterAttrAttack = document.getElementById('monsterAttrAttack');
            const monsterAttrDefense = document.getElementById('monsterAttrDefense');
            const monsterAttrHp = document.getElementById('monsterAttrHp');
            const monsterAttrInfo = document.getElementById('monsterAttrInfo');
            
            if (!monsterSelect || !attributesDisplay) return;
            
            const selectedMonsterId = monsterSelect.value;
            
            if (!selectedMonsterId) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            const monster = monsterTable.find(m => m.id === selectedMonsterId);
            if (!monster) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            // 显示怪物信息
            monsterDisplayName.textContent = `怪物 #${monster.id}`;
            monsterAttrAttack.textContent = monster.baseAttack || 0;
            monsterAttrDefense.textContent = monster.baseDefense || 0;
            monsterAttrHp.textContent = monster.baseHp || 0;
            
            // 显示详细信息
            let infoText = `怪物ID: ${monster.id}`;
            if (monster.baseAttack > 0) {
                infoText += ` | 攻击力: ${monster.baseAttack}`;
            }
            if (monster.baseDefense > 0) {
                infoText += ` | 防御力: ${monster.baseDefense}`;
            }
            if (monster.baseHp > 0) {
                infoText += ` | 生命值: ${monster.baseHp}`;
            }
            monsterAttrInfo.textContent = infoText;
            
            attributesDisplay.style.display = 'block';
        };

        // 更新英雄表信息显示
        function updateHeroTableInfo() {
            const statusEl = document.getElementById('heroTableStatus');
            const infoEl = document.getElementById('heroTableInfo');
            
            if (heroTable.length > 0) {
                statusEl.textContent = `已加载 ${heroTable.length} 个英雄（已保存到本地）`;
                statusEl.style.color = '#51cf66';
                
                // 按职业统计英雄数量
                const statsByJob = {};
                let totalLevels = 0;
                let heroesWithLevels = 0;
                
                heroTable.forEach(hero => {
                    const jobId = parseInt(hero.heroclass) || 0;
                    const jobName = JOB_NAMES[jobId] || '未知';
                    if (!statsByJob[jobName]) {
                        statsByJob[jobName] = 0;
                    }
                    statsByJob[jobName]++;
                    
                    // 统计等级数据
                    if (hero.levels && Object.keys(hero.levels).length > 0) {
                        totalLevels += Object.keys(hero.levels).length;
                        heroesWithLevels++;
                    }
                });
                
                const statsText = Object.keys(statsByJob).map(job => {
                    const count = statsByJob[job];
                    return `${job}:${count}个`;
                }).join('；');
                
                let levelInfo = '';
                if (heroesWithLevels > 0) {
                    levelInfo = `<div style="margin-top: 5px;">等级数据：${heroesWithLevels}个英雄有等级数据，共${totalLevels}条记录</div>`;
                }
                
                infoEl.innerHTML = `<div style="margin-top: 5px;">英雄统计：${statsText}</div>${levelInfo}`;
                
                // 更新英雄选择下拉框
                updateHeroSelect();
                
                // 更新所有角色的英雄选择下拉框
                updateAllCharacterHeroSelects();
            } else {
                statusEl.textContent = '未加载英雄表';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
                
                // 清空英雄选择下拉框
                const heroSelect = document.getElementById('heroSelect');
                if (heroSelect) {
                    heroSelect.innerHTML = '<option value="">请先上传英雄表</option>';
                }
            }
        }

        // 更新英雄选择下拉框
        function updateHeroSelect() {
            const heroSelect = document.getElementById('heroSelect');
            if (!heroSelect) return;
            
            heroSelect.innerHTML = '<option value="">请选择英雄</option>';
            
            if (heroTable.length === 0) {
                heroSelect.innerHTML = '<option value="">请先上传英雄表</option>';
                return;
            }
            
            // 按ID排序
            const sortedHeroes = [...heroTable].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedHeroes.forEach(hero => {
                const jobName = JOB_NAMES[hero.heroclass] || '未知';
                const option = document.createElement('option');
                option.value = hero.id;
                option.textContent = `${hero.id} - ${hero.namecn} [${jobName}]${hero.quality ? ' - ' + hero.quality : ''}`;
                heroSelect.appendChild(option);
            });
        }

        // 更新英雄等级选择下拉框（全局函数）
        window.updateHeroLevelSelect = function() {
            const heroSelect = document.getElementById('heroSelect');
            const levelSelect = document.getElementById('heroLevelSelect');
            const attributesDisplay = document.getElementById('heroAttributesDisplay');
            
            if (!heroSelect || !levelSelect) return;
            
            const selectedHeroId = heroSelect.value;
            levelSelect.innerHTML = '<option value="">请选择等级</option>';
            if (attributesDisplay) {
                attributesDisplay.style.display = 'none';
            }
            
            if (!selectedHeroId) {
                levelSelect.innerHTML = '<option value="">请先选择英雄</option>';
                return;
            }
            
            const hero = heroTable.find(h => h.id === selectedHeroId);
            if (!hero) return;
            
            // 获取该英雄的所有等级
            const levels = hero.levels ? Object.keys(hero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
            
            if (levels.length === 0) {
                levelSelect.innerHTML = '<option value="">该英雄暂无等级数据</option>';
                return;
            }
            
            levels.forEach(level => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `等级 ${level}`;
                levelSelect.appendChild(option);
            });
            
            // 自动选择第一个等级并显示属性
            if (levels.length > 0) {
                levelSelect.value = levels[0];
                updateHeroAttributes();
            }
        }

        // 更新英雄属性显示（全局函数）
        window.updateHeroAttributes = function() {
            const heroSelect = document.getElementById('heroSelect');
            const levelSelect = document.getElementById('heroLevelSelect');
            const attributesDisplay = document.getElementById('heroAttributesDisplay');
            const heroDisplayName = document.getElementById('heroDisplayName');
            const heroAttrAttack = document.getElementById('heroAttrAttack');
            const heroAttrDefense = document.getElementById('heroAttrDefense');
            const heroAttrHp = document.getElementById('heroAttrHp');
            const heroAttrInfo = document.getElementById('heroAttrInfo');
            
            if (!heroSelect || !levelSelect || !attributesDisplay) return;
            
            const selectedHeroId = heroSelect.value;
            const selectedLevel = parseInt(levelSelect.value);
            
            if (!selectedHeroId || !selectedLevel) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            const hero = heroTable.find(h => h.id === selectedHeroId);
            if (!hero) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            // 获取该等级的属性
            const levelAttrs = hero.levels && hero.levels[selectedLevel] ? hero.levels[selectedLevel] : {};
            
            // 调试：显示英雄等级数据
            console.log(`查看英雄属性 - ID: ${selectedHeroId}, 等级: ${selectedLevel}`, {
                hero: hero,
                hasLevels: !!hero.levels,
                levelKeys: hero.levels ? Object.keys(hero.levels) : [],
                currentLevelAttrs: levelAttrs
            });
            
            // 计算累计属性（从等级1到当前等级）
            let totalAttack = 0;
            let totalDefense = 0;
            let totalHp = 0;
            
            for (let level = 1; level <= selectedLevel; level++) {
                if (hero.levels && hero.levels[level]) {
                    const levelData = hero.levels[level];
                    totalAttack += (levelData.baseAttack || 0);
                    totalDefense += (levelData.baseDefense || 0);
                    totalHp += (levelData.baseHp || 0);
                    
                    // 调试：显示每级属性
                    if (level <= 3) {
                        console.log(`等级 ${level} 属性:`, levelData);
                    }
                }
            }
            
            console.log(`累计属性（1-${selectedLevel}级）:`, { totalAttack, totalDefense, totalHp });
            
            // 显示英雄信息
            const jobName = JOB_NAMES[hero.heroclass] || '未知';
            if (heroDisplayName) {
                heroDisplayName.textContent = `${hero.namecn} [${jobName}] - 等级 ${selectedLevel}`;
            }
            
            // 显示属性值
            if (heroAttrAttack) {
                heroAttrAttack.textContent = totalAttack > 0 ? totalAttack.toLocaleString() : '-';
            }
            if (heroAttrDefense) {
                heroAttrDefense.textContent = totalDefense > 0 ? totalDefense.toLocaleString() : '-';
            }
            if (heroAttrHp) {
                heroAttrHp.textContent = totalHp > 0 ? totalHp.toLocaleString() : '-';
            }
            
            // 显示详细信息
            if (heroAttrInfo) {
                const levelAttrsText = levelAttrs.baseAttack || levelAttrs.baseDefense || levelAttrs.baseHp 
                    ? `本级属性：${levelAttrs.baseAttack || 0} 攻击 / ${levelAttrs.baseDefense || 0} 防御 / ${levelAttrs.baseHp || 0} 生命`
                    : '本级无属性数据';
                heroAttrInfo.innerHTML = `
                    <div>英雄ID: ${hero.id}</div>
                    <div style="margin-top: 5px;">${levelAttrsText}</div>
                    <div style="margin-top: 5px;">累计属性（1-${selectedLevel}级）: ${totalAttack} 攻击 / ${totalDefense} 防御 / ${totalHp} 生命</div>
                `;
            }
            
            // 显示属性面板
            attributesDisplay.style.display = 'block';
        }

        // 加载装备表（全局函数）
        window.loadEquipmentTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // 读取第一个工作表
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                    // 解析装备数据（新格式：id, namecn, heroclass, type, hp, atk, def）
                    // heroclass 兼容数字和文本格式
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // 如果是数字，直接转换
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // 如果是文本，转换为数字
                        const textValue = String(heroclassValue).trim();
                        if (textValue === '坦克' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === '战士' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === '射手' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === '辅助' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    equipmentTable = jsonData.map((row, index) => {
                        const id = row['id'] || row['ID'] || `eq_${index}`;
                        const namecn = row['namecn'] || row['nameCN'] || row['名称'] || `装备${index + 1}`;
                        
                        // 尝试多种方式获取职业：heroclass, heroClass, 职业, class, job
                        let heroclass = parseHeroClass(
                            row['heroclass'] || row['heroClass'] || row['职业'] || 
                            row['class'] || row['Class'] || row['job'] || row['Job']
                        );
                        
                        // 如果职业为0，尝试从装备名称推断（如"坦克头"、"战士手"等）
                        if (heroclass === 0 && namecn) {
                            const nameStr = String(namecn).trim();
                            if (nameStr.includes('坦克')) heroclass = 1;
                            else if (nameStr.includes('战士')) heroclass = 2;
                            else if (nameStr.includes('射手')) heroclass = 3;
                            else if (nameStr.includes('辅助')) heroclass = 4;
                        }
                        
                        // 如果职业仍为0，尝试从装备ID推断（如ID中包含职业信息）
                        if (heroclass === 0 && id) {
                            const idStr = String(id).trim();
                            // 假设ID格式如：13111001，其中第3位可能是职业（1=坦克，2=战士，3=射手，4=辅助）
                            // 或者ID中包含职业标识
                            if (idStr.length >= 3) {
                                const thirdChar = parseInt(idStr[2]);
                                if (thirdChar >= 1 && thirdChar <= 4) {
                                    heroclass = thirdChar;
                                }
                            }
                        }
                        
                        const type = String(row['type'] || row['Type'] || row['部位'] || '').trim();
                        const hp = parseInt(row['hp'] || row['HP'] || row['生命值'] || 0);
                        const atk = parseInt(row['atk'] || row['ATK'] || row['攻击'] || 0);
                        const def = parseInt(row['def'] || row['DEF'] || row['防御'] || 0);
                        
                        return {
                            id: id.toString(),
                            namecn: namecn,
                            heroclass: heroclass,
                            type: type,
                            hp: hp,
                            atk: atk,
                            def: def
                        };
                    });

                    // 保存到localStorage（永久保存，直到下次手动上传替换）
                    localStorage.setItem(EQUIPMENT_STORAGE_KEY, JSON.stringify(equipmentTable));
                    console.log('装备表已保存到本地，共', equipmentTable.length, '件装备');
                    console.log('装备表示例（前3件）:', equipmentTable.slice(0, 3).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        type: eq.type
                    })));

                    // 更新界面
                    updateJobEquipmentPanel();
                    updateEquipmentTableInfo();
                    
                    showMessage(`成功加载${equipmentTable.length}件装备，已保存到本地`, 'success');
                } catch (error) {
                    console.error('读取装备表失败:', error);
                    showMessage('读取装备表失败，请检查文件格式', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // 更新职业装备面板
        function updateJobEquipmentPanel() {
            const panel = document.getElementById('jobEquipmentPanel');
            if (!panel) return;

            panel.innerHTML = Object.keys(JOB_NAMES).map(jobId => {
                const jobIdNum = parseInt(jobId);
                const jobName = JOB_NAMES[jobIdNum];
                const jobEquipment = characterEquipment[jobIdNum] || { head: null, body: null, hand: null, foot: null };
                
                // 获取该职业的装备列表（按部位分组）
                // 使用parseHeroClass函数兼容文本格式
                function parseHeroClassForFilter(heroclassValue) {
                    if (!heroclassValue) return 0;
                    
                    // 如果是数字，直接转换
                    const numValue = parseInt(heroclassValue);
                    if (!isNaN(numValue) && numValue > 0) {
                        return numValue;
                    }
                    
                    // 如果是文本，转换为数字
                    const textValue = String(heroclassValue).trim();
                    if (textValue === '坦克' || textValue === 'Tank' || textValue === '1') return 1;
                    if (textValue === '战士' || textValue === 'Warrior' || textValue === '2') return 2;
                    if (textValue === '射手' || textValue === 'Archer' || textValue === '3') return 3;
                    if (textValue === '辅助' || textValue === 'Support' || textValue === '4') return 4;
                    
                    return 0;
                }
                
                // 筛选装备：兼容多种格式
                const equipmentByType = {
                    head: equipmentTable.filter(eq => {
                        // heroclass可能是数字或需要解析的文本
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        // 兼容多种部位名称格式
                        return eqJob === jobIdNum && (
                            eqType === '头' || eqType === 'head' || eqType === 'Head' || 
                            eqType === '头部' || eqType === '头盔'
                        );
                    }),
                    body: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === '身' || eqType === 'body' || eqType === 'Body' || 
                            eqType === '身体' || eqType === '胸甲' || eqType === '护甲'
                        );
                    }),
                    hand: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === '手' || eqType === 'hand' || eqType === 'Hand' || 
                            eqType === '手部' || eqType === '武器'
                        );
                    }),
                    foot: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === '脚' || eqType === 'foot' || eqType === 'Foot' || 
                            eqType === '脚部' || eqType === '鞋子' || eqType === '靴子'
                        );
                    })
                };
                
                // 调试信息
                console.log(`职业${jobName}(${jobIdNum})装备筛选结果:`, {
                    head: equipmentByType.head.length,
                    body: equipmentByType.body.length,
                    hand: equipmentByType.hand.length,
                    foot: equipmentByType.foot.length
                });
                
                // 详细调试：显示前5件装备的数据格式（仅对第一个职业执行一次）
                if (jobIdNum === 1 && equipmentTable.length > 0) {
                    console.log('装备表数据示例（前5件）:', equipmentTable.slice(0, 5).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        heroclassType: typeof eq.heroclass,
                        type: eq.type,
                        typeType: typeof eq.type
                    })));
                    
                    // 测试筛选逻辑
                    const testEq = equipmentTable[0];
                    if (testEq) {
                        console.log('测试装备筛选:', {
                            testEq: testEq,
                            parsedHeroclass: parseHeroClassForFilter(testEq.heroclass),
                            parsedType: String(testEq.type || '').trim(),
                            matchesJob1: parseHeroClassForFilter(testEq.heroclass) === 1,
                            matchesHead: String(testEq.type || '').trim() === '头'
                        });
                    }
                    
                    // 统计所有唯一的heroclass和type值
                    const uniqueHeroclass = [...new Set(equipmentTable.map(eq => eq.heroclass))].slice(0, 10);
                    const uniqueType = [...new Set(equipmentTable.map(eq => String(eq.type || '').trim()))].slice(0, 10);
                    console.log('装备表中唯一的heroclass值（前10个）:', uniqueHeroclass);
                    console.log('装备表中唯一的type值（前10个）:', uniqueType);
                }
                
                // 详细调试：显示前5件装备的数据格式
                if (jobIdNum === 1 && equipmentTable.length > 0) {
                    console.log('装备表数据示例（前5件）:', equipmentTable.slice(0, 5).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        heroclassType: typeof eq.heroclass,
                        type: eq.type,
                        typeType: typeof eq.type
                    })));
                    
                    // 测试筛选逻辑
                    const testEq = equipmentTable[0];
                    if (testEq) {
                        console.log('测试装备筛选:', {
                            testEq: testEq,
                            parsedHeroclass: parseHeroClassForFilter(testEq.heroclass),
                            parsedType: String(testEq.type || '').trim(),
                            matchesJob1: parseHeroClassForFilter(testEq.heroclass) === 1,
                            matchesHead: String(testEq.type || '').trim() === '头'
                        });
                    }
                }

                // 计算当前职业的总装备加成
                let totalHpBonus = 0, totalAtkBonus = 0, totalDefBonus = 0;
                ['head', 'body', 'hand', 'foot'].forEach(type => {
                    const equipmentId = jobEquipment[type];
                    if (equipmentId) {
                        const equipment = equipmentTable.find(eq => eq.id === equipmentId);
                        if (equipment) {
                            totalHpBonus += equipment.hp || 0;
                            totalAtkBonus += equipment.atk || 0;
                            totalDefBonus += equipment.def || 0;
                        }
                    }
                });
                
                return `
                    <div style="background: white; border-radius: 12px; padding: 15px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; font-size: 1.1em; color: #667eea; margin-bottom: 15px;">${jobName}</div>
                        ${Object.keys(EQUIPMENT_TYPES).map(typeKey => {
                            const typeName = EQUIPMENT_TYPES[typeKey];
                            const typeKeyLower = typeKey.toLowerCase();
                            const availableEquipments = equipmentByType[typeKeyLower] || [];
                            const currentEquipmentId = jobEquipment[typeKeyLower] || '';
                            const currentEquipment = currentEquipmentId ? equipmentTable.find(eq => eq.id === currentEquipmentId) : null;
                            
                            return `
                                <div style="margin-bottom: 12px;">
                                    <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666;">${typeName}部：</label>
                                    <select 
                                        class="job-equipment-select" 
                                        data-job="${jobIdNum}" 
                                        data-type="${typeKeyLower}"
                                        onchange="updateJobEquipment(${jobIdNum}, '${typeKeyLower}', this.value)"
                                        style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                                        <option value="">无装备</option>
                                        ${availableEquipments.length > 0 ? availableEquipments.map(eq => {
                                            const displayName = eq.namecn || eq.name || eq.id || '未知装备';
                                            const isSelected = String(eq.id) === String(currentEquipmentId);
                                            const stats = [];
                                            if (eq.hp) stats.push(`HP+${eq.hp}`);
                                            if (eq.atk) stats.push(`攻击+${eq.atk}`);
                                            if (eq.def) stats.push(`防御+${eq.def}`);
                                            const statsText = stats.length > 0 ? ` (${stats.join(', ')})` : '';
                                            return `<option value="${eq.id}" ${isSelected ? 'selected' : ''}>${displayName}${statsText}</option>`;
                                        }).join('') : '<option value="" disabled>暂无该部位装备</option>'}
                                    </select>
                                    ${currentEquipment ? `
                                        <div style="margin-top: 4px; font-size: 0.8em; color: #888; padding-left: 4px;">
                                            ${currentEquipment.hp ? `<span style="color: #4CAF50;">HP +${currentEquipment.hp}</span>` : ''}
                                            ${currentEquipment.atk ? `<span style="color: #f44336; margin-left: 8px;">攻击 +${currentEquipment.atk}</span>` : ''}
                                            ${currentEquipment.def ? `<span style="color: #2196F3; margin-left: 8px;">防御 +${currentEquipment.def}</span>` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }).join('')}
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">总加成：</div>
                            <div style="font-size: 0.9em; font-weight: 600;">
                                ${totalHpBonus > 0 ? `<span style="color: #4CAF50;">HP +${totalHpBonus}</span>` : ''}
                                ${totalAtkBonus > 0 ? `<span style="color: #f44336; margin-left: 8px;">攻击 +${totalAtkBonus}</span>` : ''}
                                ${totalDefBonus > 0 ? `<span style="color: #2196F3; margin-left: 8px;">防御 +${totalDefBonus}</span>` : ''}
                                ${totalHpBonus === 0 && totalAtkBonus === 0 && totalDefBonus === 0 ? '<span style="color: #999;">无加成</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 更新职业装备（全局函数）
        window.updateJobEquipment = function(jobId, type, equipmentId) {
            if (!characterEquipment[jobId]) {
                characterEquipment[jobId] = { head: null, body: null, hand: null, foot: null };
            }
            characterEquipment[jobId][type] = equipmentId || null;
            saveCharacterEquipment();
            
            // 更新职业装备面板（刷新总加成显示）
            updateJobEquipmentPanel();
            
            // 更新所有该职业的角色属性
            characters.forEach(char => {
                if (char.job == jobId) {
                    applyJobEquipmentStats(char);
                }
            });
            
            // 更新最终属性面板
            updateFinalAttributesPanel();
            
            // 更新所有关卡的伤害信息（因为装备属性已改变）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // 应用职业装备属性
        function applyJobEquipmentStats(char) {
            const jobEquipment = characterEquipment[char.job] || { head: null, body: null, hand: null, foot: null };
            let totalHp = 0, totalAtk = 0, totalDef = 0;
            
            // 累加所有部位的装备属性
            ['head', 'body', 'hand', 'foot'].forEach(type => {
                const equipmentId = jobEquipment[type];
                if (equipmentId) {
                    const equipment = equipmentTable.find(eq => eq.id === equipmentId);
                    if (equipment) {
                        totalHp += equipment.hp || 0;
                        totalAtk += equipment.atk || 0;
                        totalDef += equipment.def || 0;
                    }
                }
            });
            
            // 保存装备加成
            char.equipmentHpBonus = totalHp;
            char.equipmentAtkBonus = totalAtk;
            char.equipmentDefBonus = totalDef;
            
            // 计算平台属性加成
            const platformMultiplier = platformConfig.heroCount + platformConfig.heroLevelSum;
            const platformAttackBonus = platformConfig.attackCoeff * platformMultiplier;
            const platformDefenseBonus = platformConfig.defenseCoeff * platformMultiplier;
            const platformHpBonus = platformConfig.hpCoeff * platformMultiplier;
            
            // 保存平台加成
            char.platformAttackBonus = platformAttackBonus;
            char.platformDefenseBonus = platformDefenseBonus;
            char.platformHpBonus = platformHpBonus;
            
            // 保存车辆加成
            char.vehicleAttackBonus = vehicleConfig.attack || 0;
            char.vehicleDefenseBonus = vehicleConfig.defense || 0;
            char.vehicleHpBonus = vehicleConfig.hp || 0;
            
            // 应用属性加成（最终属性，用于战斗计算）
            // 最终属性 = 基础属性 + 装备加成 + 平台加成 + 车辆加成
            char.attack = (char.baseAttack || 0) + totalAtk + platformAttackBonus + vehicleConfig.attack;
            char.defense = (char.baseDefense || 0) + totalDef + platformDefenseBonus + vehicleConfig.defense;
            const hpBonus = totalHp + platformHpBonus + vehicleConfig.hp;
            char.maxHp = (char.baseHp || 0) + hpBonus;
            char.hp = Math.min(char.hp || char.maxHp, char.maxHp); // 调整当前血量不超过最大血量
            
            // 计算角色5的最终回血速度 = 最终攻击力 × 回血系数
            if (char.id === 5 && char.healRate !== undefined && char.healRate !== null) {
                char.finalHealRate = char.attack * (char.healRate || 0);
            } else {
                char.finalHealRate = 0;
            }
            
            // 更新最终属性面板
            updateFinalAttributesPanel();
        }

        // 更新平台属性配置（全局函数）
        window.updatePlatformAttributes = function() {
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount').value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum').value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // 更新平台加成信息显示
            const multiplier = platformConfig.heroCount + platformConfig.heroLevelSum;
            const attackBonus = platformConfig.attackCoeff * multiplier;
            const defenseBonus = platformConfig.defenseCoeff * multiplier;
            const hpBonus = platformConfig.hpCoeff * multiplier;
            
            const infoEl = document.getElementById('platformBonusInfo');
            if (infoEl) {
                infoEl.innerHTML = `
                    <div>当前平台加成：攻击 +${attackBonus.toFixed(2)}，防御 +${defenseBonus.toFixed(2)}，生命 +${hpBonus.toFixed(2)}</div>
                    <div style="margin-top: 5px; font-size: 0.85em; color: #999;">
                        计算公式：系数 × (${platformConfig.heroCount} + ${platformConfig.heroLevelSum}) = 系数 × ${multiplier}
                    </div>
                `;
            }
            
            // 重新应用所有角色的属性（包含平台加成）
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // 更新所有关卡的伤害信息（因为平台属性影响角色最终属性）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // 更新车辆属性配置（全局函数）
        window.updateVehicleAttributes = function() {
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // 更新车辆加成信息显示
            const infoEl = document.getElementById('vehicleBonusInfo');
            if (infoEl) {
                infoEl.innerHTML = `
                    <div>当前车辆加成：攻击 +${vehicleConfig.attack}，防御 +${vehicleConfig.defense}，生命 +${vehicleConfig.hp}</div>
                `;
            }
            
            // 重新应用所有角色的属性（包含车辆加成）
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // 更新所有关卡的伤害信息（因为车辆属性影响角色最终属性）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }
        
        // 更新角色最终属性面板（同时更新主配置和战斗模拟页签）
        function updateFinalAttributesPanel() {
            // 生成属性面板HTML内容
            const panelContent = characters.map(char => {
                const baseHp = char.baseHp || char.hp;
                const baseAtk = char.baseAttack || char.attack;
                const baseDef = char.baseDefense || char.defense;
                const eqHp = char.equipmentHpBonus || 0;
                const eqAtk = char.equipmentAtkBonus || 0;
                const eqDef = char.equipmentDefBonus || 0;
                const platformHp = char.platformHpBonus || 0;
                const platformAtk = char.platformAttackBonus || 0;
                const platformDef = char.platformDefenseBonus || 0;
                const vehicleHp = char.vehicleHpBonus || 0;
                const vehicleAtk = char.vehicleAttackBonus || 0;
                const vehicleDef = char.vehicleDefenseBonus || 0;
                const finalHp = char.maxHp || baseHp;
                const finalAtk = char.attack || baseAtk;
                const finalDef = char.defense || baseDef;
                
                return `
                    <div style="background: white; border-radius: 12px; padding: 15px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; font-size: 1.1em; color: #667eea; margin-bottom: 12px;">
                            ${char.name} <span style="font-size: 0.85em; color: #999; font-weight: 400;">[${JOB_NAMES[char.job]}]</span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">基础属性：</div>
                            <div style="font-size: 0.9em;">
                                <span style="color: #4CAF50;">HP ${baseHp}</span>
                                <span style="color: #f44336; margin-left: 12px;">攻击 ${baseAtk}</span>
                                <span style="color: #2196F3; margin-left: 12px;">防御 ${baseDef}</span>
                            </div>
                        </div>
                        ${eqHp > 0 || eqAtk > 0 || eqDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">装备加成：</div>
                            <div style="font-size: 0.9em;">
                                ${eqHp > 0 ? `<span style="color: #4CAF50;">HP +${eqHp}</span>` : ''}
                                ${eqAtk > 0 ? `<span style="color: #f44336; margin-left: ${eqHp > 0 ? '12px' : '0'};">攻击 +${eqAtk}</span>` : ''}
                                ${eqDef > 0 ? `<span style="color: #2196F3; margin-left: ${(eqHp > 0 || eqAtk > 0) ? '12px' : '0'};">防御 +${eqDef}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${platformHp > 0 || platformAtk > 0 || platformDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">平台加成：</div>
                            <div style="font-size: 0.9em;">
                                ${platformHp > 0 ? `<span style="color: #4CAF50;">HP +${platformHp.toFixed(2)}</span>` : ''}
                                ${platformAtk > 0 ? `<span style="color: #f44336; margin-left: ${platformHp > 0 ? '12px' : '0'};">攻击 +${platformAtk.toFixed(2)}</span>` : ''}
                                ${platformDef > 0 ? `<span style="color: #2196F3; margin-left: ${(platformHp > 0 || platformAtk > 0) ? '12px' : '0'};">防御 +${platformDef.toFixed(2)}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${vehicleHp > 0 || vehicleAtk > 0 || vehicleDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">车辆加成：</div>
                            <div style="font-size: 0.9em;">
                                ${vehicleHp > 0 ? `<span style="color: #4CAF50;">HP +${vehicleHp}</span>` : ''}
                                ${vehicleAtk > 0 ? `<span style="color: #f44336; margin-left: ${vehicleHp > 0 ? '12px' : '0'};">攻击 +${vehicleAtk}</span>` : ''}
                                ${vehicleDef > 0 ? `<span style="color: #2196F3; margin-left: ${(vehicleHp > 0 || vehicleAtk > 0) ? '12px' : '0'};">防御 +${vehicleDef}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        <div style="padding-top: 8px; border-top: 1px solid #e0e0e0; margin-top: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">最终属性：</div>
                            <div style="font-size: 1em; font-weight: 600;">
                                <span style="color: #4CAF50;">HP ${finalHp}</span>
                                <span style="color: #f44336; margin-left: 12px;">攻击 ${finalAtk}</span>
                                <span style="color: #2196F3; margin-left: 12px;">防御 ${finalDef}</span>
                                ${char.id === 5 && char.finalHealRate !== undefined && char.finalHealRate > 0 ? `
                                <span style="color: #9C27B0; margin-left: 12px;">回血 ${char.finalHealRate.toFixed(2)}/秒</span>
                                ` : ''}
                            </div>
                            ${char.id === 5 && char.healRate !== undefined && char.healRate > 0 ? `
                            <div style="font-size: 0.8em; color: #999; margin-top: 4px;">
                                回血系数: ${char.healRate.toFixed(2)} × 最终攻击力 ${finalAtk} = ${char.finalHealRate ? char.finalHealRate.toFixed(2) : (finalAtk * char.healRate).toFixed(2)}/秒
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // 更新主配置页签中的最终属性面板
            const mainPanel = document.getElementById('finalAttributesPanel');
            if (mainPanel) {
                mainPanel.innerHTML = panelContent;
            }
            
            // 更新战斗模拟页签中的最终属性面板
            const battlePanel = document.getElementById('battleFinalAttributesPanel');
            if (battlePanel) {
                battlePanel.innerHTML = panelContent;
            }
        }

        // 更新装备表信息显示
        function updateEquipmentTableInfo() {
            const statusEl = document.getElementById('equipmentTableStatus');
            const infoEl = document.getElementById('equipmentTableInfo');
            
            if (equipmentTable.length > 0) {
                statusEl.textContent = `已加载 ${equipmentTable.length} 件装备（已保存到本地）`;
                statusEl.style.color = '#51cf66';
                
                // 按职业和部位统计装备数量
                const statsByJob = {};
                equipmentTable.forEach(eq => {
                    const jobId = parseInt(eq.heroclass) || 0;
                    const jobName = JOB_NAMES[jobId] || '未知';
                    if (!statsByJob[jobName]) {
                        statsByJob[jobName] = { head: 0, body: 0, hand: 0, foot: 0, total: 0 };
                    }
                    const type = String(eq.type || '').trim();
                    if (type === '头') statsByJob[jobName].head++;
                    else if (type === '身') statsByJob[jobName].body++;
                    else if (type === '手') statsByJob[jobName].hand++;
                    else if (type === '脚') statsByJob[jobName].foot++;
                    statsByJob[jobName].total++;
                });
                
                const statsText = Object.keys(statsByJob).map(job => {
                    const stats = statsByJob[job];
                    return `${job}:${stats.total}件(头${stats.head}/身${stats.body}/手${stats.hand}/脚${stats.foot})`;
                }).join('；');
                infoEl.innerHTML = `<div style="margin-top: 5px;">装备统计：${statsText}</div>`;
            } else {
                statusEl.textContent = '未加载装备表';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
            }
        }

        // 初始化角色界面
        // 初始化关卡配置界面
        function initStageConfig() {
            const grid = document.getElementById('stageConfigGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage] || {
                    monsterId: '',
                    atkSpeed: 0.33,
                    damageCoeff: 1,
                    hpCoeff: 0
                };
                
                // 获取怪物信息（如果已选择）
                let monsterInfo = '';
                if (stageData.monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === stageData.monsterId);
                    if (monster) {
                        monsterInfo = ` (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                    }
                }
                
                const stageCard = document.createElement('div');
                stageCard.id = `stage-card-${stage}`;
                stageCard.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;';
                stageCard.innerHTML = `
                    <div style="font-weight: 600; color: #333; margin-bottom: 10px; font-size: 1.05em;">第 ${stage} 关</div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">怪物ID</label>
                        <select id="stage-${stage}-monster" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                            <option value="">未选择</option>
                        </select>
                        <div style="font-size: 0.8em; color: #999; margin-top: 4px;" id="stage-${stage}-monster-info">${monsterInfo}</div>
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">攻击速度（次/秒）</label>
                        <input type="number" id="stage-${stage}-atkSpeed" min="0.1" max="10" step="0.01" value="${stageData.atkSpeed}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">攻击系数</label>
                        <input type="number" id="stage-${stage}-damageCoeff" min="0" step="0.01" value="${stageData.damageCoeff}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">血量系数</label>
                        <input type="number" id="stage-${stage}-hpCoeff" min="0" step="0.01" value="${stageData.hpCoeff}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="challengeStage(${stage})" style="padding: 8px 16px; font-size: 0.9em; flex: 1;">挑战</button>
                        <div id="stage-${stage}-result" style="font-size: 0.9em; font-weight: 600; flex: 1; text-align: center;"></div>
                    </div>
                    <div id="stage-${stage}-damage-info" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;">
                        <div style="margin-bottom: 5px;">1. 怪物对角色1基础伤害: <span id="stage-${stage}-monster-to-char1">-</span></div>
                        <div style="margin-bottom: 5px;">2. 角色1对怪物基础伤害: <span id="stage-${stage}-char1-to-monster">-</span></div>
                        <div>3. 角色3/角色4平均基础伤害: <span id="stage-${stage}-char34-avg">-</span></div>
                    </div>
                `;
                grid.appendChild(stageCard);
            }
            
            // 更新所有关卡怪物选择下拉框（填充怪物数据）
            updateStageMonsterSelects();
        }

        // 更新所有关卡怪物选择下拉框
        function updateStageMonsterSelects() {
            for (let stage = 1; stage <= 20; stage++) {
                const select = document.getElementById(`stage-${stage}-monster`);
                if (!select) continue;
                
                // 保存当前选择的值
                const currentValue = select.value || stageConfig[stage]?.monsterId || '';
                
                // 清空并重新填充
                select.innerHTML = '<option value="">未选择</option>';
                
                if (monsterTable.length > 0) {
                    // 按ID排序
                    const sortedMonsters = [...monsterTable].sort((a, b) => {
                        const idA = parseInt(a.id) || 0;
                        const idB = parseInt(b.id) || 0;
                        return idA - idB;
                    });
                    
                    sortedMonsters.forEach(monster => {
                        const option = document.createElement('option');
                        option.value = monster.id;
                        option.textContent = `怪物 #${monster.id} (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                        select.appendChild(option);
                    });
                }
                
                // 恢复之前的选择
                if (currentValue) {
                    select.value = currentValue;
                    updateStageConfig(stage);
                } else {
                    // 即使没有选择，也更新伤害信息（显示为"-"）
                    updateStageDamageInfo(stage);
                }
            }
            
            // 更新所有关卡的伤害信息（因为角色属性可能已改变）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // 初始化25波怪物数据输入界面
        function initBattleWaveData() {
            const grid = document.getElementById('battleWaveDataGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            grid.style.display = 'flex';
            grid.style.flexDirection = 'column';
            grid.style.gap = '20px';
            
            // 创建5个分组，每组5波
            for (let group = 0; group < 5; group++) {
                const groupStartWave = group * 5 + 1;
                const groupEndWave = group * 5 + 5;
                
                // 创建分组容器
                const groupContainer = document.createElement('div');
                groupContainer.style.cssText = 'background: #f8f9ff; border: 2px solid #667eea; border-radius: 12px; padding: 20px;';
                
                // 分组标题
                const groupTitle = document.createElement('div');
                groupTitle.style.cssText = 'font-weight: 700; color: #667eea; margin-bottom: 15px; font-size: 1.15em; padding-bottom: 10px; border-bottom: 2px solid #667eea;';
                groupTitle.textContent = `据点${group + 1} (第${groupStartWave}-${groupEndWave}波)`;
                groupContainer.appendChild(groupTitle);
                
                // 创建组内的网格容器
                const groupGrid = document.createElement('div');
                groupGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 15px;';
                
                // 为每组创建5波
                for (let wave = groupStartWave; wave <= groupEndWave; wave++) {
                    const waveData = battleWaveData[wave] || {
                        monsterId: '',
                        attack: 10,
                        defense: 5,
                        hp: 50,
                        atkSpeed: 0.33,
                        damageCoeff: 1,
                        hpCoeff: 1,
                        spawnRate: 1,
                        duration: 10
                    };
                    
                    // 获取怪物信息（如果已选择）
                    let monsterInfo = '';
                    if (waveData.monsterId && monsterTable.length > 0) {
                        const monster = monsterTable.find(m => m.id === waveData.monsterId);
                        if (monster) {
                            monsterInfo = ` (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                        }
                    }
                    
                    const waveCard = document.createElement('div');
                    waveCard.id = `battle-wave-card-${wave}`;
                    waveCard.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;';
                    
                    // 第一波添加复制按钮
                    const copyButtonHtml = wave === 1 ? `
                        <div style="margin-bottom: 10px;">
                            <button class="btn btn-secondary" onclick="copyWave1ToOthers()" style="padding: 8px 16px; font-size: 0.9em; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                                📋 复制到其他波次
                            </button>
                        </div>
                    ` : '';
                    
                    waveCard.innerHTML = `
                        <div style="font-weight: 600; color: #333; margin-bottom: 10px; font-size: 1.05em;">第 ${wave} 波</div>
                        ${copyButtonHtml}
                        <div class="input-group" style="margin-bottom: 10px;">
                            <label style="font-size: 0.9em;">怪物ID</label>
                            <select id="battle-wave-${wave}-monster" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                                <option value="">手动输入</option>
                            </select>
                            <div style="font-size: 0.8em; color: #999; margin-top: 4px;" id="battle-wave-${wave}-monster-info">${monsterInfo}</div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.85em;">攻击力</label>
                                <input type="number" id="battle-wave-${wave}-attack" min="0" value="${waveData.attack}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">防御力</label>
                                <input type="number" id="battle-wave-${wave}-defense" min="0" value="${waveData.defense}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">生命值</label>
                                <input type="number" id="battle-wave-${wave}-hp" min="0" value="${waveData.hp}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.85em;">攻速</label>
                                <input type="number" id="battle-wave-${wave}-atkSpeed" min="0.1" max="10" step="0.01" value="${waveData.atkSpeed}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">伤害系数</label>
                                <input type="number" id="battle-wave-${wave}-damageCoeff" min="0" step="0.01" value="${waveData.damageCoeff}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">生命值倍率</label>
                                <input type="number" id="battle-wave-${wave}-hpCoeff" min="0" step="0.01" value="${waveData.hpCoeff}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.9em;">每秒出几只</label>
                                <input type="number" id="battle-wave-${wave}-spawnRate" min="0.1" max="100" step="0.1" value="${waveData.spawnRate}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.9em;">持续多少秒</label>
                                <input type="number" id="battle-wave-${wave}-duration" min="1" max="1000" step="1" value="${waveData.duration}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.9em;">击杀银币奖励</label>
                                <input type="number" id="battle-wave-${wave}-coinReward" min="0" value="${waveData.coinReward || 0}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                        </div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                            <div>总怪物数: <span id="battle-wave-${wave}-total-count">-</span></div>
                        </div>
                    `;
                    groupGrid.appendChild(waveCard);
                }
                
                groupContainer.appendChild(groupGrid);
                grid.appendChild(groupContainer);
            }
            
            // 更新所有波次怪物选择下拉框
            updateBattleWaveMonsterSelects();
            
            // 更新所有波次的总怪物数显示
            updateBattleWaveTotalCounts();
        }

        // 更新所有波次怪物选择下拉框
        function updateBattleWaveMonsterSelects() {
            for (let wave = 1; wave <= 25; wave++) {
                const select = document.getElementById(`battle-wave-${wave}-monster`);
                if (!select) continue;
                
                // 保存当前选择的值
                const currentValue = select.value || battleWaveData[wave]?.monsterId || '';
                
                // 清空并重新填充
                select.innerHTML = '<option value="">手动输入</option>';
                
                if (monsterTable.length > 0) {
                    // 按ID排序
                    const sortedMonsters = [...monsterTable].sort((a, b) => {
                        const idA = parseInt(a.id) || 0;
                        const idB = parseInt(b.id) || 0;
                        return idA - idB;
                    });
                    
                    sortedMonsters.forEach(monster => {
                        const option = document.createElement('option');
                        option.value = monster.id;
                        option.textContent = `怪物 #${monster.id} (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                        select.appendChild(option);
                    });
                }
                
                // 恢复之前的选择
                if (currentValue) {
                    select.value = currentValue;
                    updateBattleWaveData(wave);
                }
            }
        }

        // 更新波次数据（全局函数）
        window.updateBattleWaveData = function(wave) {
            const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
            const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
            const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
            const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
            const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
            const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
            const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
            const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
            const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
            const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
            const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
            
            if (!monsterSelect || !attackInput || !defenseInput || !hpInput || 
                !atkSpeedInput || !damageCoeffInput || !hpCoeffInput ||
                !spawnRateInput || !durationInput) return;
            
            // 更新配置
            battleWaveData[wave] = {
                monsterId: monsterSelect.value || '',
                attack: parseFloat(attackInput.value) || 10,
                defense: parseFloat(defenseInput.value) || 5,
                hp: parseFloat(hpInput.value) || 50,
                atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                spawnRate: parseFloat(spawnRateInput.value) || 1,
                duration: parseFloat(durationInput.value) || 10,
                coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
            };
            
            // 如果选择了怪物ID，自动填充攻防血
            if (battleWaveData[wave].monsterId && monsterTable.length > 0) {
                const monster = monsterTable.find(m => m.id === battleWaveData[wave].monsterId);
                if (monster) {
                    battleWaveData[wave].attack = monster.baseAttack || 10;
                    battleWaveData[wave].defense = monster.baseDefense || 5;
                    battleWaveData[wave].hp = monster.baseHp || 50;
                    
                    // 更新输入框
                    attackInput.value = battleWaveData[wave].attack;
                    defenseInput.value = battleWaveData[wave].defense;
                    hpInput.value = battleWaveData[wave].hp;
                    
                    // 更新怪物信息显示
                    if (monsterInfo) {
                        monsterInfo.textContent = ` (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                        monsterInfo.style.color = '#51cf66';
                    }
                } else {
                    if (monsterInfo) {
                        monsterInfo.textContent = ' (怪物不存在)';
                        monsterInfo.style.color = '#f44336';
                    }
                }
            } else {
                if (monsterInfo) {
                    monsterInfo.textContent = '';
                }
            }
            
            // 更新总怪物数显示
            updateBattleWaveTotalCount(wave);
        };

        // 更新单个波次的总怪物数显示
        function updateBattleWaveTotalCount(wave) {
            const totalCountEl = document.getElementById(`battle-wave-${wave}-total-count`);
            if (!totalCountEl) return;
            
            const waveData = battleWaveData[wave];
            if (!waveData) {
                totalCountEl.textContent = '-';
                return;
            }
            
            const totalCount = Math.floor(waveData.spawnRate * waveData.duration);
            totalCountEl.textContent = totalCount;
        }

        // 更新所有波次的总怪物数显示
        function updateBattleWaveTotalCounts() {
            for (let wave = 1; wave <= 25; wave++) {
                updateBattleWaveTotalCount(wave);
            }
        }
        
        // 复制第一波数据到其他波次
        window.copyWave1ToOthers = function() {
            // 从界面读取第一波的所有数据
            const wave1Data = {
                monsterId: document.getElementById('battle-wave-1-monster')?.value || '',
                attack: parseFloat(document.getElementById('battle-wave-1-attack')?.value) || 10,
                defense: parseFloat(document.getElementById('battle-wave-1-defense')?.value) || 5,
                hp: parseFloat(document.getElementById('battle-wave-1-hp')?.value) || 50,
                atkSpeed: parseFloat(document.getElementById('battle-wave-1-atkSpeed')?.value) || 0.33,
                damageCoeff: parseFloat(document.getElementById('battle-wave-1-damageCoeff')?.value) || 1,
                hpCoeff: parseFloat(document.getElementById('battle-wave-1-hpCoeff')?.value) || 1,
                spawnRate: parseFloat(document.getElementById('battle-wave-1-spawnRate')?.value) || 1,
                duration: parseFloat(document.getElementById('battle-wave-1-duration')?.value) || 10,
                coinReward: parseFloat(document.getElementById('battle-wave-1-coinReward')?.value) || 0
            };
            
            // 复制到第2-25波
            for (let wave = 2; wave <= 25; wave++) {
                // 更新内存中的数据
                battleWaveData[wave] = {
                    monsterId: wave1Data.monsterId,
                    attack: wave1Data.attack,
                    defense: wave1Data.defense,
                    hp: wave1Data.hp,
                    atkSpeed: wave1Data.atkSpeed,
                    damageCoeff: wave1Data.damageCoeff,
                    hpCoeff: wave1Data.hpCoeff,
                    spawnRate: wave1Data.spawnRate,
                    duration: wave1Data.duration,
                    coinReward: wave1Data.coinReward
                };
                
                // 更新界面显示
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect) monsterSelect.value = wave1Data.monsterId;
                if (attackInput) attackInput.value = wave1Data.attack;
                if (defenseInput) defenseInput.value = wave1Data.defense;
                if (hpInput) hpInput.value = wave1Data.hp;
                if (atkSpeedInput) atkSpeedInput.value = wave1Data.atkSpeed;
                if (damageCoeffInput) damageCoeffInput.value = wave1Data.damageCoeff;
                if (hpCoeffInput) hpCoeffInput.value = wave1Data.hpCoeff;
                if (spawnRateInput) spawnRateInput.value = wave1Data.spawnRate;
                if (durationInput) durationInput.value = wave1Data.duration;
                if (coinRewardInput) coinRewardInput.value = wave1Data.coinReward;
                
                // 更新怪物信息显示
                if (wave1Data.monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === wave1Data.monsterId);
                    const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
                    if (monsterInfo && monster) {
                        monsterInfo.textContent = ` (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                    } else if (monsterInfo) {
                        monsterInfo.textContent = '';
                    }
                } else {
                    const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
                    if (monsterInfo) monsterInfo.textContent = '';
                }
                
                // 更新总怪物数显示
                updateBattleWaveTotalCount(wave);
            }
            
            showMessage('已将第一波数据复制到第2-25波', 'success');
        };
        
        // ========== 据点奖励更新函数 ==========
        window.updateStrongholdReward = function(stronghold, reward) {
            strongholdRewards[stronghold] = parseInt(reward) || 0;
        };
        
        // ========== 25波怪物数据方案管理 ==========
        
        // 加载25波方案列表
        function loadBattleWaveSchemes() {
            try {
                const data = localStorage.getItem(BATTLE_WAVE_STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('加载25波方案失败:', error);
                return [];
            }
        }
        
        // 更新25波方案下拉选择框
        function updateBattleWaveSchemeSelect() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl) return;
            
            const schemes = loadBattleWaveSchemes();
            const currentValue = selectEl.value || currentBattleWaveSchemeId || '';
            
            // 清空并重新填充
            selectEl.innerHTML = '<option value="">选择方案...</option>';
            
            schemes.forEach(scheme => {
                const option = document.createElement('option');
                option.value = scheme.id;
                option.textContent = scheme.name;
                if (scheme.id === currentValue) {
                    option.selected = true;
                }
                selectEl.appendChild(option);
            });
            
            // 更新状态显示
            const statusEl = document.getElementById('battleWaveSchemeStatus');
            if (statusEl) {
                if (schemes.length > 0) {
                    statusEl.textContent = `已保存 ${schemes.length} 个方案（最多${MAX_BATTLE_WAVE_SCHEMES}个）`;
                    statusEl.style.color = '#51cf66';
                } else {
                    statusEl.textContent = '暂无保存的方案';
                    statusEl.style.color = '#666';
                }
            }
        }
        
        // 保存25波方案
        window.saveBattleWaveScheme = function() {
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (!nameInput) return;
            
            const name = nameInput.value.trim();
            if (!name) {
                showMessage('请输入方案名称', 'error');
                return;
            }
            
            // 从界面读取最新的25波怪物数据和据点奖励
            const latestBattleWaveData = {};
            for (let wave = 1; wave <= 25; wave++) {
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect && attackInput && defenseInput && hpInput && 
                    atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                    spawnRateInput && durationInput) {
                    latestBattleWaveData[wave] = {
                        monsterId: monsterSelect.value || '',
                        attack: parseFloat(attackInput.value) || 10,
                        defense: parseFloat(defenseInput.value) || 5,
                        hp: parseFloat(hpInput.value) || 50,
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                        spawnRate: parseFloat(spawnRateInput.value) || 1,
                        duration: parseFloat(durationInput.value) || 10,
                        coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                    };
                }
            }
            
            const schemes = loadBattleWaveSchemes();
            
            // 检查方案数量
            if (schemes.length >= MAX_BATTLE_WAVE_SCHEMES && !currentBattleWaveSchemeId) {
                showMessage(`最多只能保存${MAX_BATTLE_WAVE_SCHEMES}个方案，请先删除一个`, 'error');
                return;
            }
            
            // 读取据点奖励配置
            const latestStrongholdRewards = {};
            for (let i = 1; i <= 5; i++) {
                const rewardInput = document.getElementById(`stronghold${i}Reward`);
                latestStrongholdRewards[i] = rewardInput ? (parseInt(rewardInput.value) || 0) : 0;
            }
            
            // 读取怪物攻击延迟配置
            const delayInput = document.getElementById('monsterAttackDelayInput');
            const latestMonsterAttackDelay = delayInput ? (parseFloat(delayInput.value) || 3) : 3;
            
            const schemeData = {
                id: currentBattleWaveSchemeId || Date.now().toString(),
                name: name,
                saveTime: new Date().toISOString(),
                battleWaveData: latestBattleWaveData,
                strongholdRewards: latestStrongholdRewards,
                monsterAttackDelay: latestMonsterAttackDelay
            };
            
            // 如果已存在，更新；否则添加
            if (currentBattleWaveSchemeId) {
                const existingIndex = schemes.findIndex(s => s.id === currentBattleWaveSchemeId);
                if (existingIndex >= 0) {
                    schemes[existingIndex] = schemeData;
                } else {
                    schemes.push(schemeData);
                }
            } else {
                schemes.push(schemeData);
            }
            
            // 保存到localStorage
            localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            
            // 更新当前方案ID
            currentBattleWaveSchemeId = schemeData.id;
            
            // 更新下拉选择框
            updateBattleWaveSchemeSelect();
            
            // 更新输入框显示
            nameInput.value = name;
            
            showMessage(`25波方案"${name}"已保存`, 'success');
        };
        
        // 加载25波方案（通过下拉选择框）
        window.loadBattleWaveScheme = function(schemeId) {
            if (!schemeId) {
                currentBattleWaveSchemeId = null;
                updateBattleWaveSchemeSelect();
                return;
            }
            loadBattleWaveSchemeById(schemeId);
        };
        
        // 根据ID加载25波方案
        function loadBattleWaveSchemeById(schemeId) {
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            if (!scheme) {
                showMessage('方案不存在', 'error');
                return;
            }
            
            // 加载25波数据
            if (scheme.battleWaveData) {
                for (let wave = 1; wave <= 25; wave++) {
                    if (scheme.battleWaveData[wave]) {
                        battleWaveData[wave] = {
                            monsterId: scheme.battleWaveData[wave].monsterId || '',
                            attack: scheme.battleWaveData[wave].attack !== undefined ? scheme.battleWaveData[wave].attack : 10,
                            defense: scheme.battleWaveData[wave].defense !== undefined ? scheme.battleWaveData[wave].defense : 5,
                            hp: scheme.battleWaveData[wave].hp !== undefined ? scheme.battleWaveData[wave].hp : 50,
                            atkSpeed: scheme.battleWaveData[wave].atkSpeed !== undefined ? scheme.battleWaveData[wave].atkSpeed : 0.33,
                            damageCoeff: scheme.battleWaveData[wave].damageCoeff !== undefined ? scheme.battleWaveData[wave].damageCoeff : 1,
                            hpCoeff: scheme.battleWaveData[wave].hpCoeff !== undefined ? scheme.battleWaveData[wave].hpCoeff : 1,
                            spawnRate: scheme.battleWaveData[wave].spawnRate !== undefined ? scheme.battleWaveData[wave].spawnRate : 1,
                            duration: scheme.battleWaveData[wave].duration !== undefined ? scheme.battleWaveData[wave].duration : 10,
                            coinReward: scheme.battleWaveData[wave].coinReward !== undefined ? scheme.battleWaveData[wave].coinReward : 0
                        };
                    }
                }
            }
            
            // 加载据点奖励配置
            if (scheme.strongholdRewards) {
                for (let i = 1; i <= 5; i++) {
                    strongholdRewards[i] = scheme.strongholdRewards[i] || 0;
                    const rewardInput = document.getElementById(`stronghold${i}Reward`);
                    if (rewardInput) {
                        rewardInput.value = strongholdRewards[i];
                    }
                }
            }
            
            // 加载怪物攻击延迟配置
            if (scheme.monsterAttackDelay !== undefined) {
                monsterAttackDelay = parseFloat(scheme.monsterAttackDelay) || 3;
                const delayInput = document.getElementById('monsterAttackDelayInput');
                if (delayInput) {
                    delayInput.value = monsterAttackDelay;
                }
            }
            
            // 重新初始化界面以应用加载的配置
            initBattleWaveData();
            
            // 更新当前方案ID和下拉选择框
            currentBattleWaveSchemeId = schemeId;
            updateBattleWaveSchemeSelect();
            
            // 更新输入框显示
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (nameInput) {
                nameInput.value = scheme.name;
            }
            
            showMessage(`已加载25波方案"${scheme.name}"`, 'success');
        }
        
        // 复制25波方案
        window.copyBattleWaveScheme = function() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl || !selectEl.value) {
                showMessage('请先选择一个方案', 'error');
                return;
            }
            
            const schemeId = selectEl.value;
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('方案不存在', 'error');
                return;
            }
            
            // 检查方案数量
            if (schemes.length >= MAX_BATTLE_WAVE_SCHEMES) {
                showMessage(`最多只能保存${MAX_BATTLE_WAVE_SCHEMES}个方案，请先删除一个`, 'error');
                return;
            }
            
            // 创建新方案（复制数据）
            const newScheme = {
                id: Date.now().toString(),
                name: `${scheme.name} - 副本`,
                saveTime: new Date().toISOString(),
                battleWaveData: JSON.parse(JSON.stringify(scheme.battleWaveData || {})), // 深拷贝25波怪物数据
                strongholdRewards: JSON.parse(JSON.stringify(scheme.strongholdRewards || {})), // 深拷贝据点奖励
                monsterAttackDelay: scheme.monsterAttackDelay !== undefined ? scheme.monsterAttackDelay : 3 // 复制怪物攻击延迟
            };
            
            // 如果名称已存在，添加数字后缀
            let copyName = newScheme.name;
            let copyIndex = 1;
            while (schemes.some(s => s.name === copyName)) {
                copyName = `${scheme.name} - 副本${copyIndex}`;
                copyIndex++;
            }
            newScheme.name = copyName;
            
            // 添加到列表
            schemes.push(newScheme);
            localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            
            // 加载新复制的方案
            currentBattleWaveSchemeId = newScheme.id;
            loadBattleWaveSchemeById(newScheme.id);
            
            // 更新方案名称输入框
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (nameInput) nameInput.value = copyName;
            
            showMessage(`已复制方案"${scheme.name}"为"${copyName}"`, 'success');
        };
        
        // 删除25波方案
        window.deleteBattleWaveScheme = function() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl || !selectEl.value) {
                showMessage('请先选择一个方案', 'error');
                return;
            }
            
            const schemeId = selectEl.value;
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('方案不存在', 'error');
                return;
            }
            
            if (!confirm(`确定要删除方案"${scheme.name}"吗？`)) {
                return;
            }
            
            // 删除方案
            const index = schemes.findIndex(s => s.id === schemeId);
            if (index >= 0) {
                schemes.splice(index, 1);
                localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            }
            
            // 如果删除的是当前方案，清空当前方案ID
            if (currentBattleWaveSchemeId === schemeId) {
                currentBattleWaveSchemeId = null;
                const nameInput = document.getElementById('battleWaveSchemeNameInput');
                if (nameInput) nameInput.value = '';
            }
            
            // 更新下拉选择框
            updateBattleWaveSchemeSelect();
            
            // 清空选择
            selectEl.value = '';
            
            showMessage(`方案"${scheme.name}"已删除`, 'success');
        };

        // 更新关卡配置（全局函数）
        window.updateStageConfig = function(stage) {
            const monsterSelect = document.getElementById(`stage-${stage}-monster`);
            const atkSpeedInput = document.getElementById(`stage-${stage}-atkSpeed`);
            const damageCoeffInput = document.getElementById(`stage-${stage}-damageCoeff`);
            const hpCoeffInput = document.getElementById(`stage-${stage}-hpCoeff`);
            const monsterInfo = document.getElementById(`stage-${stage}-monster-info`);
            
            if (!monsterSelect || !atkSpeedInput || !damageCoeffInput || !hpCoeffInput) return;
            
            // 更新配置
            stageConfig[stage] = {
                monsterId: monsterSelect.value || '',
                atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                hpCoeff: parseFloat(hpCoeffInput.value) || 0
            };
            
            // 更新怪物信息显示
            if (monsterInfo) {
                if (stageConfig[stage].monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === stageConfig[stage].monsterId);
                    if (monster) {
                        monsterInfo.textContent = ` (攻${monster.baseAttack} 防${monster.baseDefense} 血${monster.baseHp})`;
                        monsterInfo.style.color = '#51cf66';
                    } else {
                        monsterInfo.textContent = ' (怪物不存在)';
                        monsterInfo.style.color = '#f44336';
                    }
                } else {
                    monsterInfo.textContent = '';
                }
            }
            
            // 更新伤害信息显示
            updateStageDamageInfo(stage);
        };

        // 更新关卡伤害信息显示
        function updateStageDamageInfo(stage) {
            const stageData = stageConfig[stage];
            if (!stageData || !stageData.monsterId) {
                // 如果没有选择怪物，清空显示
                const monsterToChar1 = document.getElementById(`stage-${stage}-monster-to-char1`);
                const char1ToMonster = document.getElementById(`stage-${stage}-char1-to-monster`);
                const char34Avg = document.getElementById(`stage-${stage}-char34-avg`);
                if (monsterToChar1) monsterToChar1.textContent = '-';
                if (char1ToMonster) char1ToMonster.textContent = '-';
                if (char34Avg) char34Avg.textContent = '-';
                return;
            }
            
            // 从怪物表获取怪物属性
            const monster = monsterTable.find(m => m.id === stageData.monsterId);
            if (!monster) {
                const monsterToChar1 = document.getElementById(`stage-${stage}-monster-to-char1`);
                const char1ToMonster = document.getElementById(`stage-${stage}-char1-to-monster`);
                const char34Avg = document.getElementById(`stage-${stage}-char34-avg`);
                if (monsterToChar1) monsterToChar1.textContent = '-';
                if (char1ToMonster) char1ToMonster.textContent = '-';
                if (char34Avg) char34Avg.textContent = '-';
                return;
            }
            
            // 获取角色1的最终属性（需要先应用装备、平台、车辆加成）
            const char1 = characters.find(c => c.id === 1);
            if (!char1) return;
            
            // 临时应用属性计算（确保有最新的最终属性）
            applyJobEquipmentStats(char1);
            const char1FinalAttack = char1.attack || 0;
            const char1FinalDefense = char1.defense || 0;
            
            // 获取角色3和角色4的最终属性
            const char3 = characters.find(c => c.id === 3);
            const char4 = characters.find(c => c.id === 4);
            let char3FinalAttack = 0;
            let char4FinalAttack = 0;
            if (char3) {
                applyJobEquipmentStats(char3);
                char3FinalAttack = char3.attack || 0;
            }
            if (char4) {
                applyJobEquipmentStats(char4);
                char4FinalAttack = char4.attack || 0;
            }
            
            // 计算怪物最终攻击力（应用攻击系数）
            const monsterFinalAttack = (monster.baseAttack || 0) * (stageData.damageCoeff || 1);
            const monsterDefense = monster.baseDefense || 0;
            
            // 1. 怪物对角色1基础伤害 = 怪物最终攻击力 - 角色1最终防御力
            const monsterToChar1Damage = Math.max(1, Math.floor(monsterFinalAttack - char1FinalDefense));
            
            // 2. 角色1对怪物基础伤害 = 角色1最终攻击力 - 怪物防御力
            const char1ToMonsterDamage = Math.max(1, Math.floor(char1FinalAttack - monsterDefense));
            
            // 3. 角色3/角色4平均基础伤害 = (角色3攻击力 + 角色4攻击力) / 2 - 怪物防御力
            const char34AvgAttack = (char3FinalAttack + char4FinalAttack) / 2;
            const char34AvgDamage = Math.max(1, Math.floor(char34AvgAttack - monsterDefense));
            
            // 更新显示
            const monsterToChar1El = document.getElementById(`stage-${stage}-monster-to-char1`);
            const char1ToMonsterEl = document.getElementById(`stage-${stage}-char1-to-monster`);
            const char34AvgEl = document.getElementById(`stage-${stage}-char34-avg`);
            
            if (monsterToChar1El) {
                monsterToChar1El.textContent = `${monsterFinalAttack.toFixed(0)} - ${char1FinalDefense.toFixed(0)} = ${monsterToChar1Damage}`;
            }
            if (char1ToMonsterEl) {
                char1ToMonsterEl.textContent = `${char1FinalAttack.toFixed(0)} - ${monsterDefense.toFixed(0)} = ${char1ToMonsterDamage}`;
            }
            if (char34AvgEl) {
                char34AvgEl.textContent = `${char34AvgAttack.toFixed(0)} - ${monsterDefense.toFixed(0)} = ${char34AvgDamage}`;
            }
        }

        // 挑战关卡（全局函数）
        window.challengeStage = function(stage) {
            const stageData = stageConfig[stage];
            if (!stageData || !stageData.monsterId) {
                if (!window.isChallengingAll) {
                    showMessage('请先选择怪物ID', 'error');
                }
                return false; // 返回false表示跳过
            }
            
            // 从怪物表获取怪物属性
            const monster = monsterTable.find(m => m.id === stageData.monsterId);
            if (!monster) {
                if (!window.isChallengingAll) {
                    showMessage('怪物不存在', 'error');
                }
                return false; // 返回false表示跳过
            }
            
            // 将怪物属性应用到怪物配置模块
            document.getElementById('monsterAttack').value = monster.baseAttack || 10;
            document.getElementById('monsterDefense').value = monster.baseDefense || 5;
            document.getElementById('monsterHp').value = monster.baseHp || 50;
            document.getElementById('monsterAtkSpeed').value = stageData.atkSpeed || 0.33;
            document.getElementById('monsterDamageCoeff').value = stageData.damageCoeff || 1;
            document.getElementById('monsterHpCoeff').value = stageData.hpCoeff || 0;
            
            // 更新怪物配置
            updateMonsterConfig();
            
            // 清空之前的结果显示
            const resultDiv = document.getElementById(`stage-${stage}-result`);
            const stageCard = document.getElementById(`stage-card-${stage}`);
            if (resultDiv) {
                resultDiv.textContent = '挑战中...';
                resultDiv.style.color = '#666';
            }
            if (stageCard) {
                stageCard.style.background = 'white';
                stageCard.style.borderColor = '#e0e0e0';
            }
            
            // 保存当前关卡号，用于战斗结束后判断
            window.currentChallengeStage = stage;
            
            // 执行快速战斗
            quickBattle();
            
            return true; // 返回true表示成功执行
        };

        // 一键挑战所有关卡（全局函数）
        window.challengeAllStages = function() {
            // 检查是否有已配置的关卡
            let hasConfiguredStage = false;
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage];
                if (stageData && stageData.monsterId) {
                    hasConfiguredStage = true;
                    break;
                }
            }
            
            if (!hasConfiguredStage) {
                showMessage('请至少配置一个关卡的怪物ID', 'error');
                return;
            }
            
            // 设置一键挑战标志
            window.isChallengingAll = true;
            
            // 更新进度显示
            const progressEl = document.getElementById('allStagesProgress');
            if (progressEl) {
                progressEl.textContent = '准备开始挑战所有关卡...';
                progressEl.style.color = '#666';
            }
            
            // 依次挑战所有关卡（同步执行，因为quickBattle是同步的）
            let completedCount = 0;
            let skippedCount = 0;
            
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage];
                
                // 更新进度
                if (progressEl) {
                    progressEl.textContent = `正在挑战第 ${stage} 关... (${completedCount} 完成, ${skippedCount} 跳过)`;
                }
                
                // 如果该关卡没有配置怪物ID，跳过
                if (!stageData || !stageData.monsterId) {
                    skippedCount++;
                    continue;
                }
                
                // 挑战该关卡
                const success = challengeStage(stage);
                if (success) {
                    completedCount++;
                } else {
                    skippedCount++;
                }
            }
            
            // 清空一键挑战标志
            window.isChallengingAll = false;
            
            // 更新最终进度
            if (progressEl) {
                progressEl.textContent = `全部完成！共挑战 ${completedCount} 关，跳过 ${skippedCount} 关`;
                progressEl.style.color = '#51cf66';
            }
            
            showMessage(`一键挑战完成！共挑战 ${completedCount} 关，跳过 ${skippedCount} 关`, 'success');
        };

        // 检查关卡挑战结果（在战斗结束后调用）
        function checkStageResult() {
            if (window.currentChallengeStage === undefined) return;
            
            const stage = window.currentChallengeStage;
            const resultDiv = document.getElementById(`stage-${stage}-result`);
            const stageCard = document.getElementById(`stage-card-${stage}`);
            
            if (!resultDiv || !stageCard) return;
            
            // 查找角色1（ID为1）
            const char1 = battleState.characters.find(c => c.id === 1);
            let char1DeathTime = null;
            let deathTimeDisplay = '';
            let multiplierDisplay = '';
            
            // 检查角色1是否"几乎不会死"（超过200秒仍存活）
            if (battleState.char1NeverDies) {
                // 如果角色1"几乎不会死"，使用200秒作为死亡时间（或实际战斗时长，取较大值）
                char1DeathTime = Math.max(200, battleState.elapsedTime);
                deathTimeDisplay = `死亡时间: 几乎不会死（${formatTime(char1DeathTime)}）`;
                const multiplier = (char1DeathTime / 50).toFixed(2);
                multiplierDisplay = `倍率: ${multiplier}x`;
                resultDiv.innerHTML = `✓ 可通关（角色1不会死）<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}，${multiplierDisplay}</span>`;
                resultDiv.style.color = '#51cf66';
                stageCard.style.background = '#e8f5e9';
                stageCard.style.borderColor = '#51cf66';
                // 清空当前挑战关卡标记
                window.currentChallengeStage = undefined;
                return;
            }
            
            // 如果角色1死亡，获取其死亡时间
            if (char1 && !char1.isAlive) {
                // 使用记录的死亡时间，如果没有则使用firstCharacterDeathTime（如果角色1是第一个死亡的）
                char1DeathTime = char1.deathTime || (char1.id === 1 && battleState.firstCharacterDeathTime);
            } else if (char1 && char1.isAlive) {
                // 如果角色1存活，使用战斗总时长
                char1DeathTime = battleState.elapsedTime;
            }
            
            // 判断是否通关：角色1死亡时间大于50秒，或者角色1未死亡（存活超过50秒）
            // 如果角色1死亡，检查死亡时间是否大于50秒
            const isPassed = char1DeathTime === null || char1DeathTime > 50;
            
            // 格式化死亡时间显示
            if (char1DeathTime !== null) {
                deathTimeDisplay = `死亡时间: ${formatTime(char1DeathTime)}`;
                const multiplier = (char1DeathTime / 50).toFixed(2);
                multiplierDisplay = `倍率: ${multiplier}x`;
            } else {
                deathTimeDisplay = '死亡时间: 未知';
                multiplierDisplay = '倍率: -';
            }
            
            if (isPassed) {
                resultDiv.innerHTML = `✓ 可通关<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}，${multiplierDisplay}</span>`;
                resultDiv.style.color = '#51cf66';
                stageCard.style.background = '#e8f5e9';
                stageCard.style.borderColor = '#51cf66';
            } else {
                resultDiv.innerHTML = `✗ 属性不足，挑战失败<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}，${multiplierDisplay}</span>`;
                resultDiv.style.color = '#f44336';
                stageCard.style.background = '#ffebee';
                stageCard.style.borderColor = '#f44336';
            }
            
            // 清空当前挑战关卡标记
            window.currentChallengeStage = undefined;
        }

        function initCharacters() {
            const grid = document.getElementById('charactersGrid');
            if (!grid) {
                console.error('找不到charactersGrid元素');
                return;
            }
            if (!characters || characters.length === 0) {
                console.error('characters数组为空');
                return;
            }
            grid.innerHTML = characters.map(char => `
                <div class="character-card" data-char-id="${char.id}">
                    <div class="character-header">
                        <div class="character-name">${char.name}</div>
                        <span class="character-job" style="font-size: 0.85em; color: #667eea; font-weight: 600; margin-left: 8px;">[${JOB_NAMES[char.job]}]</span>
                        <span class="character-status status-alive" id="status-${char.id}">存活</span>
                    </div>
                    <div class="input-group">
                        <label>选择英雄</label>
                        <select class="char-hero-select" data-char="${char.id}" onchange="updateCharacterHero(${char.id}, this.value)" style="width: 100%; padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">请选择英雄</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>选择等级</label>
                        <select class="char-hero-level-select" data-char="${char.id}" onchange="updateCharacterHeroLevel(${char.id}, this.value)" style="width: 100%; padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">请先选择英雄</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>基础攻击力</label>
                        <input type="number" class="char-attack" data-char="${char.id}" min="1" value="${char.baseAttack || char.attack}" onchange="updateCharacter(${char.id}, 'attack', this.value)" />
                    </div>
                    <div class="input-group">
                        <label>基础防御力</label>
                        <input type="number" class="char-defense" data-char="${char.id}" min="0" value="${char.baseDefense || char.defense}" onchange="updateCharacter(${char.id}, 'defense', this.value)" />
                    </div>
                    <div class="input-group">
                        <label>基础血量</label>
                        <input type="number" class="char-hp" data-char="${char.id}" min="1" value="${char.baseHp || char.hp}" onchange="updateCharacter(${char.id}, 'hp', this.value)" />
                    </div>
                    ${char.id === 1 ? `
                    <div class="input-group">
                        <label>减伤百分比（%）</label>
                        <input type="number" class="char-damageReduction" data-char="${char.id}" min="0" max="100" step="0.1" value="${char.damageReduction || 0}" onchange="updateCharacter(${char.id}, 'damageReduction', this.value)" />
                    </div>
                    ` : ''}
                    ${(char.id === 2 || char.id === 3 || char.id === 4) ? `
                    <div class="input-group">
                        <label>技能伤害系数（%）</label>
                        <input type="number" class="char-skillDamage" data-char="${char.id}" min="0" step="0.1" value="${char.skillDamage || 0}" onchange="updateCharacter(${char.id}, 'skillDamage', this.value)" />
                    </div>
                    ` : ''}
                    ${char.id === 5 ? `
                    <div class="input-group">
                        <label>回血系数</label>
                        <input type="number" class="char-heal" data-char="${char.id}" min="0" step="0.01" value="${char.healRate || 0}" onchange="updateCharacter(${char.id}, 'healRate', this.value)" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">最终回血速度 = 最终攻击力 × 回血系数</div>
                    </div>
                    ` : ''}
                    <div class="hp-bar" style="display: none;">
                        <div class="hp-fill" id="hp-bar-${char.id}" style="width: 100%;"></div>
                    </div>
                </div>
            `).join('');
            
            // 更新所有角色的英雄选择下拉框
            updateAllCharacterHeroSelects();
        }

        // 更新所有角色的英雄选择下拉框
        function updateAllCharacterHeroSelects() {
            characters.forEach(char => {
                updateCharacterHeroSelect(char.id);
            });
        }

        // 更新单个角色的英雄选择下拉框
        function updateCharacterHeroSelect(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char) return;
            
            const heroSelect = document.querySelector(`.char-hero-select[data-char="${charId}"]`);
            if (!heroSelect) return;
            
            heroSelect.innerHTML = '<option value="">请选择英雄</option>';
            
            if (heroTable.length === 0) {
                heroSelect.innerHTML = '<option value="">请先上传英雄表</option>';
                return;
            }
            
            // 筛选与角色职业相同的英雄
            const jobHeroes = heroTable.filter(hero => {
                const heroJob = parseInt(hero.heroclass) || 0;
                return heroJob === char.job;
            });
            
            if (jobHeroes.length === 0) {
                heroSelect.innerHTML = '<option value="">暂无该职业的英雄</option>';
                return;
            }
            
            // 按ID排序
            const sortedHeroes = [...jobHeroes].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedHeroes.forEach(hero => {
                const option = document.createElement('option');
                option.value = hero.id;
                option.textContent = `${hero.id} - ${hero.namecn}${hero.quality ? ' [' + hero.quality + ']' : ''}`;
                
                // 如果角色已选择该英雄，设置为选中
                if (char.selectedHeroId === hero.id) {
                    option.selected = true;
                }
                
                heroSelect.appendChild(option);
            });
            
            // 如果角色已选择英雄，更新等级选择下拉框
            if (char.selectedHeroId) {
                updateCharacterHeroLevelSelect(charId);
            }
        }

        // 更新角色的等级选择下拉框
        function updateCharacterHeroLevelSelect(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.selectedHeroId) return;
            
            const levelSelect = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
            if (!levelSelect) return;
            
            const hero = heroTable.find(h => h.id === char.selectedHeroId);
            if (!hero) {
                levelSelect.innerHTML = '<option value="">英雄不存在</option>';
                return;
            }
            
            levelSelect.innerHTML = '<option value="">请选择等级</option>';
            
            // 获取该英雄的所有等级
            const levels = hero.levels ? Object.keys(hero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
            
            if (levels.length === 0) {
                levelSelect.innerHTML = '<option value="">该英雄暂无等级数据</option>';
                return;
            }
            
            levels.forEach(level => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `等级 ${level}`;
                
                // 如果角色已选择该等级，设置为选中
                if (char.selectedHeroLevel === level) {
                    option.selected = true;
                }
                
                levelSelect.appendChild(option);
            });
        }

        // 更新角色选择的英雄（全局函数）
        window.updateCharacterHero = function(charId, heroId) {
            const char = characters.find(c => c.id === charId);
            if (!char) return;
            
            char.selectedHeroId = heroId || null;
            
            // 更新等级选择下拉框
            updateCharacterHeroLevelSelect(charId);
            
            // 如果清空了英雄选择，也清空等级选择
            if (!heroId) {
                char.selectedHeroLevel = null;
                const levelSelect = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
                if (levelSelect) {
                    levelSelect.innerHTML = '<option value="">请先选择英雄</option>';
                }
            }
        }

        // 更新角色选择的英雄等级并自动更新属性（全局函数）
        window.updateCharacterHeroLevel = function(charId, level) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.selectedHeroId) return;
            
            const levelNum = parseInt(level);
            if (!levelNum) {
                char.selectedHeroLevel = null;
                return;
            }
            
            char.selectedHeroLevel = levelNum;
            
            // 获取英雄数据
            const hero = heroTable.find(h => h.id === char.selectedHeroId);
            if (!hero) return;
            
            // 只读取当前等级的属性（不累加之前等级）
            const levelAttrs = hero.levels && hero.levels[levelNum] ? hero.levels[levelNum] : {};
            
            // 自动更新角色的基础属性（只使用当前等级的属性值）
            // 如果当前等级有属性数据，使用该等级的属性；否则保持原值
            if (levelAttrs.baseAttack !== undefined && levelAttrs.baseAttack !== null) {
                char.baseAttack = levelAttrs.baseAttack;
            }
            if (levelAttrs.baseDefense !== undefined && levelAttrs.baseDefense !== null) {
                char.baseDefense = levelAttrs.baseDefense;
            }
            if (levelAttrs.baseHp !== undefined && levelAttrs.baseHp !== null) {
                char.baseHp = levelAttrs.baseHp;
                char.maxHp = levelAttrs.baseHp;
            } else if (char.baseHp) {
                char.maxHp = char.baseHp;
            }
            
            // 应用装备属性
            applyJobEquipmentStats(char);
            
            // 更新界面显示
            const card = document.querySelector(`[data-char-id="${charId}"]`);
            if (card) {
                const attackInput = card.querySelector('.char-attack');
                const defenseInput = card.querySelector('.char-defense');
                const hpInput = card.querySelector('.char-hp');
                if (attackInput) attackInput.value = char.baseAttack;
                if (defenseInput) defenseInput.value = char.baseDefense;
                if (hpInput) hpInput.value = char.baseHp;
            }
            
            // 更新最终属性面板
            updateFinalAttributesPanel();
            
            // 更新所有关卡的伤害信息（因为角色属性已改变）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // 更新角色属性
        function updateCharacter(id, property, value) {
            const char = characters.find(c => c.id === id);
            if (char) {
                if (property === 'healRate' || property === 'damageReduction' || property === 'skillDamage') {
                    char[property] = parseFloat(value) || 0;
                    // 如果更新的是角色5的回血系数，需要重新计算最终回血速度
                    if (property === 'healRate' && char.id === 5) {
                        applyJobEquipmentStats(char);
                    }
                } else {
                    const numValue = parseInt(value) || 1;
                    if (property === 'attack') {
                        char.baseAttack = numValue;
                        applyEquipmentStats(char);
                        // 如果更新的是角色5的攻击力，最终回血速度会在applyJobEquipmentStats中自动更新
                    } else if (property === 'defense') {
                        char.baseDefense = numValue;
                        applyEquipmentStats(char);
                    } else if (property === 'hp') {
                        char.baseHp = numValue;
                        char.maxHp = numValue;
                        applyEquipmentStats(char);
                    } else {
                        char[property] = numValue;
                    }
                }
                // 更新最终属性面板
                updateFinalAttributesPanel();
                
                // 更新所有关卡的伤害信息（因为角色属性已改变）
                for (let stage = 1; stage <= 20; stage++) {
                    updateStageDamageInfo(stage);
                }
            }
        }

        // 更新角色装备（全局函数）
        window.updateCharacterEquipment = function(charId, equipmentId) {
            const char = characters.find(c => c.id === charId);
            if (char) {
                char.equipmentId = equipmentId || null;
                applyEquipmentStats(char);
                // 更新界面显示
                updateCharacterDisplay(char);
            }
        }

        // 应用装备属性加成（兼容旧版本，现在使用applyJobEquipmentStats）
        function applyEquipmentStats(char) {
            applyJobEquipmentStats(char);
        }

        // 更新角色显示（显示基础属性，不是最终属性）
        function updateCharacterDisplay(char) {
            const card = document.querySelector(`[data-char-id="${char.id}"]`);
            if (card) {
                const attackInput = card.querySelector('.char-attack');
                const defenseInput = card.querySelector('.char-defense');
                const hpInput = card.querySelector('.char-hp');
                // 显示基础属性，不是最终属性
                if (attackInput) attackInput.value = char.baseAttack || char.attack;
                if (defenseInput) defenseInput.value = char.baseDefense || char.defense;
                if (hpInput) hpInput.value = char.baseHp || char.hp;
            }
            // 更新最终属性面板
            updateFinalAttributesPanel();
        }

        // 更新怪物配置
        function updateMonsterConfig() {
            monsterConfig.spawnRate = parseFloat(document.getElementById('spawnRate').value) || 1;
            monsterConfig.attack = parseInt(document.getElementById('monsterAttack').value) || 10;
            monsterConfig.defense = parseInt(document.getElementById('monsterDefense').value) || 5;
            monsterConfig.hp = parseInt(document.getElementById('monsterHp').value) || 50;
            monsterConfig.atkSpeed = parseFloat(document.getElementById('monsterAtkSpeed').value) || 1;
            monsterConfig.damageCoeff = parseFloat(document.getElementById('monsterDamageCoeff').value) || 1;
            monsterConfig.hpCoeff = parseFloat(document.getElementById('monsterHpCoeff').value) || 0;
            
            // 更新所有关卡的伤害信息（因为怪物配置已改变）
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // 重置配置
        function resetConfig() {
            characters.forEach((char, i) => {
                // 重置基础属性
                char.baseAttack = 20;
                char.baseDefense = 10;
                char.baseHp = 100;
                char.healRate = i === 4 ? 0.05 : 0; // 角色5默认回血系数0.05（如果最终攻击力100，则回血速度5/秒）
                char.damageReduction = i === 0 ? 0 : 0; // 角色1减伤百分比
                char.skillDamage = (i === 1 || i === 2 || i === 3) ? 0 : 0; // 角色2、3、4技能伤害系数
                char.isAlive = true;
                
                // 应用装备属性后，最终属性会被计算
                applyJobEquipmentStats(char);
            });
            
            document.getElementById('spawnRate').value = 1;
            document.getElementById('monsterAttack').value = 10;
            document.getElementById('monsterDefense').value = 5;
            document.getElementById('monsterHp').value = 50;
            document.getElementById('monsterAtkSpeed').value = 1;
            document.getElementById('monsterDamageCoeff').value = 1;
            document.getElementById('monsterHpCoeff').value = 0;

            initCharacters();
            hideMessage();
        }

        // 停止战斗
        function stopBattle() {
            if (!battleState.isRunning) {
                return;
            }

            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '开始战斗';
            document.getElementById('stopBtn').style.display = 'none';

            let deathInfo = '';
            if (battleState.firstCharacterDeathTime !== null) {
                deathInfo = `，首个角色死亡时间: ${formatTime(battleState.firstCharacterDeathTime)}`;
                saveFirstDeathTimeToScheme(battleState.firstCharacterDeathTime);
            }

            addLog(`<span style="color: #ffc107; font-weight: bold;">战斗已手动停止！</span>`);
            addLog(`正常模式统计：击败怪物 ${battleState.totalMonstersKilled}，伤害输出 ${battleState.totalDamageDealt}，战斗时长 ${formatTime(battleState.elapsedTime)}${deathInfo}`);
            addLog(`无浪费模式统计：击败怪物 ${noWasteBattleState.totalMonstersKilled}，伤害输出 ${noWasteBattleState.totalDamageDealt}，战斗时长 ${formatTime(noWasteBattleState.elapsedTime)}`);
            
            // 更新战斗统计显示
            updateBattleStatsAfterEnd();
        }

        // 开始战斗
        function startBattle() {
            if (battleState.isRunning) {
                return;
            }

            // 更新怪物配置
            updateMonsterConfig();
            
            // 从界面读取最新的平台属性配置并更新
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount').value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum').value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // 从界面读取最新的车辆属性配置并更新
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // 从界面读取最新的角色基础属性（如果用户手动修改了）
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // 重新应用所有角色的属性（确保包含最新的装备、平台、车辆加成）
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // 重置战斗状态（正常模式）
            battleState = {
                isRunning: true,
                startTime: Date.now(),
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: 0,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0 // 确保战斗状态中包含最终回血速度
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null, // 第一个角色死亡时间
                char1NeverDies: false // 标记角色1是否"几乎不会死"（超过200秒仍存活）
            };
            
            // 重置无浪费模式战斗状态
            noWasteBattleState = {
                isRunning: true,
                startTime: Date.now(),
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: 0,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null,
                overflowDamage: 0 // 溢出伤害
            };

            // 显示战斗区域
            document.getElementById('battleArea').classList.add('show');
            document.getElementById('battleLog').innerHTML = '';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = '战斗中...';
            document.getElementById('stopBtn').style.display = 'block';

            // 显示角色HP条
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                const hpBar = card.querySelector('.hp-bar');
                if (hpBar) hpBar.style.display = 'block';
            });

            // 记录开始
            addLog(`战斗开始！怪物刷新速度: ${monsterConfig.spawnRate}个/秒`);

            // 开始战斗循环
            battleLoop();
        }

        // 快速战斗（直接显示结果，不显示动画）
        window.quickBattle = function() {
            if (battleState.isRunning) {
                return;
            }

            // 更新怪物配置
            updateMonsterConfig();
            
            // 从界面读取最新的平台属性配置并更新
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount').value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum').value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // 从界面读取最新的车辆属性配置并更新
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // 从界面读取最新的角色基础属性
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // 重新应用所有角色的属性
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // 重置战斗状态（正常模式）
            battleState = {
                isRunning: true,
                startTime: 0,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: -1000, // 初始化为负数，确保第一次可以攻击
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0,
                    deathTime: null // 记录每个角色的死亡时间
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                char1NeverDies: false, // 标记角色1是否"几乎不会死"（超过200秒仍存活）
                firstCharacterDeathTime: null // 第一个角色死亡时间
            };
            
            // 重置无浪费模式战斗状态
            noWasteBattleState = {
                isRunning: true,
                startTime: 0,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: -1000,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null,
                overflowDamage: 0
            };

            // 显示战斗区域
            document.getElementById('battleArea').classList.add('show');
            document.getElementById('battleLog').innerHTML = '';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('quickResultBtn').disabled = true;
            document.getElementById('startBtn').textContent = '计算中...';

            // 显示角色HP条
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                const hpBar = card.querySelector('.hp-bar');
                if (hpBar) hpBar.style.display = 'block';
            });

            // 记录开始
            addLog(`快速战斗开始！怪物刷新速度: ${monsterConfig.spawnRate}个/秒`);

            // 设置快速战斗模式标志（用于减少日志输出）
            const isQuickBattle = true;
            
            // 快速战斗循环（使用时间步进，不等待动画）
            const timeStep = 0.01; // 每次步进0.01秒
            const maxTime = 600; // 最大战斗时间600秒（10分钟）
            let lastSummaryTime = 0; // 上次输出摘要的时间
            
            while (battleState.isRunning && battleState.elapsedTime < maxTime) {
                // 更新经过时间
                battleState.elapsedTime += timeStep;
                noWasteBattleState.elapsedTime = battleState.elapsedTime;
                
                const currentTime = battleState.elapsedTime * 1000; // 转换为毫秒

                // 刷新怪物（两种模式同时刷新，快速模式下不输出日志）
                if (currentTime >= battleState.nextSpawnTime) {
                    // 快速模式下不输出怪物出现日志
                    const oldLogLength = document.getElementById('battleLog').children.length;
                    spawnMonster();
                    spawnMonsterNoWaste();
                    // 移除刚才添加的日志（如果有）
                    const log = document.getElementById('battleLog');
                    while (log.children.length > oldLogLength) {
                        log.removeChild(log.lastChild);
                    }
                    const spawnInterval = 1000 / monsterConfig.spawnRate;
                    battleState.nextSpawnTime = currentTime + spawnInterval;
                    noWasteBattleState.nextSpawnTime = battleState.nextSpawnTime;
                }

                // 角色攻击（正常模式，快速模式下不输出详细日志）
                battleState.characters.forEach(char => {
                    if (char.isAlive && battleState.monsters.length > 0) {
                        const timeSinceLastAttack = battleState.elapsedTime - (char.lastAttackTime / 1000);
                        const attackInterval = 1 / char.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval) {
                            // 快速模式下，不输出每次攻击的详细日志
                            const oldLogLength = document.getElementById('battleLog').children.length;
                            characterAttack(char);
                            // 移除详细攻击日志，只保留怪物死亡等重要事件
                            const log = document.getElementById('battleLog');
                            while (log.children.length > oldLogLength) {
                                const lastEntry = log.lastChild;
                                if (lastEntry && !lastEntry.innerHTML.includes('被击败') && !lastEntry.innerHTML.includes('阵亡')) {
                                    log.removeChild(lastEntry);
                                } else {
                                    break;
                                }
                            }
                            char.lastAttackTime = currentTime;
                        }
                    }
                });
                
                // 角色攻击（无浪费模式，不输出日志）
                noWasteBattleState.characters.forEach(char => {
                    if (char.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (char.lastAttackTime / 1000);
                        const attackInterval = 1 / char.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval) {
                            characterAttackNoWaste(char);
                            char.lastAttackTime = currentTime;
                        }
                    }
                });

                // 角色回血（正常模式，快速模式下不输出日志）
                battleState.characters.forEach(char => {
                    if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                        const timeSinceLastHeal = battleState.elapsedTime - ((char.lastHealTime || 0) / 1000);
                        if (timeSinceLastHeal >= 1.0) {
                            const aliveChars = battleState.characters.filter(c => c.isAlive);
                            if (aliveChars.length > 0) {
                                const targetChar = aliveChars.reduce((min, c) => {
                                    const minRatio = min.hp / min.maxHp;
                                    const cRatio = c.hp / c.maxHp;
                                    return cRatio < minRatio ? c : min;
                                });

                                if (targetChar.hp < targetChar.maxHp) {
                                    const healAmount = char.finalHealRate;
                                    targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                }
                            }
                            char.lastHealTime = currentTime;
                        }
                    }
                });
                
                // 角色回血（无浪费模式）
                noWasteBattleState.characters.forEach(char => {
                    if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                        const timeSinceLastHeal = battleState.elapsedTime - ((char.lastHealTime || 0) / 1000);
                        if (timeSinceLastHeal >= 1.0) {
                            const aliveChars = noWasteBattleState.characters.filter(c => c.isAlive);
                            if (aliveChars.length > 0) {
                                const targetChar = aliveChars.reduce((min, c) => {
                                    const minRatio = min.hp / min.maxHp;
                                    const cRatio = c.hp / c.maxHp;
                                    return cRatio < minRatio ? c : min;
                                });

                                if (targetChar.hp < targetChar.maxHp) {
                                    const healAmount = char.finalHealRate;
                                    targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                }
                            }
                            char.lastHealTime = currentTime;
                        }
                    }
                });

                // 怪物攻击（正常模式，快速模式下不输出详细日志）
                battleState.monsters.forEach(monster => {
                    if (monster.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (monster.lastAttackTime / 1000);
                        const attackInterval = 1 / monster.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval && battleState.characters.some(c => c.isAlive)) {
                            // 快速模式下，不输出每次攻击的详细日志
                            const oldLogLength = document.getElementById('battleLog').children.length;
                            monsterAttack(monster);
                            // 移除详细攻击日志，只保留角色死亡等重要事件
                            const log = document.getElementById('battleLog');
                            while (log.children.length > oldLogLength) {
                                const lastEntry = log.lastChild;
                                if (lastEntry && !lastEntry.innerHTML.includes('阵亡') && !lastEntry.innerHTML.includes('被击败')) {
                                    log.removeChild(lastEntry);
                                } else {
                                    break;
                                }
                            }
                            monster.lastAttackTime = currentTime;
                        }
                    }
                });

                // 怪物攻击（无浪费模式）
                noWasteBattleState.monsters.forEach(monster => {
                    if (monster.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (monster.lastAttackTime / 1000);
                        const attackInterval = 1 / monster.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval && noWasteBattleState.characters.some(c => c.isAlive)) {
                            monsterAttackNoWaste(monster);
                            monster.lastAttackTime = currentTime;
                        }
                    }
                });

                // 清理死亡怪物
                battleState.monsters = battleState.monsters.filter(monster => monster.isAlive);
                noWasteBattleState.monsters = noWasteBattleState.monsters.filter(monster => monster.isAlive);

                // 每5秒输出一次进度摘要（可选）
                if (battleState.elapsedTime - lastSummaryTime >= 5.0) {
                    const aliveCount = battleState.characters.filter(c => c.isAlive).length;
                    const monsterCount = battleState.monsters.filter(m => m.isAlive).length;
                    addLog(`[${formatTime(battleState.elapsedTime)}] 战斗进行中：存活角色 ${aliveCount}/5，当前怪物 ${monsterCount}，已击败 ${battleState.totalMonstersKilled} 只`);
                    lastSummaryTime = battleState.elapsedTime;
                }

                // 检查200秒限制：如果超过200秒且角色1仍存活，结束战斗并标记为"几乎不会死"
                const char1 = battleState.characters.find(c => c.id === 1);
                if (battleState.elapsedTime >= 200 && char1 && char1.isAlive) {
                    battleState.char1NeverDies = true;
                    // 设置角色1的死亡时间为特殊标记（用于关卡判断）
                    char1.deathTime = 'never';
                    battleState.isRunning = false;
                    noWasteBattleState.isRunning = false;
                    addLog(`<span style="color: #51cf66; font-weight: bold;">战斗时间超过200秒，角色1仍存活，判定为"几乎不会死"</span>`);
                    break;
                }

                // 检查战斗结束
                const allCharactersDead = !battleState.characters.some(c => c.isAlive);
                if (allCharactersDead) {
                    battleState.isRunning = false;
                    noWasteBattleState.isRunning = false;
                    break;
                }
            }

            // 战斗结束
            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            
            // 更新显示
            updateBattleDisplay();
            
            // 结束战斗
            const win = battleState.characters.some(c => c.isAlive);
            endBattle(win);
            
            // 检查关卡挑战结果
            checkStageResult();
            
            // 恢复按钮状态
            document.getElementById('startBtn').disabled = false;
            document.getElementById('quickResultBtn').disabled = false;
            document.getElementById('startBtn').textContent = '重新开始战斗';
        };

        // 战斗循环
        function battleLoop() {
            if (!battleState.isRunning) {
                return;
            }

            const now = Date.now();
            battleState.elapsedTime = (now - battleState.startTime) / 1000;
            noWasteBattleState.elapsedTime = battleState.elapsedTime;

            // 刷新怪物（两种模式同时刷新）
            if (now >= battleState.nextSpawnTime) {
                spawnMonster();
                spawnMonsterNoWaste();
                const spawnInterval = 1000 / monsterConfig.spawnRate;
                battleState.nextSpawnTime = now + spawnInterval;
                noWasteBattleState.nextSpawnTime = battleState.nextSpawnTime;
            }

            // 角色攻击（正常模式）
            battleState.characters.forEach(char => {
                if (char.isAlive && battleState.monsters.length > 0) {
                    const timeSinceLastAttack = (now - char.lastAttackTime) / 1000;
                    const attackInterval = 1 / char.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval) {
                        characterAttack(char);
                        char.lastAttackTime = now;
                    }
                }
            });
            
            // 角色攻击（无浪费模式）
            noWasteBattleState.characters.forEach((char, index) => {
                if (char.isAlive) {
                    const timeSinceLastAttack = (now - char.lastAttackTime) / 1000;
                    const attackInterval = 1 / char.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval) {
                        characterAttackNoWaste(char);
                        char.lastAttackTime = now;
                    }
                }
            });

            // 角色回血（角色5为血量比例最少的角色恢复，正常模式）
            battleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || battleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) { // 每秒回血一次
                        // 找到血量比例最少的存活角色
                        const aliveChars = battleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            // 如果目标血量不是满的，进行治疗
                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate; // 使用最终回血速度
                                const oldHp = targetChar.hp;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                const actualHeal = targetChar.hp - oldHp;
                                
                                if (actualHeal > 0) {
                                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-heal">${char.name}</span> 为 ${targetChar.name} 恢复 ${actualHeal.toFixed(1)} 点生命值`);
                                    showDamageNumber(`panel-char-${targetChar.id}`, `+${actualHeal.toFixed(1)}`, true);
                                }
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });
            
            // 角色回血（角色5为血量比例最少的角色恢复，无浪费模式）
            noWasteBattleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || noWasteBattleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) { // 每秒回血一次
                        // 找到血量比例最少的存活角色
                        const aliveChars = noWasteBattleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            // 如果目标血量不是满的，进行治疗
                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate; // 使用最终回血速度
                                const oldHp = targetChar.hp;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });

            // 怪物攻击（正常模式）
            battleState.monsters.forEach(monster => {
                if (monster.isAlive) {
                    const timeSinceLastAttack = (now - monster.lastAttackTime) / 1000;
                    const attackInterval = 1 / monster.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval && battleState.characters.some(c => c.isAlive)) {
                        monsterAttack(monster);
                        monster.lastAttackTime = now;
                    }
                }
            });

            // 怪物攻击（无浪费模式）
            noWasteBattleState.monsters.forEach(monster => {
                if (monster.isAlive) {
                    const timeSinceLastAttack = (now - monster.lastAttackTime) / 1000;
                    const attackInterval = 1 / monster.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval && noWasteBattleState.characters.some(c => c.isAlive)) {
                        monsterAttackNoWaste(monster);
                        monster.lastAttackTime = now;
                    }
                }
            });

            // 清理死亡怪物
            battleState.monsters = battleState.monsters.filter(monster => monster.isAlive);
            noWasteBattleState.monsters = noWasteBattleState.monsters.filter(monster => monster.isAlive);

            // 更新显示
            updateBattleDisplay();

            // 检查200秒限制：如果超过200秒且角色1仍存活，结束战斗并标记为"几乎不会死"
            const char1 = battleState.characters.find(c => c.id === 1);
            if (battleState.elapsedTime >= 200 && char1 && char1.isAlive) {
                battleState.char1NeverDies = true;
                // 设置角色1的死亡时间为特殊标记（用于关卡判断）
                char1.deathTime = 'never';
                addLog(`<span style="color: #51cf66; font-weight: bold;">战斗时间超过200秒，角色1仍存活，判定为"几乎不会死"</span>`);
                endBattle(true); // 角色1存活，判定为胜利
                return;
            }

            // 检查战斗结束
            const allCharactersDead = !battleState.characters.some(c => c.isAlive);
            if (allCharactersDead) {
                endBattle(false);
                return;
            }

            // 继续循环
            requestAnimationFrame(battleLoop);
        }

        // 刷新怪物（正常模式）
        function spawnMonster() {
            battleState.monsterIdCounter++;
            // 应用血量系数：进入战斗时的血量 = 基础血量 × (1 + 血量系数)
            const actualHp = Math.floor(monsterConfig.hp * (1 + (monsterConfig.hpCoeff || 0)));
            const monster = {
                id: battleState.monsterIdCounter,
                attack: monsterConfig.attack,
                defense: monsterConfig.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: monsterConfig.atkSpeed,
                isAlive: true,
                lastAttackTime: 0
            };
            battleState.monsters.push(monster);
            battleState.totalMonstersSpawned++;
            addLog(`[${formatTime(battleState.elapsedTime)}] 怪物 #${monster.id} 出现！`);
        }

        // 刷新怪物（无浪费模式）
        function spawnMonsterNoWaste() {
            noWasteBattleState.monsterIdCounter++;
            // 应用血量系数：进入战斗时的血量 = 基础血量 × (1 + 血量系数)
            const actualHp = Math.floor(monsterConfig.hp * (1 + (monsterConfig.hpCoeff || 0)));
            const monster = {
                id: noWasteBattleState.monsterIdCounter,
                attack: monsterConfig.attack,
                defense: monsterConfig.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: monsterConfig.atkSpeed,
                isAlive: true,
                lastAttackTime: 0
            };
            noWasteBattleState.monsters.push(monster);
            noWasteBattleState.totalMonstersSpawned++;
        }

        // 角色攻击
        function characterAttack(character) {
            if (battleState.monsters.length === 0) return;

            // 攻击第一个存活的怪物
            const target = battleState.monsters.find(m => m.isAlive);
            if (!target) return;

            // 基础伤害计算
            let baseDamage = Math.max(1, character.attack - target.defense);
            
            // 角色2、3、4的技能伤害加成
            let finalDamage = baseDamage;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && character.skillDamage > 0) {
                const skillBonus = baseDamage * (character.skillDamage / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            target.hp -= finalDamage;
            battleState.totalDamageDealt += finalDamage;

            let damageText = finalDamage === baseDamage 
                ? `${finalDamage}`
                : `${finalDamage}（基础${baseDamage} + 技能${(finalDamage - baseDamage).toFixed(1)}）`;
            
            addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-damage">${character.name}</span> 攻击 怪物 #${target.id}，造成 ${damageText} 点伤害`);

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                battleState.totalMonstersKilled++;
                addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">怪物 #${target.id} 被击败！</span>`);
            }
        }

        // 角色攻击（无浪费模式，剩余伤害传递到下一只怪物）
        function characterAttackNoWaste(character) {
            // 基础伤害计算（使用怪物配置的防御力）
            let baseDamage = Math.max(1, character.attack - monsterConfig.defense);
            
            // 角色2、3、4的技能伤害加成
            let finalDamage = baseDamage;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && character.skillDamage > 0) {
                const skillBonus = baseDamage * (character.skillDamage / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            // 加上溢出伤害
            finalDamage += noWasteBattleState.overflowDamage;
            noWasteBattleState.overflowDamage = 0;
            
            // 找到第一个存活的怪物
            let target = noWasteBattleState.monsters.find(m => m.isAlive);
            
            // 如果没有存活的怪物，将伤害保存为溢出伤害，等待下一个怪物出现
            if (!target) {
                noWasteBattleState.overflowDamage = finalDamage;
                return;
            }
            
            const targetHpBefore = target.hp;
            target.hp -= finalDamage;
            noWasteBattleState.totalDamageDealt += finalDamage;

            // 如果怪物被击败，计算溢出伤害
            if (target.hp <= 0) {
                const overflow = Math.abs(target.hp); // 溢出的伤害
                noWasteBattleState.overflowDamage = overflow;
                target.hp = 0;
                target.isAlive = false;
                noWasteBattleState.totalMonstersKilled++;
            }
        }

        // 怪物攻击（优先攻击角色1，按1~5顺序）
        function monsterAttack(monster) {
            // 按顺序找存活的角色（角色1到角色5）
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = battleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // 基础伤害计算
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // 角色1的减伤百分比
            let damageAfterReduction = baseDamage;
            if (target.id === 1 && target.damageReduction > 0) {
                const reduction = baseDamage * (target.damageReduction / 100);
                damageAfterReduction = baseDamage - reduction;
                damageAfterReduction = Math.max(1, Math.floor(damageAfterReduction));
            }
            
            // 应用怪物攻击系数
            let finalDamage = damageAfterReduction * (monsterConfig.damageCoeff || 1);
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            battleState.totalDamageTaken += finalDamage;

            let damageText = '';
            if (finalDamage === baseDamage && monsterConfig.damageCoeff === 1) {
                damageText = `${finalDamage}`;
            } else {
                const parts = [];
                if (baseDamage !== damageAfterReduction) {
                    parts.push(`基础${baseDamage} - 减伤${(baseDamage - damageAfterReduction).toFixed(1)}`);
                } else {
                    parts.push(`基础${baseDamage}`);
                }
                if (monsterConfig.damageCoeff !== 1) {
                    parts.push(`× 系数${monsterConfig.damageCoeff.toFixed(2)}`);
                }
                damageText = `${finalDamage}（${parts.join('，')}）`;
            }
            
            addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-damage">怪物 #${monster.id}</span> 攻击 ${target.name}，造成 ${damageText} 点伤害`);
            showDamageNumber(`panel-char-${target.id}`, `-${finalDamage}`, false);

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = battleState.elapsedTime; // 记录该角色的死亡时间
                updateCharacterStatus(target.id, false);
                
                // 记录第一个角色死亡时间
                if (battleState.firstCharacterDeathTime === null) {
                    battleState.firstCharacterDeathTime = battleState.elapsedTime;
                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">${target.name} 阵亡！[首个阵亡角色]</span>`);
                } else {
                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">${target.name} 阵亡！</span>`);
                }
            }
        }

        // 怪物攻击（无浪费模式）
        function monsterAttackNoWaste(monster) {
            // 按顺序找存活的角色（角色1到角色5）
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = noWasteBattleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // 基础伤害计算
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // 角色1的减伤百分比
            let damageAfterReduction = baseDamage;
            if (target.id === 1 && target.damageReduction > 0) {
                const reduction = baseDamage * (target.damageReduction / 100);
                damageAfterReduction = baseDamage - reduction;
                damageAfterReduction = Math.max(1, Math.floor(damageAfterReduction));
            }
            
            // 应用怪物攻击系数
            let finalDamage = damageAfterReduction * (monsterConfig.damageCoeff || 1);
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            noWasteBattleState.totalDamageTaken += finalDamage;

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = noWasteBattleState.elapsedTime; // 记录该角色的死亡时间
                
                // 记录第一个角色死亡时间
                if (noWasteBattleState.firstCharacterDeathTime === null) {
                    noWasteBattleState.firstCharacterDeathTime = noWasteBattleState.elapsedTime;
                }
            }
        }

        // 更新战斗显示
        function updateBattleDisplay() {
            // 更新角色HP条（配置区域）
            battleState.characters.forEach(char => {
                const hpPercent = (char.hp / char.maxHp) * 100;
                const hpBar = document.getElementById(`hp-bar-${char.id}`);
                if (hpBar) {
                    hpBar.style.width = `${hpPercent}%`;
                }
            });

            // 更新角色面板
            updateCharactersPanel();

            // 更新统计（同时显示正常模式和无浪费模式）
            const stats = `
                <div class="stat-card" style="grid-column: 1 / -1; background: #f0f0f0; padding: 10px; margin-bottom: 10px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">正常模式（伤害不溢出）</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div>
                            <div style="font-size: 0.85em; color: #666;">战斗时长</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${formatTime(battleState.elapsedTime)}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">存活角色</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.characters.filter(c => c.isAlive).length}/5</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">当前怪物数</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.monsters.filter(m => m.isAlive).length}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">已击败怪物</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.totalMonstersKilled}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">总伤害输出</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #f44336;">${battleState.totalDamageDealt}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">承受伤害</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #ff9800;">${battleState.totalDamageTaken}</div>
                        </div>
                    </div>
                </div>
                <div class="stat-card" style="grid-column: 1 / -1; background: #e8f5e9; padding: 10px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">无浪费模式（剩余伤害传递）</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div>
                            <div style="font-size: 0.85em; color: #666;">战斗时长</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${formatTime(noWasteBattleState.elapsedTime)}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">存活角色</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.characters.filter(c => c.isAlive).length}/5</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">当前怪物数</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.monsters.filter(m => m.isAlive).length}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">已击败怪物</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.totalMonstersKilled}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">总伤害输出</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #f44336;">${noWasteBattleState.totalDamageDealt}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">承受伤害</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #ff9800;">${noWasteBattleState.totalDamageTaken}</div>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('battleStats').innerHTML = stats;
        }

        // 更新角色面板
        function updateCharactersPanel() {
            const panel = document.getElementById('charactersPanel');
            panel.innerHTML = battleState.characters.map(char => {
                const hpPercent = (char.hp / char.maxHp) * 100;
                const statusClass = char.isAlive ? 'alive' : 'dead';
                const jobName = JOB_NAMES[char.job] || '未知';
                return `
                    <div class="char-panel-item ${statusClass}" id="panel-char-${char.id}">
                        <div class="char-panel-name">${char.name} <span style="font-size: 0.85em; color: #667eea;">[${jobName}]</span></div>
                        <div class="char-panel-hp">${char.hp.toFixed(0)} / ${char.maxHp} (${hpPercent.toFixed(0)}%)</div>
                        <div class="char-panel-hp-bar">
                            <div class="char-panel-hp-fill" style="width: ${hpPercent}%;"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 显示伤害数字动画
        // 显示伤害数字动画（兼容两种调用方式：elementId字符串 或 element对象）
        function showDamageNumber(elementOrId, damageOrText, isHeal = false) {
            let element = null;
            let damageText = '';
            
            // 判断第一个参数是字符串ID还是DOM元素
            if (typeof elementOrId === 'string') {
                // 旧版本调用：showDamageNumber(elementId, text, isHeal)
                element = document.getElementById(elementOrId);
                damageText = damageOrText; // 第二个参数直接是文本
            } else if (elementOrId && typeof elementOrId.getBoundingClientRect === 'function') {
                // 新版本调用：showDamageNumber(element, damage, isHeal)
                element = elementOrId;
                const damage = typeof damageOrText === 'number' ? damageOrText : parseFloat(damageOrText) || 0;
                damageText = isHeal ? `+${damage.toFixed(0)}` : `-${damage.toFixed(0)}`;
            } else {
                return; // 无效参数
            }
            
            if (!element) return;

            // 检查是否有波次战斗场景（优先）
            let battleScene = null;
            let isInWaveBattle = false;
            
            // 检查是否在波次战斗中进行
            if (typeof waveBattleState !== 'undefined' && waveBattleState && waveBattleState.isRunning) {
                battleScene = document.getElementById('waveBattleScene');
                if (battleScene) {
                    // 检查元素是否在波次战斗区域内
                    const waveBattleArea = document.getElementById('waveBattleArea');
                    if (waveBattleArea && (waveBattleArea.contains(element) || element.closest('#waveBattleArea'))) {
                        isInWaveBattle = true;
                    }
                }
            }
            
            // 如果没有波次战斗场景，检查普通战斗场景
            if (!battleScene || !isInWaveBattle) {
                const normalBattleScene = document.getElementById('battleScene');
                if (normalBattleScene && normalBattleScene.contains(element)) {
                    battleScene = normalBattleScene;
                    isInWaveBattle = false;
                }
            }
            
            if (battleScene && (isInWaveBattle || battleScene.contains(element))) {
                // 战斗场景模式：在战斗场景中显示
                const rect = element.getBoundingClientRect();
                const sceneRect = battleScene.getBoundingClientRect();
                const x = rect.left - sceneRect.left + rect.width / 2;
                const y = rect.top - sceneRect.top;
                
                const damageEl = document.createElement('div');
                damageEl.className = isHeal ? 'heal-number' : 'damage-number';
                damageEl.textContent = damageText;
                damageEl.style.left = x + 'px';
                damageEl.style.top = y + 'px';
                damageEl.style.position = 'absolute';
                damageEl.style.zIndex = '1000';
                damageEl.style.pointerEvents = 'none';
                
                battleScene.appendChild(damageEl);
                
                setTimeout(() => {
                    if (damageEl.parentNode) {
                        damageEl.parentNode.removeChild(damageEl);
                    }
                }, 1000);
            } else {
                // 普通模式：在元素内部显示
                const damageEl = document.createElement('div');
                damageEl.className = isHeal ? 'heal-number' : 'damage-number';
                damageEl.textContent = damageText;
                element.appendChild(damageEl);

                setTimeout(() => {
                    if (damageEl.parentNode) {
                        damageEl.parentNode.removeChild(damageEl);
                    }
                }, 1000);
            }
        }

        // 更新角色状态显示
        function updateCharacterStatus(charId, isAlive) {
            const statusEl = document.getElementById(`status-${charId}`);
            if (statusEl) {
                statusEl.textContent = isAlive ? '存活' : '阵亡';
                statusEl.className = `character-status ${isAlive ? 'status-alive' : 'status-dead'}`;
            }
        }

        // 结束战斗
        function endBattle(win) {
            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '重新开始战斗';
            document.getElementById('stopBtn').style.display = 'none';

            if (win) {
                addLog(`<span style="color: #51cf66; font-weight: bold;">战斗胜利！</span>`);
            } else {
                addLog(`<span style="color: #ff6b6b; font-weight: bold;">战斗失败！所有角色阵亡。</span>`);
            }

            // 显示第一个角色死亡时间
            let deathInfo = '';
            if (battleState.char1NeverDies) {
                // 如果角色1"几乎不会死"，显示特殊信息
                deathInfo = `，角色1死亡时间: 几乎不会死（超过200秒仍存活）`;
            } else if (battleState.firstCharacterDeathTime !== null) {
                deathInfo = `，首个角色死亡时间: ${formatTime(battleState.firstCharacterDeathTime)}`;
                
                // 保存第一个角色死亡时间到当前方案
                saveFirstDeathTimeToScheme(battleState.firstCharacterDeathTime);
            }

            addLog(`战斗结束。正常模式：击败怪物 ${battleState.totalMonstersKilled}，伤害输出 ${battleState.totalDamageDealt}，战斗时长 ${formatTime(battleState.elapsedTime)}${deathInfo}`);
            addLog(`无浪费模式：击败怪物 ${noWasteBattleState.totalMonstersKilled}，伤害输出 ${noWasteBattleState.totalDamageDealt}，战斗时长 ${formatTime(noWasteBattleState.elapsedTime)}`);

            // 更新战斗统计显示
            updateBattleStatsAfterEnd();
            
            // 检查关卡挑战结果
            checkStageResult();
        }

        // 保存第一个角色死亡时间到当前方案
        function saveFirstDeathTimeToScheme(deathTime) {
            if (!currentSchemeId) {
                return; // 如果没有当前方案，不保存
            }

            try {
                const schemes = loadSchemes();
                const schemeIndex = schemes.findIndex(s => s.id === currentSchemeId);
                
                if (schemeIndex >= 0) {
                    schemes[schemeIndex].lastDeathTime = {
                        time: deathTime,
                        timestamp: new Date().toISOString(),
                        date: new Date().toLocaleString('zh-CN')
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));
                }
            } catch (error) {
                console.error('保存死亡时间到方案失败:', error);
            }
        }

        // 更新战斗统计（战斗结束后）
        function updateBattleStatsAfterEnd() {
            const stats = document.getElementById('battleStats');
            if (!stats) return;

            let deathTimeDisplay = '';
            if (battleState.firstCharacterDeathTime !== null) {
                deathTimeDisplay = `
                    <div class="stat-card" style="border: 2px solid #ff6b6b;">
                        <div class="stat-label">首个角色死亡时间</div>
                        <div class="stat-value" style="color: #ff6b6b;">${formatTime(battleState.firstCharacterDeathTime)}</div>
                    </div>
                `;
            }

            const currentStats = stats.innerHTML;
            if (deathTimeDisplay && !currentStats.includes('首个角色死亡时间')) {
                stats.innerHTML = currentStats + deathTimeDisplay;
            }
        }

        // 添加日志
        function addLog(message) {
            // 优先使用波次战斗日志（如果波次战斗正在进行），否则使用普通战斗日志
            let log = null;
            if (waveBattleState.isRunning) {
                log = document.getElementById('waveBattleLog');
            }
            if (!log) {
                log = document.getElementById('battleLog');
            }
            if (!log) return;
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // 开始波次战斗（可视化模拟）
        window.startWaveBattle = function() {
            if (waveBattleState.isRunning) {
                return;
            }

            // 从界面读取最新的25波怪物数据配置（确保每次战斗都使用最新的界面配置）
            for (let wave = 1; wave <= 25; wave++) {
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect && attackInput && defenseInput && hpInput && 
                    atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                    spawnRateInput && durationInput) {
                    battleWaveData[wave] = {
                        monsterId: monsterSelect.value || '',
                        attack: parseFloat(attackInput.value) || 10,
                        defense: parseFloat(defenseInput.value) || 5,
                        hp: parseFloat(hpInput.value) || 50,
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                        spawnRate: parseFloat(spawnRateInput.value) || 1,
                        duration: parseFloat(durationInput.value) || 10,
                        coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                    };
                }
            }

            // 检查是否有配置的波次
            let hasWaveConfig = false;
            for (let wave = 1; wave <= 25; wave++) {
                if (battleWaveData[wave] && (battleWaveData[wave].monsterId || battleWaveData[wave].attack > 0)) {
                    hasWaveConfig = true;
                    break;
                }
            }

            if (!hasWaveConfig) {
                showMessage('请先配置至少一波怪物数据', 'error');
                return;
            }

            // 读取怪物攻击延迟配置（秒）
            const delayInput = document.getElementById('monsterAttackDelayInput');
            if (delayInput) {
                const val = parseFloat(delayInput.value);
                monsterAttackDelay = isNaN(val) || val < 0 ? 0 : val;
            } else {
                monsterAttackDelay = 3; // 安全兜底
            }

            // 读取角色攻击频率（秒/次）和伤害倍率配置
            const atkIntervalInput = document.getElementById('characterAttackIntervalInput');
            if (atkIntervalInput) {
                const val = parseFloat(atkIntervalInput.value);
                characterAttackInterval = isNaN(val) || val <= 0 ? 0.1 : val;
            } else {
                characterAttackInterval = 0.1;
            }

            const dmgScaleInput = document.getElementById('characterDamageScaleInput');
            if (dmgScaleInput) {
                const val = parseFloat(dmgScaleInput.value);
                characterDamageScale = isNaN(val) || val <= 0 ? 0.1 : val;
            } else {
                characterDamageScale = 0.1;
            }

            // 从界面读取最新的平台属性配置并更新
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount')?.value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum')?.value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff')?.value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff')?.value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff')?.value) || 0;
            
            // 从界面读取最新的车辆属性配置并更新
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack')?.value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense')?.value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp')?.value) || 0;
            
            // 重新应用所有角色的属性（确保包含最新的装备、平台、车辆加成）
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // 重置银币和升级信息
            waveBattleCoins = 0;
            weaponLevel = 0;
            skillLevel = 0;
            
            // 从界面读取据点奖励配置
            for (let i = 1; i <= 5; i++) {
                const rewardInput = document.getElementById(`stronghold${i}Reward`);
                strongholdRewards[i] = rewardInput ? (parseInt(rewardInput.value) || 0) : 0;
            }
            
            // 重置波次战斗状态
            // 注意：char.attack 此时已经包含了装备、平台、车辆加成的最终攻击力
            // baseAttack 应该使用 char.baseAttack（基础攻击力），而不是 char.attack（最终攻击力）
            const battleStartTime = Date.now(); // 记录战斗开始时间
            waveBattleState = {
                isRunning: true,
                startTime: battleStartTime,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    // 保存真正的角色基础属性，不包含装备加成（baseAttack/baseDefense/baseHp）
                    // char.attack/char.defense/char.maxHp 是最终属性（包含装备、平台、车辆加成）
                    // 这些最终属性会用于战斗计算，但需要保存基础属性以便正确初始化
                    baseAttack: char.baseAttack || 20, // 保存基础攻击力（不包含装备加成）
                    baseDefense: char.baseDefense || 10, // 保存基础防御力
                    baseHp: char.baseHp || 100, // 保存基础血量
                    // 战斗使用的最终属性（包含所有加成）
                    attack: char.attack || char.baseAttack || 20, // 最终攻击力
                    defense: char.defense || char.baseDefense || 10, // 最终防御力
                    maxHp: char.maxHp || char.baseHp || 100, // 最终最大血量
                    hp: char.maxHp || char.baseHp || 100, // 当前血量 = 最大血量
                    isAlive: true,
                    lastAttackTime: battleStartTime, // 初始化为战斗开始时间，确保第一次攻击可以立即进行
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0,
                    deathTime: null,
                    skillDamage: 0 // 重置技能伤害加成
                })),
                monsters: [],
                currentWave: 0,
                currentStronghold: 0,
                strongholdCompleted: {},
                waveStartTime: 0,
                waveSpawnedCount: 0,
                waveTotalCount: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                spawnAccumulator: 0, // 怪物生成累计值（用于小数生成率）
                lastSpawnCheckTime: Date.now() // 上次检查生成的时间
            };

            // 显示战斗区域（在tab-battle页签内）
            const waveBattleArea = document.getElementById('waveBattleArea');
            if (waveBattleArea) {
                waveBattleArea.style.display = 'block';
            }
            
            // 清空战斗日志
            const log = document.getElementById('battleLog');
            if (log) log.innerHTML = '';

            // 更新按钮状态
            const startBtn = document.getElementById('startWaveBattleBtn');
            const stopBtn = document.getElementById('stopWaveBattleBtn');
            if (startBtn) startBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            // 显示波次信息
            const info = document.getElementById('waveBattleInfo');
            if (info) info.style.display = 'block';

            // 显示战斗UI面板（仅波次战斗）
            const uiPanel = document.getElementById('waveBattleUIPanel');
            if (uiPanel) {
                uiPanel.style.display = 'block';
            }

            // 开始第一波（这会在内部调用 updateBattleScene）
            startNextWave();
            
            // 初始化可视化场景（在开始第一波后立即调用）
            updateBattleScene();
            
            // 更新银币和升级按钮显示（确保在显示UI面板后更新）
            updateCoinsDisplay();
            updateUpgradeButtons();
            
            // 更新战斗统计显示
            updateWaveBattleDisplay();
            
            // 滚动到战斗区域
            if (waveBattleArea) {
                setTimeout(() => {
                    waveBattleArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }

            // 开始战斗循环
            waveBattleLoop();
        };

        // 停止波次战斗
        window.stopWaveBattle = function() {
            if (!waveBattleState.isRunning) {
                return;
            }

            waveBattleState.isRunning = false;

            // 更新按钮状态
            const startBtn = document.getElementById('startWaveBattleBtn');
            const stopBtn = document.getElementById('stopWaveBattleBtn');
            if (startBtn) startBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';

            const status = document.getElementById('waveBattleStatus');
            if (status) status.textContent = '模拟已停止';

            addLog(`<span style="color: #ffc107; font-weight: bold;">波次战斗已手动停止！</span>`);
            addLog(`总统计：击败怪物 ${waveBattleState.totalMonstersKilled}，伤害输出 ${waveBattleState.totalDamageDealt}，战斗时长 ${formatTime(waveBattleState.elapsedTime)}`);
        };

        // 开始下一波
        // 检查当前据点的所有怪物是否都已死亡
        function isCurrentStrongholdCleared() {
            if (waveBattleState.currentStronghold <= 0 || waveBattleState.currentStronghold > 5) {
                return false;
            }
            
            const waveRange = getStrongholdWaveRange(waveBattleState.currentStronghold);
            
            // 首先检查场景内是否有该据点的存活怪物
            const aliveMonsters = waveBattleState.monsters.filter(m => 
                m.isAlive && 
                m.wave >= waveRange.start && 
                m.wave <= waveRange.end
            );
            
            // 如果场景内还有存活怪物，据点未完成
            if (aliveMonsters.length > 0) {
                return false;
            }
            
            // 场景内没有存活怪物后，还需要检查据点的最后一个波次是否已经完成
            // 如果据点的最后一个波次（waveRange.end）已经完成，且场景内没有存活怪物，
            // 说明据点的所有波次都已完成（因为只有在前一个波次完成后才会开始下一个波次）
            const lastWave = waveRange.end;
            const lastWaveData = battleWaveData[lastWave];
            
            // 如果最后一个波次没有配置，或者当前波次已经超过了最后一个波次，说明据点已完成
            if (!lastWaveData || (!lastWaveData.monsterId && lastWaveData.attack <= 0)) {
                // 最后一个波次没有配置，只要场景内没有存活怪物就算完成
                return true;
            }
            
            // 如果当前波次还未开始据点的最后一个波次，据点未完成
            if (waveBattleState.currentWave < lastWave) {
                return false;
            }
            
            // 如果当前波次正好是据点的最后一个波次，检查该波次是否已经完成
            if (waveBattleState.currentWave === lastWave) {
                const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                const waveFinished = waveElapsedTime >= lastWaveData.duration || 
                                   waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount;
                if (!waveFinished) {
                    return false; // 最后一个波次还未完成，据点未完成
                }
            }
            
            // 所有条件都满足：场景内没有存活怪物，且据点的最后一个波次已完成
            return true;
        }
        
        // 检查并发放据点完成奖励（立即发放，不等待下一波）
        function checkAndGrantStrongholdReward() {
            if (waveBattleState.currentStronghold <= 0 || waveBattleState.currentStronghold > 5) {
                return;
            }
            
            // 检查当前据点是否已完成且还未发放奖励
            if (isCurrentStrongholdCleared() && !waveBattleState.strongholdCompleted[waveBattleState.currentStronghold]) {
                const reward = strongholdRewards[waveBattleState.currentStronghold] || 0;
                if (reward > 0) {
                    waveBattleCoins += reward;
                    updateCoinsDisplay();
                    addLog(`<span style="color: #ffd43b; font-weight: bold;">据点 ${waveBattleState.currentStronghold} 完成！获得 ${reward} 银币奖励！</span>`);
                }
                waveBattleState.strongholdCompleted[waveBattleState.currentStronghold] = true;
            }
        }
        
        function startNextWave() {
            // 查找下一个有配置的波次
            while (waveBattleState.currentWave < 25) {
                waveBattleState.currentWave++;
                
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData && (waveData.monsterId || waveData.attack > 0)) {
                    // 找到有配置的波次，检查是否属于新的据点
                    const newStronghold = getStrongholdForWave(waveBattleState.currentWave);
                    if (newStronghold > waveBattleState.currentStronghold) {
                        // 进入新据点，需要等待上一个据点所有怪物死亡
                        // 同据点不同波次不需要等待，只有跨据点才需要等待
                        if (waveBattleState.currentStronghold > 0 && !isCurrentStrongholdCleared()) {
                            // 上一个据点还有怪物存活，不能开始新据点
                            waveBattleState.currentWave--; // 回退
                            return;
                        }
                        // 上一个据点已完成，检查是否应该给予据点奖励（如果在怪物死亡时未发放，这里作为备用）
                        if (waveBattleState.currentStronghold > 0) {
                            checkAndGrantStrongholdReward();
                        }
                        waveBattleState.currentStronghold = newStronghold;
                    }
                    // 找到有配置的波次，开始这一波（同据点内直接开始，不需要等待）
                    break;
                }
            }
            
            if (waveBattleState.currentWave > 25) {
                // 所有波次完成
                waveBattleState.isRunning = false;
                addLog(`<span style="color: #51cf66; font-weight: bold;">所有25波怪物已完成！</span>`);
                addLog(`总统计：击败怪物 ${waveBattleState.totalMonstersKilled}，伤害输出 ${waveBattleState.totalDamageDealt}，战斗时长 ${formatTime(waveBattleState.elapsedTime)}`);
                
                // 更新按钮状态
                const startBtn = document.getElementById('startWaveBattleBtn');
                const stopBtn = document.getElementById('stopWaveBattleBtn');
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                
                const status = document.getElementById('waveBattleStatus');
                if (status) status.textContent = '所有波次已完成';
                
                return;
            }

            const waveData = battleWaveData[waveBattleState.currentWave];

            waveBattleState.waveStartTime = waveBattleState.elapsedTime;
            waveBattleState.waveSpawnedCount = 0;
            // 计算总怪物数（使用累计机制，所以可以是小数累计到整数）
            waveBattleState.waveTotalCount = Math.floor(waveData.spawnRate * waveData.duration);
            waveBattleState.nextSpawnTime = Date.now();
            waveBattleState.spawnAccumulator = 0; // 重置累计值
            waveBattleState.lastSpawnCheckTime = Date.now(); // 重置检查时间

            // 更新显示
            updateWaveBattleInfo();
            
            // 更新可视化场景（显示当前波次）
            updateBattleScene();

            addLog(`<span style="color: #667eea; font-weight: bold;">========== 第 ${waveBattleState.currentWave} 波开始 ==========</span>`);
            addLog(`怪物属性：攻击 ${waveData.attack}，防御 ${waveData.defense}，生命 ${waveData.hp}，攻速 ${waveData.atkSpeed}，伤害系数 ${waveData.damageCoeff}，生命值倍率 ${waveData.hpCoeff}`);
            addLog(`刷新速度：${waveData.spawnRate} 只/秒，持续时间：${waveData.duration} 秒，总怪物数：${waveBattleState.waveTotalCount}`);
        }

        // 生成波次怪物
        // 注意：为了支持"同一时刻批量出怪"（避免逐只刷新导致明显先后顺序），这里不再负责刷新场景/UI，调用方批量生成后统一刷新。
        function spawnWaveMonster(spawnTimeSec) {
            if (waveBattleState.currentWave <= 0 || waveBattleState.currentWave > 25) {
                return;
            }

            const waveData = battleWaveData[waveBattleState.currentWave];
            if (!waveData) {
                return;
            }

            // 检查是否已经出完当前波次的所有怪物
            if (waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                return;
            }

            // 检查是否超过持续时间
            const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
            if (waveElapsedTime >= waveData.duration) {
                return;
            }

            waveBattleState.monsterIdCounter++;
            
            // 应用生命值倍率
            const actualHp = Math.floor(waveData.hp * waveData.hpCoeff);
            
            const monster = {
                id: waveBattleState.monsterIdCounter,
                wave: waveBattleState.currentWave,
                attack: waveData.attack,
                defense: waveData.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: waveData.atkSpeed,
                damageCoeff: waveData.damageCoeff,
                coinReward: waveData.coinReward || 0, // 击杀获得的银币
                spawnTimeSec: (typeof spawnTimeSec === 'number' && isFinite(spawnTimeSec)) ? spawnTimeSec : Math.floor(waveBattleState.elapsedTime),
                spawnGameTime: waveBattleState.elapsedTime, // 精确记录生成时的战斗时间（秒）
                isAlive: true,
                lastAttackTime: 0
            };

            waveBattleState.monsters.push(monster);
            waveBattleState.waveSpawnedCount++;

            addLog(`[${formatTime(waveBattleState.elapsedTime)}] 第${waveBattleState.currentWave}波 怪物 #${monster.id} 出现！`);

            // 累计值已使用，不需要设置下次出怪时间（由累计机制控制）
        }

        // 波次战斗循环
        function waveBattleLoop() {
            if (!waveBattleState.isRunning) {
                return;
            }

            const now = Date.now();
            waveBattleState.elapsedTime = (now - waveBattleState.startTime) / 1000;

            // 检查是否需要开始下一波
            // 需求：当前波怪物刷完后，需要等待当前据点所有怪物死亡才能开始下一个据点
            // 为避免因浮点误差导致"刷怪数未完全达到理论总数而卡死"，这里使用"持续时间到 或 刷怪数达到总数"任一条件即可推进下一波
            if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData) {
                    const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                    
                    // 如果当前波次持续时间已到，或怪物已按配置刷完，则尝试开始下一波
                    // 注意：startNextWave内部会检查据点是否完成
                    if (waveElapsedTime >= waveData.duration ||
                        waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                        const oldWave = waveBattleState.currentWave;
                        startNextWave();
                        // 如果成功开始下一波，记录日志
                        if (waveBattleState.currentWave > oldWave) {
                            addLog(`<span style="color: #51cf66;">第 ${oldWave} 波完成！开始下一波...</span>`);
                        }
                    }
                }
            }

            // 生成怪物（使用累计机制支持小数生成率；同一帧内批量出怪后统一刷新，避免明显先后顺序）
            if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData) {
                    // 检查是否超过持续时间（防止在波次结束后继续生成）
                    const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                    if (waveElapsedTime >= waveData.duration) {
                        // 波次持续时间已到，不再生成新怪物
                        // 特别处理：如果是最后一波（第25波），清零累计值，完全停止生成
                        if (waveBattleState.currentWave === 25) {
                            waveBattleState.spawnAccumulator = 0; // 清零累计值，防止继续生成
                        }
                        waveBattleState.lastSpawnCheckTime = now; // 更新时间，避免累计值异常增长
                    } else {
                        // 计算自上次检查以来的时间差（秒）
                        let deltaTime = (now - waveBattleState.lastSpawnCheckTime) / 1000;
                        
                        // 保护措施：限制deltaTime的最大值，避免因循环暂停导致大量怪物生成
                        // 最大允许1秒的时间差（正常情况下每帧间隔很短）
                        if (deltaTime > 1.0) {
                            console.warn(`检测到异常大的时间差: ${deltaTime.toFixed(2)}秒，已限制为1秒`);
                            deltaTime = 1.0;
                        }
                        
                        // 确保lastSpawnCheckTime不为null
                        if (!waveBattleState.lastSpawnCheckTime) {
                            waveBattleState.lastSpawnCheckTime = now;
                            deltaTime = 0;
                        }
                        
                        waveBattleState.lastSpawnCheckTime = now;
                        
                        // 累计怪物数量（每秒spawnRate只）
                        waveBattleState.spawnAccumulator += waveData.spawnRate * deltaTime;
                        
                        // 当累计值>=1时，生成怪物（但不超过当前波次应该生成的总数，且不超过持续时间）
                        let spawnedThisTick = 0;
                        const spawnTimeSec = Math.floor(waveBattleState.elapsedTime);
                        // 重新计算waveElapsedTime，确保在生成过程中也检查持续时间
                        const currentWaveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                        while (waveBattleState.spawnAccumulator >= 1.0 && 
                               waveBattleState.waveSpawnedCount < waveBattleState.waveTotalCount &&
                               currentWaveElapsedTime < waveData.duration) {
                            spawnWaveMonster(spawnTimeSec);
                            waveBattleState.spawnAccumulator -= 1.0; // 减去1只
                            spawnedThisTick++;
                            
                            // 额外保护：如果已经达到总数，清零累计值，避免继续生成
                            if (waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                                waveBattleState.spawnAccumulator = 0;
                                break;
                            }
                            
                            // 额外保护：如果持续时间已到（特别是最后一波），清零累计值并停止生成
                            const checkWaveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                            if (checkWaveElapsedTime >= waveData.duration) {
                                waveBattleState.spawnAccumulator = 0;
                                break;
                            }
                        }

                        // 本帧如果生成了怪物，统一刷新一次，确保同时出现
                        if (spawnedThisTick > 0) {
                            updateWaveBattleInfo();
                            updateBattleScene();
                        }
                    }
                }
            }

            // 角色攻击
            waveBattleState.characters.forEach(char => {
                if (char.isAlive && waveBattleState.monsters.length > 0) {
                    const timeSinceLastAttack = (now - char.lastAttackTime) / 1000;
                    // 使用全局配置的角色攻击频率，默认0.1秒1次
                    const attackInterval = typeof characterAttackInterval === 'number' && characterAttackInterval > 0
                        ? characterAttackInterval
                        : (1 / char.atkSpeed);

                    if (timeSinceLastAttack >= attackInterval) {
                        characterAttackWave(char);
                        char.lastAttackTime = now;
                    }
                }
            });

            // 角色回血（角色5）
            waveBattleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || waveBattleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) {
                        const aliveChars = waveBattleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-heal">${char.name}</span> 为 <span class="log-heal">${targetChar.name}</span> 恢复 ${healAmount.toFixed(2)} 点生命值`);
                                
                                // 显示回血动画和数字
                                const targetSprite = document.getElementById(`char-sprite-${targetChar.id}`);
                                if (targetSprite) {
                                    // 显示回血数字
                                    showDamageNumber(targetSprite, healAmount, true);
                                }
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });

            // 怪物攻击
            waveBattleState.monsters.forEach(monster => {
                if (monster.isAlive) {
                    const timeSinceLastAttack = (now - monster.lastAttackTime) / 1000;
                    const attackInterval = 1 / monster.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval && waveBattleState.characters.some(c => c.isAlive)) {
                        monsterAttackWave(monster);
                        monster.lastAttackTime = now;
                    }
                }
            });

            // 清理死亡怪物
            waveBattleState.monsters = waveBattleState.monsters.filter(monster => monster.isAlive);

            // 检查胜利条件：据点5（第21-25波）所有怪物都已击杀
            // 只有当据点5的所有波次（21-25波）的所有怪物都被击杀后，才算据点5胜利
            // 检查条件：
            // 1. 所有25波都已完成（currentWave > 25，或currentWave === 25且第25波已出完）
            // 2. 当前据点是据点5，且据点5的所有怪物都已死亡
            if (waveBattleState.currentStronghold === 5) {
                let all25WavesFinished = false;
                
                // 检查所有25波是否都已完成
                if (waveBattleState.currentWave > 25) {
                    all25WavesFinished = true;
                } else if (waveBattleState.currentWave === 25) {
                    const waveData = battleWaveData[25];
                    if (waveData) {
                        const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                        // 检查第25波是否已经出完所有怪物（持续时间已到 或 怪物已按配置刷完）
                        all25WavesFinished = waveElapsedTime >= waveData.duration || 
                                             waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount;
                    }
                }
                
                // 检查据点5的所有波次（21-25波）的所有怪物是否都已死亡
                if (all25WavesFinished && isCurrentStrongholdCleared()) {
                    // 判定胜利：据点5胜利
                    waveBattleState.isRunning = false;
                    
                    // 发放据点5的奖励（如果还未发放）
                    checkAndGrantStrongholdReward();
                    
                    addLog(`<span style="color: #51cf66; font-weight: bold;">🏆 胜利！据点5完成！所有第21-25波怪物都已清除！</span>`);
                    addLog(`<span style="color: #51cf66; font-weight: bold;">所有25波怪物已完成！</span>`);
                    addLog(`总统计：击败怪物 ${waveBattleState.totalMonstersKilled}，伤害输出 ${waveBattleState.totalDamageDealt}，战斗时长 ${formatTime(waveBattleState.elapsedTime)}`);
                    
                    // 更新按钮状态
                    const startBtn = document.getElementById('startWaveBattleBtn');
                    const stopBtn = document.getElementById('stopWaveBattleBtn');
                    if (startBtn) startBtn.style.display = 'inline-block';
                    if (stopBtn) stopBtn.style.display = 'none';
                    
                    const status = document.getElementById('waveBattleStatus');
                    if (status) status.textContent = '战斗结束：胜利！';
                    
                    updateWaveBattleDisplay();
                    return;
                }
            }

            // 检查战斗结束（所有角色死亡）
            const allCharactersDead = !waveBattleState.characters.some(c => c.isAlive);
            if (allCharactersDead) {
                waveBattleState.isRunning = false;
                addLog(`<span style="color: #f44336; font-weight: bold;">所有角色阵亡！战斗结束</span>`);
                addLog(`总统计：击败怪物 ${waveBattleState.totalMonstersKilled}，伤害输出 ${waveBattleState.totalDamageDealt}，战斗时长 ${formatTime(waveBattleState.elapsedTime)}`);
                
                // 更新按钮状态
                const startBtn = document.getElementById('startWaveBattleBtn');
                const stopBtn = document.getElementById('stopWaveBattleBtn');
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                
                const status = document.getElementById('waveBattleStatus');
                if (status) status.textContent = '战斗结束：所有角色阵亡';
                
                updateWaveBattleDisplay();
                return;
            }

            // 更新显示
            updateWaveBattleDisplay();
            updateWaveBattleInfo();

            // 继续循环
            requestAnimationFrame(waveBattleLoop);
        }

        // 角色攻击（波次战斗）
        function characterAttackWave(character) {
            if (waveBattleState.monsters.length === 0) return;

            // 攻击第一个存活的怪物
            const target = waveBattleState.monsters.find(m => m.isAlive);
            if (!target) return;

            // 基础伤害计算
            let baseDamage = Math.max(1, character.attack - target.defense);
            
            // 应用武器伤害系数
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const weaponDamageCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            baseDamage = baseDamage * weaponDamageCoeff;
            
            // 角色2、3、4的技能伤害加成
            let finalDamage = baseDamage;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && character.skillDamage > 0) {
                const skillBonus = baseDamage * (character.skillDamage / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            // 应用技能升级伤害系数（所有角色的最终伤害乘以技能升级伤害系数）
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const skillDamageCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
            finalDamage = finalDamage * skillDamageCoeff;

            // 应用统一的角色攻击伤害倍率（例如0.1倍伤害）
            const dmgScale = (typeof characterDamageScale === 'number' && characterDamageScale > 0) ? characterDamageScale : 1.0;
            finalDamage = finalDamage * dmgScale;
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            waveBattleState.totalDamageDealt += finalDamage;

            let damageText = finalDamage === baseDamage 
                ? `${finalDamage}`
                : `${finalDamage}（基础${baseDamage.toFixed(1)} + 技能${(finalDamage - baseDamage).toFixed(1)}）`;
            
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-damage">${character.name}</span> 攻击 第${target.wave}波怪物 #${target.id}，造成 ${damageText} 点伤害`);

            // 显示攻击动画
            const charSprite = document.getElementById(`char-sprite-${character.id}`);
            if (charSprite) {
                charSprite.classList.remove('attacking');
                void charSprite.offsetWidth; // 触发重排
                charSprite.classList.add('attacking');
                setTimeout(() => {
                    charSprite.classList.remove('attacking');
                }, 500);
            }

            // 显示受击动画和伤害数字
            const monsterSprite = document.getElementById(`monster-sprite-${target.id}`);
            if (monsterSprite) {
                monsterSprite.classList.remove('hit');
                void monsterSprite.offsetWidth;
                monsterSprite.classList.add('hit');
                setTimeout(() => {
                    monsterSprite.classList.remove('hit');
                }, 300);
                
                // 显示伤害数字
                showDamageNumber(monsterSprite, finalDamage, false);
            }

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                waveBattleState.totalMonstersKilled++;
                
                // 获得银币
                const coinReward = target.coinReward || 0;
                if (coinReward > 0) {
                    waveBattleCoins += coinReward;
                    updateCoinsDisplay();
                    addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-kill">第${target.wave}波怪物 #${target.id} 被击败！获得 ${coinReward} 银币</span>`);
                } else {
                    addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-kill">第${target.wave}波怪物 #${target.id} 被击败！</span>`);
                }
                
                // 怪物死亡动画
                if (monsterSprite) {
                    monsterSprite.classList.add('dead');
                }
                
                // 检查据点是否完成，如果完成则立即发放据点奖励
                checkAndGrantStrongholdReward();
            }
        }

        // 更新银币显示
        function updateCoinsDisplay() {
            // 只更新波次战斗的银币显示
            const waveCoinsDisplay = document.getElementById('waveCoinsDisplay');
            if (waveCoinsDisplay) {
                waveCoinsDisplay.textContent = waveBattleCoins;
            }
            updateUpgradeButtons();
        }

        // 更新升级按钮状态
        function updateUpgradeButtons() {
            // 只使用波次战斗的按钮
            const weaponBtn = document.getElementById('waveUpgradeWeaponBtn');
            const skillBtn = document.getElementById('waveUpgradeSkillBtn');
            const weaponInfo = document.getElementById('waveWeaponUpgradeInfo');
            const skillInfo = document.getElementById('waveSkillUpgradeInfo');
            
            // 武器升级（从当前等级升级到下一级，读取当前等级对应的价格）
            const nextWeaponLevel = weaponLevel + 1;
            const weaponCost = weaponCostTable.find(w => w.level === weaponLevel);
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const nextWeaponData = weaponCostTable.find(w => w.level === nextWeaponLevel);
            
            if (weaponBtn && weaponInfo) {
                if (weaponCost) {
                    const canUpgrade = waveBattleCoins >= weaponCost.cost;
                    weaponBtn.disabled = !canUpgrade;
                    
                    // 获取当前和下一级的伤害系数
                    const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
                    const nextCoeff = (nextWeaponData && nextWeaponData.damageCoeff !== undefined) ? parseFloat(nextWeaponData.damageCoeff) : currentCoeff;
                    const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
                    
                    weaponInfo.textContent = `Lv.${weaponLevel} (系数${currentCoeff.toFixed(2)}) → Lv.${nextWeaponLevel} (${weaponCost.cost}银币, +${((upgradeRatio - 1) * 100).toFixed(1)}%)`;
                    // 根据是否可以升级设置颜色（按钮主文字）
                    if (canUpgrade) {
                        weaponBtn.style.color = '#90ee90'; // 浅绿色，更清晰
                        weaponInfo.style.color = '#90ee90'; // 信息文字也用浅绿色
                    } else {
                        weaponBtn.style.color = '#ffcccc'; // 浅红色，更清晰
                        weaponInfo.style.color = '#ffcccc'; // 信息文字也用浅红色
                    }
                } else {
                    weaponBtn.disabled = true;
                    const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
                    weaponInfo.textContent = `Lv.${weaponLevel} (系数${currentCoeff.toFixed(2)}, 已满级)`;
                    weaponBtn.style.color = '#ffcccc'; // 浅红色（已满级），更清晰
                    weaponInfo.style.color = '#ffcccc'; // 信息文字也用浅红色
                }
            }
            
            // 技能升级（从当前等级升级到下一级，读取当前等级对应的价格）
            const nextSkillLevel = skillLevel + 1;
            const skillCost = skillCostTable.find(s => s.level === skillLevel);
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const nextSkillData = skillCostTable.find(s => s.level === nextSkillLevel);
            
            if (skillBtn && skillInfo) {
                if (skillCost) {
                    const canUpgrade = waveBattleCoins >= skillCost.cost;
                    skillBtn.disabled = !canUpgrade;
                    
                    // 获取当前和下一级的伤害系数
                    const currentCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
                    const nextCoeff = (nextSkillData && nextSkillData.damageCoeff !== undefined) ? parseFloat(nextSkillData.damageCoeff) : currentCoeff;
                    const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
                    
                    skillInfo.textContent = `Lv.${skillLevel} (系数${currentCoeff.toFixed(2)}) → Lv.${nextSkillLevel} (${skillCost.cost}银币, +${((upgradeRatio - 1) * 100).toFixed(1)}%)`;
                    // 根据是否可以升级设置颜色（按钮主文字）
                    if (canUpgrade) {
                        skillBtn.style.color = '#90ee90'; // 浅绿色，更清晰
                        skillInfo.style.color = '#90ee90'; // 信息文字也用浅绿色
                    } else {
                        skillBtn.style.color = '#ffcccc'; // 浅红色，更清晰
                        skillInfo.style.color = '#ffcccc'; // 信息文字也用浅红色
                    }
                } else {
                    skillBtn.disabled = true;
                    const currentCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
                    skillInfo.textContent = `Lv.${skillLevel} (系数${currentCoeff.toFixed(2)}, 已满级)`;
                    skillBtn.style.color = '#ffcccc'; // 浅红色（已满级），更清晰
                    skillInfo.style.color = '#ffcccc'; // 信息文字也用浅红色
                }
            }
        }

        // 武器升级
        window.upgradeWeapon = function() {
            // 读取当前等级对应的价格（0级升级到1级，读取level=0的价格）
            const weaponCost = weaponCostTable.find(w => w.level === weaponLevel);
            
            if (!weaponCost) {
                showMessage('武器已达到最高等级', 'error');
                return;
            }
            
            if (waveBattleCoins < weaponCost.cost) {
                showMessage(`银币不足！需要 ${weaponCost.cost} 银币，当前只有 ${waveBattleCoins} 银币`, 'error');
                return;
            }
            
            waveBattleCoins -= weaponCost.cost;
            weaponLevel = weaponLevel + 1;
            
            // 获取当前等级的伤害系数
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const damageCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            
            updateCoinsDisplay();
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #667eea; font-weight: bold;">武器升级到 Lv.${weaponLevel}！消耗 ${weaponCost.cost} 银币，伤害系数 ${damageCoeff.toFixed(2)}</span>`);
        };

        // 技能升级
        window.upgradeSkill = function() {
            // 读取当前等级对应的价格（0级升级到1级，读取level=0的价格）
            const skillCost = skillCostTable.find(s => s.level === skillLevel);
            
            if (!skillCost) {
                showMessage('技能已达到最高等级', 'error');
                return;
            }
            
            if (waveBattleCoins < skillCost.cost) {
                showMessage(`银币不足！需要 ${skillCost.cost} 银币，当前只有 ${waveBattleCoins} 银币`, 'error');
                return;
            }
            
            waveBattleCoins -= skillCost.cost;
            skillLevel = skillLevel + 1;
            
            // 获取当前等级的伤害系数
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const damageCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
            
            updateCoinsDisplay();
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #f093fb; font-weight: bold;">技能升级到 Lv.${skillLevel}！消耗 ${skillCost.cost} 银币，伤害系数 ${damageCoeff.toFixed(2)}</span>`);
        };

        // 怪物攻击（波次战斗）
        function monsterAttackWave(monster) {
            // 怪物生成后前 monsterAttackDelay 秒不攻击
            const delay = typeof monsterAttackDelay === 'number' ? monsterAttackDelay : 0;
            if (delay > 0) {
                const spawnTime = (typeof monster.spawnGameTime === 'number' ? monster.spawnGameTime : waveBattleState.elapsedTime);
                const aliveTime = waveBattleState.elapsedTime - spawnTime;
                if (aliveTime < delay) {
                    return;
                }
            }

            // 优先攻击角色1，按1~5顺序依次攻击
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = waveBattleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // 基础伤害计算
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // 应用伤害系数
            let finalDamage = Math.floor(baseDamage * monster.damageCoeff);
            finalDamage = Math.max(1, finalDamage);

            // 角色1的减伤
            if (target.id === 1 && target.damageReduction > 0) {
                finalDamage = Math.floor(finalDamage * (1 - target.damageReduction / 100));
                finalDamage = Math.max(1, finalDamage);
            }

            target.hp -= finalDamage;
            waveBattleState.totalDamageTaken += finalDamage;

            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-damage-taken">第${monster.wave}波怪物 #${monster.id}</span> 攻击 <span class="log-damage-taken">${target.name}</span>，造成 ${finalDamage} 点伤害`);

            // 显示怪物攻击动画
            const monsterSprite = document.getElementById(`monster-sprite-${monster.id}`);
            if (monsterSprite) {
                monsterSprite.classList.remove('attacking');
                void monsterSprite.offsetWidth; // 触发重排
                monsterSprite.classList.add('attacking');
                setTimeout(() => {
                    monsterSprite.classList.remove('attacking');
                }, 500);
            }

            // 显示角色受击动画和伤害数字
            const charSprite = document.getElementById(`char-sprite-${target.id}`);
            if (charSprite) {
                charSprite.classList.remove('hit');
                void charSprite.offsetWidth;
                charSprite.classList.add('hit');
                setTimeout(() => {
                    charSprite.classList.remove('hit');
                }, 300);
                
                // 显示伤害数字
                showDamageNumber(charSprite, finalDamage, false);
            }

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = waveBattleState.elapsedTime;
                addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #f44336; font-weight: bold;">${target.name} 阵亡！</span>`);
                
                // 角色死亡动画
                if (charSprite) {
                    charSprite.classList.add('dead');
                }
            }
        }

        // 获取角色头像emoji
        function getCharacterEmoji(jobId) {
            const jobEmojis = {
                1: '🛡️', // 坦克
                2: '⚔️', // 战士
                3: '🏹', // 射手
                4: '💚'  // 辅助
            };
            return jobEmojis[jobId] || '👤';
        }

        // 获取怪物头像emoji（根据怪物ID固定）
        function getMonsterEmoji(monsterId) {
            const monsterEmojis = ['👹', '👺', '👽', '🤖', '👾', '🎃', '🦹', '🦴', '🧟', '👻', '💀', '🧛'];
            const index = (monsterId - 1) % monsterEmojis.length;
            return monsterEmojis[index];
        }

        // 更新波次战斗显示
        function updateWaveBattleDisplay() {
            // 更新可视化战斗场景
            updateBattleScene();
            
            // 更新角色面板（使用waveCharactersPanel）
            const panel = document.getElementById('waveCharactersPanel');
            if (panel && waveBattleState.characters && waveBattleState.characters.length > 0) {
                panel.innerHTML = waveBattleState.characters.map(char => {
                    const hpPercent = char.maxHp > 0 ? (char.hp / char.maxHp * 100) : 0;
                    return `
                        <div class="char-panel-item ${char.isAlive ? '' : 'dead'}" data-char-id="${char.id}">
                            <div style="font-weight: 600; margin-bottom: 5px;">${char.name} [${JOB_NAMES[char.job]}]</div>
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">HP: ${char.hp.toFixed(0)} / ${char.maxHp.toFixed(0)} (${hpPercent.toFixed(1)}%)</div>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: ${hpPercent}%; background: ${char.isAlive ? '#51cf66' : '#f44336'};"></div>
                            </div>
                            <div style="font-size: 0.8em; color: #999; margin-top: 5px;">${char.isAlive ? '存活' : '阵亡'}</div>
                        </div>
                    `;
                }).join('');
            }

            // 更新战斗统计（使用waveBattleStats）
            const stats = document.getElementById('waveBattleStats');
            if (stats) {
                const aliveCount = waveBattleState.characters.filter(c => c.isAlive).length;
                const monsterCount = waveBattleState.monsters.filter(m => m.isAlive).length;
                stats.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">战斗时长</div>
                        <div class="stat-value">${formatTime(waveBattleState.elapsedTime)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">存活角色</div>
                        <div class="stat-value">${aliveCount} / 5</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">当前怪物</div>
                        <div class="stat-value">${monsterCount}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">击败怪物</div>
                        <div class="stat-value">${waveBattleState.totalMonstersKilled}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">伤害输出</div>
                        <div class="stat-value">${waveBattleState.totalDamageDealt}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">受到伤害</div>
                        <div class="stat-value">${waveBattleState.totalDamageTaken}</div>
                    </div>
                `;
            }
        }

        // 更新可视化战斗场景
        function updateBattleScene() {
            // 更新波次指示器
            const waveIndicator = document.getElementById('waveIndicator');
            if (waveIndicator) {
                if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                    const stronghold = getStrongholdForWave(waveBattleState.currentWave);
                    waveIndicator.textContent = `据点 ${stronghold} - 第 ${waveBattleState.currentWave} 波`;
                    waveIndicator.style.display = 'block';
                } else {
                    waveIndicator.style.display = 'none';
                }
            }

            // 更新角色侧（使用waveCharactersSide）
            const charactersSide = document.getElementById('waveCharactersSide');
            if (charactersSide && waveBattleState.characters && waveBattleState.characters.length > 0) {
                charactersSide.innerHTML = waveBattleState.characters.map(char => {
                    const hpPercent = char.maxHp > 0 ? (char.hp / char.maxHp * 100) : 0;
                    const jobClass = char.job === 1 ? 'tank' : char.job === 2 ? 'warrior' : char.job === 3 ? 'archer' : 'support';
                    const emoji = getCharacterEmoji(char.job);
                    
                    return `
                        <div class="character-sprite ${char.isAlive ? '' : 'dead'}" 
                             id="char-sprite-${char.id}" 
                             data-char-id="${char.id}"
                             style="opacity: ${char.isAlive ? 1 : 0.5};">
                            <div class="character-avatar ${jobClass}">${emoji}</div>
                            <div class="character-info">
                                <div class="character-name">${char.name} [${JOB_NAMES[char.job]}]</div>
                                <div style="font-size: 0.85em; color: #666;">
                                    HP: ${char.hp.toFixed(0)} / ${char.maxHp.toFixed(0)}
                                </div>
                                <div class="character-hp-bar">
                                    <div class="character-hp-fill ${hpPercent < 30 ? 'low' : ''}" style="width: ${hpPercent}%;"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } else if (charactersSide && (!waveBattleState.characters || waveBattleState.characters.length === 0)) {
                charactersSide.innerHTML = '<div style="color: rgba(255,255,255,0.7); font-size: 1.2em; text-align: center; width: 100%; padding: 20px;">等待角色初始化...</div>';
            }

            // 更新怪物侧（使用waveMonstersSide）
            const monstersSide = document.getElementById('waveMonstersSide');
            if (monstersSide) {
                // 只显示存活的怪物
                const aliveMonsters = waveBattleState.monsters.filter(m => m.isAlive);
                if (aliveMonsters.length === 0) {
                    monstersSide.innerHTML = '<div style="color: rgba(255,255,255,0.7); font-size: 1.2em; text-align: center; width: 100%; padding: 20px;">暂无怪物</div>';
                } else {
                    monstersSide.innerHTML = aliveMonsters.map(monster => {
                        const hpNow = Math.max(0, Number(monster.hp) || 0);
                        const hpMax = Math.max(0, Number(monster.maxHp) || 0);
                        const hpPercent = hpMax > 0 ? Math.max(0, Math.min(100, (hpNow / hpMax * 100))) : 0;
                        const emoji = getMonsterEmoji(monster.id);
                        const spawnTag = (monster.spawnTimeSec !== undefined && monster.spawnTimeSec !== null) ? `${monster.spawnTimeSec}s` : '';
                        
                        // 计算可攻击倒计时
                        const delay = typeof monsterAttackDelay === 'number' ? monsterAttackDelay : 3;
                        let countdownHtml = '';
                        if (delay > 0 && monster.spawnGameTime !== undefined) {
                            const aliveTime = waveBattleState.elapsedTime - monster.spawnGameTime;
                            const remainingTime = Math.max(0, delay - aliveTime);
                            if (remainingTime > 0) {
                                const countdownText = remainingTime >= 1 ? remainingTime.toFixed(0) : remainingTime.toFixed(1);
                                countdownHtml = `<div class="monster-attack-countdown">${countdownText}s</div>`;
                            } else {
                                countdownHtml = `<div class="monster-attack-countdown ready">可攻击</div>`;
                            }
                        }
                        
                        return `
                            <div class="monster-sprite ${monster.isAlive ? '' : 'dead'}" 
                                 id="monster-sprite-${monster.id}" 
                                 data-monster-id="${monster.id}">
                                ${spawnTag ? `<div class="monster-spawn-time-tag">${spawnTag}</div>` : ''}
                                ${countdownHtml}
                                <div class="monster-avatar">${emoji}</div>
                                <div class="monster-hp-bar">
                                    <div class="monster-hp-fill" style="width: ${hpPercent}%;"></div>
                                </div>
                                <div class="monster-hp-text">${hpNow.toFixed(0)} / ${hpMax.toFixed(0)}</div>
                                <div class="monster-id">#${monster.id}</div>
                                <div style="font-size: 0.7em; color: #666; margin-top: 2px;">W${monster.wave}</div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }

        // 更新波次信息显示
        function updateWaveBattleInfo() {
            const currentWaveEl = document.getElementById('currentWaveNumber');
            const spawnedEl = document.getElementById('currentWaveSpawned');
            const totalEl = document.getElementById('currentWaveTotal');
            const aliveEl = document.getElementById('currentWaveAlive');

            if (currentWaveEl) {
                currentWaveEl.textContent = waveBattleState.currentWave > 0 ? waveBattleState.currentWave : '-';
            }
            if (spawnedEl) {
                spawnedEl.textContent = waveBattleState.waveSpawnedCount;
            }
            if (totalEl) {
                totalEl.textContent = waveBattleState.waveTotalCount;
            }
            if (aliveEl) {
                const aliveCount = waveBattleState.monsters.filter(m => m.wave === waveBattleState.currentWave && m.isAlive).length;
                aliveEl.textContent = aliveCount;
            }

            // 更新据点显示
            const currentStrongholdEl = document.getElementById('currentStrongholdNumber');
            if (currentStrongholdEl) {
                currentStrongholdEl.textContent = waveBattleState.currentStronghold > 0 ? waveBattleState.currentStronghold : '-';
            }
            
            const status = document.getElementById('waveBattleStatus');
            if (status && waveBattleState.isRunning) {
                if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                    const stronghold = getStrongholdForWave(waveBattleState.currentWave);
                    status.textContent = `进行中：据点 ${stronghold} - 第 ${waveBattleState.currentWave} 波`;
                } else {
                    status.textContent = '进行中';
                }
            }
        }

        // 格式化时间
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        // 显示消息
        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = `message show ${type}`;
            setTimeout(() => {
                hideMessage();
            }, 3000);
        }

        // 隐藏消息
        function hideMessage() {
            document.getElementById('message').classList.remove('show');
        }

        // 标签页切换功能
        window.switchTab = function(tabName) {
            // 隐藏所有标签页内容
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 移除所有按钮的active状态
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 显示选中的标签页
            const targetTab = document.getElementById(`tab-${tabName}`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            
            // 激活对应的按钮
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach((btn, index) => {
                if ((tabName === 'main' && index === 0) || 
                    (tabName === 'battle' && index === 1) || 
                    (tabName === 'data' && index === 2) || 
                    (tabName === 'import' && index === 3)) {
                    btn.classList.add('active');
                }
            });
            
            // 如果是主配置标签页，需要将主配置内容移到标签页内
            if (tabName === 'main') {
                const mainContent = document.getElementById('main-content');
                const mainTab = document.getElementById('tab-main');
                if (mainContent && mainTab && !mainTab.contains(mainContent)) {
                    mainTab.appendChild(mainContent);
                }
            }
        };

        // 方案管理
        const STORAGE_KEY = 'battleSimulatorSchemes';
        const MAX_SCHEMES = 10;
        let currentSchemeId = null;
        
        // 20波怪物数据方案管理
        const BATTLE_WAVE_STORAGE_KEY = 'battleSimulatorBattleWaveSchemes';
        const MAX_BATTLE_WAVE_SCHEMES = 8;
        let currentBattleWaveSchemeId = null;
        
        // 共享存储配置
        const SHARED_GIST_ID_KEY = 'battleSimulatorSharedGistId';
        let sharedGistId = null;
        
        // 加载共享Gist ID
        function loadSharedGistId() {
            const saved = localStorage.getItem(SHARED_GIST_ID_KEY);
            if (saved) {
                sharedGistId = saved;
                document.getElementById('sharedGistId').value = sharedGistId;
            }
        }
        
        // 保存共享Gist ID
        window.saveSharedGistId = function() {
            const gistId = document.getElementById('sharedGistId').value.trim();
            if (gistId) {
                sharedGistId = gistId;
                localStorage.setItem(SHARED_GIST_ID_KEY, gistId);
                showMessage('Gist ID已保存', 'success');
                updateSharedStorageStatus('已配置共享存储');
            } else {
                sharedGistId = null;
                localStorage.removeItem(SHARED_GIST_ID_KEY);
                showMessage('已清除Gist ID，将仅使用本地存储', 'info');
                updateSharedStorageStatus('未配置共享存储');
            }
        };
        
        // 更新共享存储状态显示
        function updateSharedStorageStatus(message) {
            const statusEl = document.getElementById('sharedStorageStatus');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }
        
        // 从GitHub Gist读取数据
        async function readFromGist(gistId) {
            try {
                const response = await fetch(`https://api.github.com/gists/${gistId}`);
                if (!response.ok) {
                    throw new Error('无法访问Gist，请检查Gist ID是否正确，且Gist为公开状态');
                }
                const gist = await response.json();
                
                // 查找数据文件（通常命名为 data.json）
                const files = Object.keys(gist.files);
                let dataFile = files.find(f => f.includes('data') || f.includes('json'));
                if (!dataFile && files.length > 0) {
                    dataFile = files[0]; // 使用第一个文件
                }
                
                if (!dataFile) {
                    throw new Error('Gist中没有找到数据文件');
                }
                
                const content = gist.files[dataFile].content;
                return JSON.parse(content);
            } catch (error) {
                console.error('读取Gist失败:', error);
                throw error;
            }
        }
        
        // 写入数据到GitHub Gist（需要Personal Access Token）
        async function writeToGist(gistId, data, token) {
            try {
                const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        files: {
                            'battle-simulator-data.json': {
                                content: JSON.stringify(data, null, 2)
                            }
                        }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || '写入Gist失败');
                }
                
                return await response.json();
            } catch (error) {
                console.error('写入Gist失败:', error);
                throw error;
            }
        }
        
        // 从共享存储同步数据
        window.syncFromShared = async function() {
            if (!sharedGistId) {
                showMessage('请先配置Gist ID', 'error');
                return;
            }
            
            updateSharedStorageStatus('正在同步...');
            try {
                const sharedData = await readFromGist(sharedGistId);
                
                // 同步装备表
                if (sharedData.equipmentTable && Array.isArray(sharedData.equipmentTable)) {
                    equipmentTable = sharedData.equipmentTable;
                    localStorage.setItem(EQUIPMENT_STORAGE_KEY, JSON.stringify(equipmentTable));
                    updateEquipmentTableInfo();
                    updateJobEquipmentPanel();
                    console.log('已同步装备表，共', equipmentTable.length, '件');
                }
                
                // 同步英雄表
                if (sharedData.heroTable && Array.isArray(sharedData.heroTable)) {
                    heroTable = sharedData.heroTable;
                    localStorage.setItem(HERO_STORAGE_KEY, JSON.stringify(heroTable));
                    updateHeroTableInfo();
                    updateHeroSelect();
                    console.log('已同步英雄表，共', heroTable.length, '个');
                }
                
                // 同步怪物表
                if (sharedData.monsterTable && Array.isArray(sharedData.monsterTable)) {
                    monsterTable = sharedData.monsterTable;
                    localStorage.setItem(MONSTER_STORAGE_KEY, JSON.stringify(monsterTable));
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects();
                    updateBattleWaveMonsterSelects(); // 更新波次怪物选择下拉框
                    console.log('已同步怪物表，共', monsterTable.length, '个');
                }
                
                // 同步方案
                if (sharedData.schemes && Array.isArray(sharedData.schemes)) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(sharedData.schemes));
                    renderSchemes();
                    console.log('已同步方案，共', sharedData.schemes.length, '个');
                }
                
                showMessage('同步成功！已从共享存储加载所有数据', 'success');
                updateSharedStorageStatus('同步完成');
            } catch (error) {
                showMessage('同步失败：' + error.message, 'error');
                updateSharedStorageStatus('同步失败');
            }
        };
        
        // 上传数据到共享存储
        window.syncToShared = async function() {
            if (!sharedGistId) {
                showMessage('请先配置Gist ID', 'error');
                return;
            }
            
            // 提示需要Personal Access Token
            const token = prompt('请输入GitHub Personal Access Token（需要repo权限）：\n\n创建Token：https://github.com/settings/tokens\n\n如果不想使用Token，可以手动复制数据到Gist');
            
            if (!token) {
                showMessage('已取消上传', 'info');
                return;
            }
            
            updateSharedStorageStatus('正在上传...');
            try {
                // 收集所有数据
                const sharedData = {
                    equipmentTable: equipmentTable,
                    heroTable: heroTable,
                    monsterTable: monsterTable,
                    schemes: loadSchemes(),
                    lastUpdate: new Date().toISOString(),
                    version: VERSION
                };
                
                await writeToGist(sharedGistId, sharedData, token);
                
                showMessage('上传成功！所有数据已保存到共享存储', 'success');
                updateSharedStorageStatus('上传完成');
            } catch (error) {
                showMessage('上传失败：' + error.message, 'error');
                updateSharedStorageStatus('上传失败');
            }
        };

        // 保存方案（全局函数）
        window.saveScheme = function() {
            let name = document.getElementById('schemeNameInput').value.trim();
            
            // 加载现有方案
            const schemes = loadSchemes();
            
            // 如果输入框为空，但有当前选中的方案，使用当前方案的名称
            if (!name && currentSchemeId) {
                const existingScheme = schemes.find(s => s.id === currentSchemeId);
                if (existingScheme) {
                    name = existingScheme.name;
                    // 更新输入框显示
                    document.getElementById('schemeNameInput').value = name;
                }
            }
            
            // 如果还是没有名称，提示用户输入
            if (!name) {
                showMessage('请输入方案名称', 'error');
                return;
            }

            // 检查方案数量
            if (schemes.length >= MAX_SCHEMES && !currentSchemeId) {
                showMessage(`最多只能保存${MAX_SCHEMES}个方案，请先删除一个`, 'error');
                return;
            }

            // 获取当前方案的死亡时间（如果存在）
            let lastDeathTime = null;
            if (currentSchemeId) {
                const existingScheme = schemes.find(s => s.id === currentSchemeId);
                if (existingScheme && existingScheme.lastDeathTime !== undefined) {
                    lastDeathTime = existingScheme.lastDeathTime;
                }
            }

            // 准备方案数据
            // 先从界面读取最新的基础属性值（如果用户手动修改了）
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // 从界面读取最新的平台属性配置
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount').value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum').value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // 从界面读取最新的车辆属性配置
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // 从界面读取最新的关卡配置
            for (let stage = 1; stage <= 20; stage++) {
                const monsterSelect = document.getElementById(`stage-${stage}-monster`);
                const atkSpeedInput = document.getElementById(`stage-${stage}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`stage-${stage}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`stage-${stage}-hpCoeff`);
                
                if (monsterSelect && atkSpeedInput && damageCoeffInput && hpCoeffInput) {
                    stageConfig[stage] = {
                        monsterId: monsterSelect.value || '',
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 0
                    };
                }
            }
            
            const schemeData = {
                id: currentSchemeId || Date.now().toString(),
                name: name,
                saveTime: new Date().toISOString(),
                // 保存角色面板信息
                characters: characters.map(char => ({
                    id: char.id, // 角色ID
                    name: char.name, // 角色名称
                    job: char.job, // 职业
                    // 基础属性（从角色对象中获取，已包含手动修改的值）
                    baseAttack: char.baseAttack || char.attack || 20, // 基础攻击力
                    baseDefense: char.baseDefense || char.defense || 10, // 基础防御力
                    baseHp: char.baseHp || char.hp || 100, // 基础血量
                    // 最终属性（包含装备加成）
                    attack: char.attack || char.baseAttack || 20,
                    defense: char.defense || char.baseDefense || 10,
                    hp: char.hp || char.baseHp || 100,
                    maxHp: char.maxHp || char.baseHp || 100,
                    // 英雄选择信息
                    selectedHeroId: char.selectedHeroId || null, // 选择的英雄ID
                    selectedHeroLevel: char.selectedHeroLevel || null, // 选择的英雄等级
                    // 职业特殊属性系数
                    healRate: char.healRate || 0, // 回血速度（角色5）
                    damageReduction: char.damageReduction || 0, // 减伤百分比（角色1）
                    skillDamage: char.skillDamage || 0 // 技能伤害系数（角色2、3、4）
                })),
                // 保存装备面板信息（职业装备配置）
                characterEquipment: JSON.parse(JSON.stringify(characterEquipment)),
                // 保存平台属性配置
                platformConfig: JSON.parse(JSON.stringify(platformConfig)),
                // 保存平台属性（车辆）配置
                vehicleConfig: JSON.parse(JSON.stringify(vehicleConfig)),
            // 保存关卡配置
            stageConfig: JSON.parse(JSON.stringify(stageConfig)),
            
            // 从界面读取最新的20波怪物数据输入配置
            // 确保保存时读取界面上的最新值
            battleWaveData: (function() {
                const latestBattleWaveData = {};
                for (let wave = 1; wave <= 25; wave++) {
                    const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                    const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                    const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                    const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                    const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                    const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                    const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                    const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                    const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                    const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                    
                    if (monsterSelect && attackInput && defenseInput && hpInput && 
                        atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                        spawnRateInput && durationInput) {
                        latestBattleWaveData[wave] = {
                            monsterId: monsterSelect.value || '',
                            attack: parseFloat(attackInput.value) || 10,
                            defense: parseFloat(defenseInput.value) || 5,
                            hp: parseFloat(hpInput.value) || 50,
                            atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                            damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                            hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                            spawnRate: parseFloat(spawnRateInput.value) || 1,
                            duration: parseFloat(durationInput.value) || 10,
                            coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                        };
                    } else {
                        // 如果界面元素不存在，使用内存中的数据
                        latestBattleWaveData[wave] = battleWaveData[wave] || {
                            monsterId: '',
                            attack: 10,
                            defense: 5,
                            hp: 50,
                            atkSpeed: 0.33,
                            damageCoeff: 1,
                            hpCoeff: 1,
                            spawnRate: 1,
                            duration: 10,
                            coinReward: 0
                        };
                    }
                }
                return latestBattleWaveData;
            })(),
                // 保存怪物属性
                monsterConfig: {
                    spawnRate: parseFloat(document.getElementById('spawnRate').value) || 1, // 刷新速度
                    attack: parseInt(document.getElementById('monsterAttack').value) || 10, // 攻击力
                    defense: parseInt(document.getElementById('monsterDefense').value) || 5, // 防御力
                    hp: parseInt(document.getElementById('monsterHp').value) || 50, // 血量
                    atkSpeed: parseFloat(document.getElementById('monsterAtkSpeed').value) || 1, // 攻击速度
                    damageCoeff: parseFloat(document.getElementById('monsterDamageCoeff').value) || 1, // 攻击系数
                    hpCoeff: parseFloat(document.getElementById('monsterHpCoeff').value) || 0 // 血量系数
                },
                lastDeathTime: lastDeathTime // 保存上次的死亡时间
            };

            // 如果已存在，更新；否则添加
            if (currentSchemeId) {
                const existingIndex = schemes.findIndex(s => s.id === currentSchemeId);
                if (existingIndex >= 0) {
                    schemes[existingIndex] = schemeData;
                } else {
                    // 如果ID存在但列表中找不到，直接添加（可能是数据不同步）
                    schemes.push(schemeData);
                }
            } else {
                schemes.push(schemeData);
            }

            // 保存到localStorage
            localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));

            // 调试：输出保存的方案信息
            console.log('保存方案:', {
                name: schemeData.name,
                characters: schemeData.characters.map(c => ({
                    id: c.id,
                    job: c.job,
                    heroId: c.selectedHeroId,
                    heroLevel: c.selectedHeroLevel,
                    baseAttack: c.baseAttack,
                    baseDefense: c.baseDefense,
                    baseHp: c.baseHp,
                    damageReduction: c.damageReduction,
                    skillDamage: c.skillDamage,
                    healRate: c.healRate
                })),
                equipment: schemeData.characterEquipment,
                platformConfig: schemeData.platformConfig,
                vehicleConfig: schemeData.vehicleConfig,
                monster: schemeData.monsterConfig
            });

            // 更新当前方案ID
            currentSchemeId = schemeData.id;

            // 刷新方案列表
            renderSchemeList();

            // 不清空输入框，保留方案名称，方便用户继续修改并保存
            // 如果用户想创建新方案，可以点击"新建方案"按钮

            showMessage(`方案"${name}"已保存`, 'success');
        };

        // 加载方案列表
        function loadSchemes() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('加载方案失败:', error);
                return [];
            }
        }

        // 加载方案（全局函数）
        window.loadScheme = function(schemeId) {
            const schemes = loadSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            if (!scheme) {
                showMessage('方案不存在', 'error');
                return;
            }

            // 加载角色配置
            scheme.characters.forEach((charData, index) => {
                if (characters[index]) {
                    // 加载职业（如果存在，否则使用默认值）
                    if (charData.job) {
                        characters[index].job = charData.job;
                    } else {
                        // 兼容旧方案，设置默认职业
                        if (index === 0) characters[index].job = JOB_TYPES.TANK;
                        else if (index === 1) characters[index].job = JOB_TYPES.WARRIOR;
                        else if (index === 2 || index === 3) characters[index].job = JOB_TYPES.ARCHER;
                        else if (index === 4) characters[index].job = JOB_TYPES.SUPPORT;
                    }
                    
                    // 加载英雄选择信息（必须在加载基础属性之前）
                    if (charData.selectedHeroId !== undefined) {
                        characters[index].selectedHeroId = charData.selectedHeroId || null;
                    }
                    if (charData.selectedHeroLevel !== undefined) {
                        characters[index].selectedHeroLevel = charData.selectedHeroLevel || null;
                    }
                    
                    // 加载基础属性（兼容旧方案）
                    // 如果有选择的英雄和等级，基础属性会从英雄数据中获取，否则使用保存的值
                    if (!charData.selectedHeroId || !charData.selectedHeroLevel) {
                        characters[index].baseAttack = charData.baseAttack || charData.attack || 20;
                        characters[index].baseDefense = charData.baseDefense || charData.defense || 10;
                        characters[index].baseHp = charData.baseHp || charData.hp || 100;
                    }
                    
                    // 加载职业特殊属性系数
                    characters[index].healRate = charData.healRate !== undefined ? charData.healRate : 0;
                    characters[index].damageReduction = charData.damageReduction !== undefined ? charData.damageReduction : 0;
                    characters[index].skillDamage = charData.skillDamage !== undefined ? charData.skillDamage : 0;
                }
            });
            
            // 加载职业装备配置（装备面板信息）
            if (scheme.characterEquipment) {
                characterEquipment = JSON.parse(JSON.stringify(scheme.characterEquipment));
                saveCharacterEquipment();
            } else {
                // 如果没有装备配置，初始化默认配置
                characterEquipment = {
                    1: { head: null, body: null, hand: null, foot: null },
                    2: { head: null, body: null, hand: null, foot: null },
                    3: { head: null, body: null, hand: null, foot: null },
                    4: { head: null, body: null, hand: null, foot: null }
                };
            }
            
            // 更新职业装备面板
            updateJobEquipmentPanel();
            
            // 刷新界面（必须在应用装备属性之前，以便正确显示英雄选择）
            initCharacters();
            
            // 应用角色属性
            characters.forEach(char => {
                if (char.selectedHeroId && char.selectedHeroLevel) {
                    // 如果有选择的英雄和等级，从英雄数据中获取属性
                    updateCharacterHeroLevel(char.id, char.selectedHeroLevel);
                } else {
                    // 如果没有选择英雄，使用保存的基础属性，然后应用装备属性
                    applyJobEquipmentStats(char);
                }
            });
            
            // 更新最终属性面板
            updateFinalAttributesPanel();

            // 加载怪物配置
            if (scheme.monsterConfig) {
                document.getElementById('spawnRate').value = scheme.monsterConfig.spawnRate || 1;
                document.getElementById('monsterAttack').value = scheme.monsterConfig.attack || 10;
                document.getElementById('monsterDefense').value = scheme.monsterConfig.defense || 5;
                document.getElementById('monsterHp').value = scheme.monsterConfig.hp || 50;
                document.getElementById('monsterAtkSpeed').value = scheme.monsterConfig.atkSpeed || 1;
                document.getElementById('monsterDamageCoeff').value = scheme.monsterConfig.damageCoeff !== undefined ? scheme.monsterConfig.damageCoeff : 1;
                document.getElementById('monsterHpCoeff').value = scheme.monsterConfig.hpCoeff !== undefined ? scheme.monsterConfig.hpCoeff : 0;
            }

            // 加载平台属性配置
            if (scheme.platformConfig) {
                platformConfig.heroCount = scheme.platformConfig.heroCount !== undefined ? scheme.platformConfig.heroCount : 0;
                platformConfig.heroLevelSum = scheme.platformConfig.heroLevelSum !== undefined ? scheme.platformConfig.heroLevelSum : 0;
                platformConfig.attackCoeff = scheme.platformConfig.attackCoeff !== undefined ? scheme.platformConfig.attackCoeff : 0;
                platformConfig.defenseCoeff = scheme.platformConfig.defenseCoeff !== undefined ? scheme.platformConfig.defenseCoeff : 0;
                platformConfig.hpCoeff = scheme.platformConfig.hpCoeff !== undefined ? scheme.platformConfig.hpCoeff : 0;
                
                // 更新界面显示
                document.getElementById('platformHeroCount').value = platformConfig.heroCount;
                document.getElementById('platformHeroLevelSum').value = platformConfig.heroLevelSum;
                document.getElementById('platformAttackCoeff').value = platformConfig.attackCoeff;
                document.getElementById('platformDefenseCoeff').value = platformConfig.defenseCoeff;
                document.getElementById('platformHpCoeff').value = platformConfig.hpCoeff;
                
                // 更新平台属性显示
                updatePlatformAttributes();
            }

            // 加载平台属性（车辆）配置
            if (scheme.vehicleConfig) {
                vehicleConfig.attack = scheme.vehicleConfig.attack !== undefined ? scheme.vehicleConfig.attack : 0;
                vehicleConfig.defense = scheme.vehicleConfig.defense !== undefined ? scheme.vehicleConfig.defense : 0;
                vehicleConfig.hp = scheme.vehicleConfig.hp !== undefined ? scheme.vehicleConfig.hp : 0;
                
                // 更新界面显示
                document.getElementById('vehicleAttack').value = vehicleConfig.attack;
                document.getElementById('vehicleDefense').value = vehicleConfig.defense;
                document.getElementById('vehicleHp').value = vehicleConfig.hp;
                
                // 更新车辆属性显示
                updateVehicleAttributes();
            }

            // 加载关卡配置
            if (scheme.stageConfig) {
                // 合并保存的关卡配置
                for (let stage = 1; stage <= 20; stage++) {
                    if (scheme.stageConfig[stage]) {
                        stageConfig[stage] = {
                            monsterId: scheme.stageConfig[stage].monsterId || '',
                            atkSpeed: scheme.stageConfig[stage].atkSpeed !== undefined ? scheme.stageConfig[stage].atkSpeed : 0.33,
                            damageCoeff: scheme.stageConfig[stage].damageCoeff !== undefined ? scheme.stageConfig[stage].damageCoeff : 1,
                            hpCoeff: scheme.stageConfig[stage].hpCoeff !== undefined ? scheme.stageConfig[stage].hpCoeff : 0
                        };
                    }
                }
                
                // 重新初始化关卡配置界面以应用加载的配置
                initStageConfig();
            }

            // 加载20波怪物数据输入配置（根据方案ID加载）
            if (scheme.battleWaveSchemeId) {
                currentBattleWaveSchemeId = scheme.battleWaveSchemeId;
                // 更新下拉选择框
                updateBattleWaveSchemeSelect();
                // 加载对应的20波方案
                loadBattleWaveSchemeById(scheme.battleWaveSchemeId);
            } else if (scheme.battleWaveData) {
                // 兼容旧方案：如果保存了完整数据，直接加载
                for (let wave = 1; wave <= 25; wave++) {
                    if (scheme.battleWaveData[wave]) {
                        battleWaveData[wave] = {
                            monsterId: scheme.battleWaveData[wave].monsterId || '',
                            attack: scheme.battleWaveData[wave].attack !== undefined ? scheme.battleWaveData[wave].attack : 10,
                            defense: scheme.battleWaveData[wave].defense !== undefined ? scheme.battleWaveData[wave].defense : 5,
                            hp: scheme.battleWaveData[wave].hp !== undefined ? scheme.battleWaveData[wave].hp : 50,
                            atkSpeed: scheme.battleWaveData[wave].atkSpeed !== undefined ? scheme.battleWaveData[wave].atkSpeed : 0.33,
                            damageCoeff: scheme.battleWaveData[wave].damageCoeff !== undefined ? scheme.battleWaveData[wave].damageCoeff : 1,
                            hpCoeff: scheme.battleWaveData[wave].hpCoeff !== undefined ? scheme.battleWaveData[wave].hpCoeff : 1,
                            spawnRate: scheme.battleWaveData[wave].spawnRate !== undefined ? scheme.battleWaveData[wave].spawnRate : 1,
                            duration: scheme.battleWaveData[wave].duration !== undefined ? scheme.battleWaveData[wave].duration : 10,
                            coinReward: scheme.battleWaveData[wave].coinReward !== undefined ? scheme.battleWaveData[wave].coinReward : 0
                        };
                    }
                }
                // 重新初始化25波怪物数据输入界面以应用加载的配置
                initBattleWaveData();
            }

            // 更新当前方案ID
            currentSchemeId = schemeId;
            
            // 更新方案名称输入框，显示当前方案名称
            document.getElementById('schemeNameInput').value = scheme.name;

            // 渲染方案列表
            renderSchemeList();

            // 显示上次的死亡时间
            displayLastDeathTime(scheme);

            showMessage(`已加载方案"${scheme.name}"`, 'success');
            
            // 保存当前使用的方案ID
            localStorage.setItem('battleSimulatorLastScheme', schemeId);
        };

        // 显示上次的死亡时间
        function displayLastDeathTime(scheme) {
            if (scheme.lastDeathTime && scheme.lastDeathTime.time) {
                const deathTime = scheme.lastDeathTime.time;
                const deathDate = scheme.lastDeathTime.date || '';
                showMessage(`上次首个角色死亡时间: ${formatTime(deathTime)}${deathDate ? ` (${deathDate})` : ''}`, 'info');
            }
        }

        // 删除方案（全局函数）
        window.deleteScheme = function(schemeId, event) {
            event.stopPropagation(); // 阻止触发点击事件

            if (!confirm('确定要删除这个方案吗？')) {
                return;
            }

            const schemes = loadSchemes();
            const filtered = schemes.filter(s => s.id !== schemeId);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));

            // 如果删除的是当前方案，清空当前方案ID
            if (currentSchemeId === schemeId) {
                currentSchemeId = null;
                document.getElementById('schemeNameInput').value = '';
            }

            renderSchemeList();
            showMessage('方案已删除', 'success');
        }

        // 新建方案（全局函数）
        window.newScheme = function() {
            currentSchemeId = null;
            document.getElementById('schemeNameInput').value = '';
            resetConfig();
            renderSchemeList();
            showMessage('已创建新方案，请配置后保存', 'info');
        };

        // 清空当前配置（全局函数）
        window.clearCurrentScheme = function() {
            currentSchemeId = null;
            document.getElementById('schemeNameInput').value = '';
            resetConfig();
            renderSchemeList();
        };

        // 渲染方案列表
        function renderSchemeList() {
            const schemes = loadSchemes();
            const listEl = document.getElementById('schemeList');
            const warningEl = document.getElementById('schemeWarning');

            if (schemes.length === 0) {
                listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无保存的方案</div>';
                warningEl.textContent = '';
                return;
            }

            listEl.innerHTML = schemes.map(scheme => {
                const saveDate = new Date(scheme.saveTime);
                const isActive = currentSchemeId === scheme.id;
                return `
                    <div class="scheme-item ${isActive ? 'active' : ''}" onclick="loadScheme('${scheme.id}')">
                        <div class="scheme-item-actions">
                            <button class="scheme-item-btn copy" onclick="copyScheme('${scheme.id}', event)" title="复制方案">📋</button>
                            <button class="scheme-item-btn delete" onclick="deleteScheme('${scheme.id}', event)" title="删除方案">×</button>
                        </div>
                        <div class="scheme-item-name">${scheme.name}</div>
                        <div class="scheme-item-meta">${saveDate.toLocaleString('zh-CN')}</div>
                    </div>
                `;
            }).join('');

            // 显示方案数量警告
            if (schemes.length >= MAX_SCHEMES) {
                warningEl.textContent = `⚠️ 已保存${schemes.length}个方案（最多${MAX_SCHEMES}个）`;
            } else {
                warningEl.textContent = '';
            }
        }

        // 复制方案（全局函数）
        window.copyScheme = function(schemeId, event) {
            event.stopPropagation(); // 阻止触发点击事件

            const schemes = loadSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('方案不存在', 'error');
                return;
            }

            // 检查方案数量
            if (schemes.length >= MAX_SCHEMES) {
                showMessage(`已达到最大方案数（${MAX_SCHEMES}个），请先删除一个方案`, 'error');
                return;
            }

            // 创建新方案（复制数据）
            const newScheme = {
                id: Date.now().toString(),
                name: `${scheme.name} - 副本`,
                saveTime: new Date().toISOString(),
                characters: JSON.parse(JSON.stringify(scheme.characters)), // 深拷贝角色信息（包含英雄ID、等级、属性等）
                characterEquipment: JSON.parse(JSON.stringify(scheme.characterEquipment || {})), // 深拷贝装备配置
                platformConfig: JSON.parse(JSON.stringify(scheme.platformConfig || {})), // 深拷贝平台配置
                vehicleConfig: JSON.parse(JSON.stringify(scheme.vehicleConfig || {})), // 深拷贝车辆配置
                monsterConfig: JSON.parse(JSON.stringify(scheme.monsterConfig || {})), // 深拷贝怪物配置
                lastDeathTime: null // 新方案不复制死亡时间
            };

            // 如果名称已存在，添加数字后缀
            let copyName = newScheme.name;
            let copyIndex = 1;
            while (schemes.some(s => s.name === copyName)) {
                copyName = `${scheme.name} - 副本${copyIndex}`;
                copyIndex++;
            }
            newScheme.name = copyName;

            // 添加到列表
            schemes.push(newScheme);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));

            // 加载新复制的方案
            currentSchemeId = newScheme.id;
            loadScheme(newScheme.id);
            
            // 更新方案名称输入框
            document.getElementById('schemeNameInput').value = copyName;

            renderSchemeList();
            showMessage(`已复制方案"${scheme.name}"为"${copyName}"`, 'success');
        };

        // 保存角色装备配置
        function saveCharacterEquipment() {
            try {
                localStorage.setItem('battleSimulatorCharacterEquipment', JSON.stringify(characterEquipment));
            } catch (error) {
                console.error('保存角色装备配置失败:', error);
            }
        }

        // 加载保存的角色装备配置
        function loadSavedCharacterEquipment() {
            try {
                const saved = localStorage.getItem('battleSimulatorCharacterEquipment');
                if (saved) {
                    characterEquipment = JSON.parse(saved);
                    console.log('从本地加载角色装备配置');
                } else {
                    // 初始化默认配置
                    characterEquipment = {
                        1: { head: null, body: null, hand: null, foot: null },
                        2: { head: null, body: null, hand: null, foot: null },
                        3: { head: null, body: null, hand: null, foot: null },
                        4: { head: null, body: null, hand: null, foot: null }
                    };
                }
            } catch (error) {
                console.error('加载角色装备配置失败:', error);
                // 初始化默认配置
                characterEquipment = {
                    1: { head: null, body: null, hand: null, foot: null },
                    2: { head: null, body: null, hand: null, foot: null },
                    3: { head: null, body: null, hand: null, foot: null },
                    4: { head: null, body: null, hand: null, foot: null }
                };
            }
        }

        // 加载保存的英雄表
        // 加载保存的怪物表
        function loadSavedMonsterTable() {
            try {
                const saved = localStorage.getItem(MONSTER_STORAGE_KEY);
                if (saved) {
                    monsterTable = JSON.parse(saved);
                    console.log('从本地加载怪物表，共', monsterTable.length, '个怪物');
                    
                    // 更新界面
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects(); // 更新关卡怪物选择下拉框
                    updateBattleWaveMonsterSelects(); // 更新波次怪物选择下拉框
                }
            } catch (error) {
                console.error('加载保存的怪物表失败:', error);
            }
        }

        function loadSavedHeroTable() {
            try {
                const saved = localStorage.getItem(HERO_STORAGE_KEY);
                if (saved) {
                    heroTable = JSON.parse(saved);
                    console.log('从本地加载英雄表，共', heroTable.length, '个英雄');
                    
                    // 确保类型正确（兼容旧数据和文本格式）
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // 如果是数字，直接转换
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // 如果是文本，转换为数字
                        const textValue = String(heroclassValue).trim();
                        if (textValue === '坦克' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === '战士' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === '射手' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === '辅助' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // 重新处理英雄数据，确保职业正确
                    heroTable = heroTable.map(hero => {
                        let heroclass = parseHeroClass(hero.heroclass);
                        
                        // 如果职业为0，尝试从英雄名称推断
                        if (heroclass === 0 && hero.namecn) {
                            const nameStr = String(hero.namecn).trim();
                            if (nameStr.includes('坦克')) heroclass = 1;
                            else if (nameStr.includes('战士')) heroclass = 2;
                            else if (nameStr.includes('射手')) heroclass = 3;
                            else if (nameStr.includes('辅助')) heroclass = 4;
                        }
                        
                        // 确保levels属性存在（兼容旧数据）
                        if (!hero.levels) {
                            hero.levels = {};
                        }
                        
                        // 确保基础属性存在（如果没有levels数据，使用保存的基础属性）
                        if (!hero.baseAttack && hero.levels[1]) {
                            hero.baseAttack = hero.levels[1].baseAttack || 0;
                        }
                        if (!hero.baseDefense && hero.levels[1]) {
                            hero.baseDefense = hero.levels[1].baseDefense || 0;
                        }
                        if (!hero.baseHp && hero.levels[1]) {
                            hero.baseHp = hero.levels[1].baseHp || 0;
                        }
                        
                        return {
                            ...hero,
                            heroclass: heroclass
                        };
                    });
                    
                    updateHeroTableInfo();
                } else {
                    console.log('本地没有保存的英雄表');
                }
            } catch (error) {
                console.error('加载英雄表失败:', error);
            }
        }

        // 加载保存的装备表
        function loadSavedEquipmentTable() {
            try {
                const saved = localStorage.getItem(EQUIPMENT_STORAGE_KEY);
                if (saved) {
                    equipmentTable = JSON.parse(saved);
                    console.log('从本地加载装备表，共', equipmentTable.length, '件装备');
                    
                    // 调试：显示原始数据格式
                    if (equipmentTable.length > 0) {
                        console.log('加载装备表时的原始数据示例（前3件）:', equipmentTable.slice(0, 3).map(eq => ({
                            id: eq.id,
                            namecn: eq.namecn,
                            heroclass: eq.heroclass,
                            heroclassType: typeof eq.heroclass,
                            type: eq.type,
                            typeType: typeof eq.type
                        })));
                        
                        // 统计所有唯一的heroclass和type值
                        const uniqueHeroclass = [...new Set(equipmentTable.map(eq => eq.heroclass))].slice(0, 20);
                        const uniqueType = [...new Set(equipmentTable.map(eq => String(eq.type || '').trim()))].slice(0, 20);
                        console.log('装备表中唯一的heroclass值（前20个）:', uniqueHeroclass);
                        console.log('装备表中唯一的type值（前20个）:', uniqueType);
                    }
                    
                    // 确保类型正确（兼容旧数据和文本格式）
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // 如果是数字，直接转换
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // 如果是文本，转换为数字
                        const textValue = String(heroclassValue).trim();
                        if (textValue === '坦克' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === '战士' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === '射手' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === '辅助' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // 重新处理装备数据，确保职业正确
                    equipmentTable = equipmentTable.map(eq => {
                        let heroclass = parseHeroClass(eq.heroclass);
                        
                        // 如果职业为0，尝试从装备名称推断（如"坦克头"、"战士手"等）
                        if (heroclass === 0 && eq.namecn) {
                            const nameStr = String(eq.namecn).trim();
                            if (nameStr.includes('坦克')) heroclass = 1;
                            else if (nameStr.includes('战士')) heroclass = 2;
                            else if (nameStr.includes('射手')) heroclass = 3;
                            else if (nameStr.includes('辅助')) heroclass = 4;
                        }
                        
                        // 如果职业仍为0，尝试从装备ID推断（如ID中包含职业信息）
                        if (heroclass === 0 && eq.id) {
                            const idStr = String(eq.id).trim();
                            // 假设ID格式如：13111001，其中第3位可能是职业（1=坦克，2=战士，3=射手，4=辅助）
                            if (idStr.length >= 3) {
                                const thirdChar = parseInt(idStr[2]);
                                if (thirdChar >= 1 && thirdChar <= 4) {
                                    heroclass = thirdChar;
                                }
                            }
                        }
                        
                        return {
                            ...eq,
                            heroclass: heroclass,
                            type: String(eq.type || '').trim()
                        };
                    });
                    
                    // 调试：显示转换后的数据格式
                    if (equipmentTable.length > 0) {
                        console.log('转换后的装备数据示例（前3件）:', equipmentTable.slice(0, 3).map(eq => ({
                            id: eq.id,
                            namecn: eq.namecn,
                            heroclass: eq.heroclass,
                            heroclassType: typeof eq.heroclass,
                            type: eq.type,
                            typeType: typeof eq.type
                        })));
                        
                        // 统计各职业和部位的装备数量
                        const stats = {};
                        equipmentTable.forEach(eq => {
                            const job = eq.heroclass || 0;
                            const type = eq.type || '';
                            const key = `job${job}_${type}`;
                            stats[key] = (stats[key] || 0) + 1;
                        });
                        console.log('装备统计（职业_部位: 数量）:', stats);
                    }
                    updateJobEquipmentPanel();
                    updateEquipmentTableInfo();
                } else {
                    console.log('本地没有保存的装备表');
                }
            } catch (error) {
                console.error('加载装备表失败:', error);
            }
        }

        // 初始化函数
        function initializeApp() {
            // 确保DOM已加载
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeApp);
                return;
            }

            // 加载共享Gist ID配置
            loadSharedGistId();
            
            // 初始化标签页：将主配置内容移到主配置标签页
            const mainContent = document.getElementById('main-content');
            const mainTab = document.getElementById('tab-main');
            if (mainContent && mainTab) {
                mainTab.appendChild(mainContent);
            }
            
            // 初始化角色界面
            initCharacters();
            
            // 加载保存的数据（先从本地加载，然后尝试从共享存储同步）
            loadSavedCharacterEquipment();
            loadSavedEquipmentTable();
            loadSavedHeroTable();
            loadSavedMonsterTable();
            loadSavedUpgradeTable();
            
            // 如果配置了共享存储，自动尝试同步（静默，不显示错误）
            if (sharedGistId) {
                updateSharedStorageStatus('已配置，点击同步按钮加载共享数据');
                // 可选：自动同步（取消注释下面的代码）
                // syncFromShared().catch(() => {
                //     // 静默失败，使用本地数据
                //     console.log('自动同步失败，使用本地数据');
                // });
            } else {
                updateSharedStorageStatus('未配置共享存储');
            }
            
            // 初始化时应用装备属性
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // 初始化职业装备面板
            updateJobEquipmentPanel();
            
            // 初始化最终属性面板
            updateFinalAttributesPanel();
            
            // 初始化关卡配置界面
            initStageConfig();
            
            // 初始化20波怪物数据输入界面
            initBattleWaveData();
            
            // 初始化20波怪物数据方案下拉选择框
            updateBattleWaveSchemeSelect();
            
            // 初始化平台属性配置显示
            updatePlatformAttributes();
            
            // 初始化车辆属性配置显示
            updateVehicleAttributes();
            
            // 渲染方案列表
            renderSchemeList();

            // 尝试加载上次使用的方案
            const lastSchemeId = localStorage.getItem('battleSimulatorLastScheme');
            if (lastSchemeId) {
                const schemes = loadSchemes();
                const scheme = schemes.find(s => s.id === lastSchemeId);
                if (scheme) {
                    loadScheme(lastSchemeId);
                }
            }
        }

        // 执行初始化
        initializeApp();

    </script>
</body>
</html>




