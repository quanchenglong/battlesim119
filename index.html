<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ˜æ–—æ¨¡æ‹Ÿå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        h1 {
            color: #333;
            font-size: 2em;
        }

        .version {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
        }

        .config-section {
            margin-bottom: 30px;
        }

        .section-title {
            color: #667eea;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .character-card {
            background: #f8f9ff;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .character-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .character-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .status-alive {
            background: #d4edda;
            color: #155724;
        }

        .status-dead {
            background: #f8d7da;
            color: #721c24;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .monster-config {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
        }

        .monster-config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .battle-area {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
            display: none;
        }

        .battle-area.show {
            display: block;
        }

        /* æ³¢æ¬¡æˆ˜æ–—åŒºåŸŸï¼ˆåœ¨tab-battleé¡µç­¾å†…ï¼‰ */
        #waveBattleArea {
            display: none;
        }

        #waveBattleArea[style*="block"] {
            display: block !important;
        }

        /* å¯è§†åŒ–æˆ˜æ–—åœºæ™¯ */
        .battle-scene {
            width: 100%;
            min-height: 400px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        /* ä¸»é…ç½®é¡µç­¾çš„æˆ˜æ–—åœºæ™¯ä¸æ˜¾ç¤ºèƒŒæ™¯ */
        #battleArea #battleScene {
            background: transparent !important;
            min-height: 0 !important;
            padding: 0 !important;
            margin-bottom: 0 !important;
            display: none !important;
        }

        .battle-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 350px;
            position: relative;
        }

        /* è§’è‰²åŒºåŸŸ */
        .characters-side {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            max-width: 400px;
        }

        .character-sprite {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 2px solid #fff;
            transition: all 0.3s ease;
            position: relative;
        }

        .character-sprite.dead {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
            position: relative;
            flex-shrink: 0;
        }

        .character-avatar.tank { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .character-avatar.warrior { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .character-avatar.archer { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .character-avatar.support { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }

        .character-info {
            flex: 1;
            min-width: 0;
        }

        .character-name {
            font-weight: 600;
            font-size: 1em;
            margin-bottom: 5px;
        }

        .character-hp-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .character-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #40c057 100%);
            transition: width 0.3s ease;
        }

        .character-hp-fill.low {
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
        }

        /* æ€ªç‰©åŒºåŸŸ */
        .monsters-side {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex: 1;
            justify-content: flex-end;
            align-items: flex-start;
            max-width: 500px;
        }

        .monster-sprite {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 2px solid #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .monster-sprite.dead {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(100%);
        }

        .monster-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .monster-hp-bar {
            width: 70px;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
        }

        .monster-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
            transition: width 0.3s ease;
        }

        .monster-hp-text {
            font-size: 0.65em;
            color: #666;
            margin-top: 2px;
            line-height: 1;
            white-space: nowrap;
        }

        .monster-id {
            font-size: 0.7em;
            color: #666;
            margin-top: 2px;
        }

        /* æ”»å‡»åŠ¨ç”» */
        @keyframes attackAnimation {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(30px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes monsterAttackAnimation {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(-30px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes hitAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1); }
        }

        @keyframes damageFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .character-sprite.attacking {
            animation: attackAnimation 0.5s ease;
        }

        .monster-sprite.attacking {
            animation: monsterAttackAnimation 0.5s ease;
        }
        
        /* åŒä¸€ç§’åˆ·æ–°çš„æ—¶é—´æ ‡è®° */
        .monster-spawn-time-tag {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.65em;
            font-weight: 700;
            line-height: 1;
            padding: 2px 5px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.65);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.25);
            text-shadow: 0 1px 1px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 2;
        }
        
        /* å¯æ”»å‡»å€’è®¡æ—¶æ ‡è®°ï¼ˆå³ä¸Šè§’ï¼‰ */
        .monster-attack-countdown {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7em;
            font-weight: 700;
            line-height: 1;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 87, 34, 0.85);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 3;
            min-width: 35px;
            text-align: center;
        }
        
        .monster-attack-countdown.ready {
            background: rgba(76, 175, 80, 0.85);
        }

        .character-sprite.hit {
            animation: hitAnimation 0.3s ease;
        }

        .monster-sprite.hit {
            animation: hitAnimation 0.3s ease;
        }

        .damage-number {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .heal-number {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #51cf66;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* æ³¢æ¬¡æ ‡è¯† */
        .wave-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            color: #667eea;
            font-size: 1.1em;
            z-index: 100;
        }

        /* é“¶å¸å’Œå‡çº§UI */
        .battle-ui-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        
        /* æ³¢æ¬¡æˆ˜æ–—çš„UIé¢æ¿ä½¿ç”¨æ­£å¸¸å¸ƒå±€ */
        #waveBattleUIPanel {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .coins-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #f59f00;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: linear-gradient(135deg, #ffd43b 0%, #f59f00 100%);
            border-radius: 8px;
            color: white;
        }
        
        /* æ³¢æ¬¡æˆ˜æ–—çš„UIé¢æ¿ï¼ˆåœ¨æˆ˜æ–—åœºæ™¯ä¸­ï¼Œæ³¢æ¬¡æŒ‡ç¤ºå™¨ä¸‹æ–¹ï¼‰ */
        #waveBattleUIPanel {
            position: relative !important;
            top: auto !important;
            right: auto !important;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px auto 0 auto;
            max-width: 400px;
            width: 100%;
        }

        .upgrade-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .upgrade-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            color: #ffffff !important;
        }

        .upgrade-btn.weapon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff !important;
        }

        .upgrade-btn.skill {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #ffffff !important;
        }

        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .upgrade-info {
            font-size: 0.95em;
            color: #ffffff;
            margin-top: 8px;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .battle-log {
            max-height: 400px;
            overflow-y: auto;
            background: #2d2d2d;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 15px;
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        .log-time {
            color: #888;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #51cf66;
        }

        .log-death {
            color: #ff8787;
            font-weight: bold;
        }

        .battle-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.8em;
            font-weight: bold;
        }

        .message {
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
            text-align: center;
            font-weight: 500;
        }

        .message.show {
            display: block;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .hp-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #ffd43b 50%, #ff6b6b 100%);
            transition: width 0.3s ease;
        }

        .monster-spawn-rate {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .monster-spawn-rate label {
            font-weight: 600;
            color: #333;
        }

        .characters-panel {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
        }

        .characters-panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .char-panel-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            position: relative;
            overflow: visible;
        }

        .char-panel-item.alive {
            border-color: #51cf66;
        }

        .char-panel-item.dead {
            border-color: #ff8787;
            opacity: 0.6;
        }

        .char-panel-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .char-panel-hp {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .char-panel-hp-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .char-panel-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #51cf66 0%, #ffd43b 50%, #ff6b6b 100%);
            transition: width 0.3s ease;
        }

        .damage-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-weight: bold;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }

        .heal-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #51cf66;
            font-weight: bold;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -100px);
            }
        }

        .scheme-manager {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
        }

        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tab-container {
            margin-bottom: 30px;
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0;
        }

        .tab-button {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            top: 2px;
        }

        .tab-button:hover {
            color: #667eea;
            background: #f8f9ff;
        }

        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .scheme-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }

        .scheme-input {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .scheme-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .scheme-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .scheme-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .scheme-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .scheme-item.active {
            border-color: #667eea;
            background: #e8ebff;
        }

        .scheme-item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .scheme-item-meta {
            font-size: 0.8em;
            color: #666;
        }

        .scheme-item-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7em;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .scheme-item:hover .scheme-item-delete {
            opacity: 1;
        }

        .scheme-item-delete:hover {
            background: #c82333;
        }

        .scheme-warning {
            color: #ffc107;
            font-size: 0.85em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš”ï¸ æˆ˜æ–—æ¨¡æ‹Ÿå™¨</h1>
            <div class="version">v<span id="version">-</span></div>
        </div>

        <!-- æ ‡ç­¾é¡µå®¹å™¨ -->
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('main')">âš™ï¸ ä¸»é…ç½®</button>
                <button class="tab-button" onclick="switchTab('battle')">âš”ï¸ å±€å†…æˆ˜æ–—æ¨¡æ‹Ÿ</button>
                <button class="tab-button" onclick="switchTab('data')">ğŸ“Š æ•°æ®è¡¨å¯¼å…¥</button>
                <button class="tab-button" onclick="switchTab('import')">ğŸ’¾ æ–¹æ¡ˆå¯¼å…¥</button>
                <button class="tab-button" onclick="switchTab('economy')">ğŸ’° ç©å®¶ç»æµæ¨¡æ‹Ÿ</button>
            </div>

            <!-- ä¸»é…ç½®æ ‡ç­¾é¡µ -->
            <div id="tab-main" class="tab-content active">
                <!-- ä¸»é…ç½®å†…å®¹å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
            </div>

            <!-- å±€å†…æˆ˜æ–—æ¨¡æ‹Ÿæ ‡ç­¾é¡µ -->
            <div id="tab-battle" class="tab-content">
                <div class="config-section">
                    <div class="section-title">ğŸ“Š è§’è‰²æœ€ç»ˆå±æ€§ï¼ˆç”¨äºæˆ˜æ–—è®¡ç®—ï¼‰</div>
                    <div id="battleFinalAttributesPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px;"></div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ† 25æ³¢æ€ªç‰©æ•°æ®è¾“å…¥</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                            é…ç½®25æ³¢æ€ªç‰©æ•°æ®ï¼Œå¯é€‰æ‹©æ€ªç‰©IDè‡ªåŠ¨å¡«å……æ”»é˜²è¡€ï¼Œæˆ–æ‰‹åŠ¨è¾“å…¥ã€‚æ¯5æ³¢ä¸ºä¸€ä¸ªæ®ç‚¹ï¼Œå…±5ä¸ªæ®ç‚¹ã€‚
                        </div>
                        
                        <!-- æ®ç‚¹å¥–åŠ±é…ç½® -->
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">ğŸ’° æ®ç‚¹å¥–åŠ±é…ç½®ï¼ˆæ¯ä¸ªæ®ç‚¹é€šè¿‡åè·å¾—é“¶å¸å¥–åŠ±ï¼‰</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">æ®ç‚¹1 (1-5æ³¢):</label>
                                    <input type="number" id="stronghold1Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(1, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">é“¶å¸</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">æ®ç‚¹2 (6-10æ³¢):</label>
                                    <input type="number" id="stronghold2Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(2, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">é“¶å¸</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">æ®ç‚¹3 (11-15æ³¢):</label>
                                    <input type="number" id="stronghold3Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(3, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">é“¶å¸</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">æ®ç‚¹4 (16-20æ³¢):</label>
                                    <input type="number" id="stronghold4Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(4, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">é“¶å¸</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: 500; min-width: 80px;">æ®ç‚¹5 (21-25æ³¢):</label>
                                    <input type="number" id="stronghold5Reward" min="0" step="1" value="0" onchange="updateStrongholdReward(5, this.value)" style="padding: 6px 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <span style="color: #666; font-size: 0.85em;">é“¶å¸</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆç®¡ç† -->
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">ğŸ’¾ 25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆç®¡ç†ï¼ˆæœ€å¤š8ä¸ªï¼‰</div>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px;">
                                <input type="text" id="battleWaveSchemeNameInput" placeholder="æ–¹æ¡ˆåç§°" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 150px;" />
                                <button class="btn btn-primary" onclick="saveBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em;">ä¿å­˜æ–¹æ¡ˆ</button>
                                <select id="battleWaveSchemeSelect" onchange="loadBattleWaveScheme(this.value)" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 150px;">
                                    <option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>
                                </select>
                                <button class="btn btn-secondary" onclick="copyBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white;">å¤åˆ¶æ–¹æ¡ˆ</button>
                                <button class="btn btn-danger" onclick="deleteBattleWaveScheme()" style="padding: 8px 16px; font-size: 0.9em; background: #ff6b6b;">åˆ é™¤æ–¹æ¡ˆ</button>
                            </div>
                            <div id="battleWaveSchemeStatus" style="font-size: 0.85em; color: #666;"></div>
                        </div>
                        
                        <div id="battleWaveDataGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 15px;"></div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">âš”ï¸ å¯è§†åŒ–æˆ˜æ–—æ¨¡æ‹Ÿ</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                            æŒ‰ç…§é…ç½®çš„25æ³¢æ€ªç‰©æ•°æ®ï¼Œé€æ³¢å‡ºæ€ªå¹¶è¿›è¡Œå¯è§†åŒ–æˆ˜æ–—æ¨¡æ‹Ÿã€‚æ¯ä¸ªæ®ç‚¹æ‰€æœ‰æ€ªç‰©æ­»äº¡åæ‰èƒ½å¼€å§‹ä¸‹ä¸€ä¸ªæ®ç‚¹ã€‚
                        </div>
                        <div style="margin-bottom: 10px; font-size: 0.85em; color: #555; display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                            <span>æ€ªç‰©ç”Ÿæˆåå‰</span>
                            <input type="number" id="monsterAttackDelayInput" min="0" max="60" step="0.5" value="3" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>ç§’ä¸æ”»å‡»ï¼›æ€ªç‰©ç”Ÿæˆåå‰</span>
                            <input type="number" id="monsterInvincibleTimeInput" min="0" max="60" step="0.1" value="1" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>ç§’ä¸å¯è¢«æ”»å‡»ï¼›è§’è‰²æ”»å‡»é¢‘ç‡</span>
                            <input type="number" id="characterAttackIntervalInput" min="0.01" max="5" step="0.01" value="0.1" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>ç§’/æ¬¡ï¼Œä¼¤å®³ç³»æ•°</span>
                            <input type="number" id="characterDamageScaleInput" min="0.01" max="10" step="0.01" value="0.1" style="width: 70px; padding: 4px 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; text-align: center;" />
                            <span>å€ï¼ˆå‡å¯é…ç½®ï¼‰</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button class="btn btn-primary" id="startWaveBattleBtn" onclick="startWaveBattle()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; background: #667eea;">
                                ğŸ® å¼€å§‹å¯è§†åŒ–æ¨¡æ‹Ÿ
                            </button>
                            <button class="btn btn-secondary" id="stopWaveBattleBtn" onclick="stopWaveBattle()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; display: none;">
                                â¹ï¸ åœæ­¢æ¨¡æ‹Ÿ
                            </button>
                            <div id="waveBattleStatus" style="font-size: 0.9em; color: #666; margin-left: 10px;"></div>
                        </div>
                        <div id="waveBattleInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666; display: none;">
                            <div>å½“å‰æ®ç‚¹: <span id="currentStrongholdNumber">-</span> / 5</div>
                            <div>å½“å‰æ³¢æ¬¡: <span id="currentWaveNumber">-</span> / 25</div>
                            <div>å·²å‡ºæ€ªç‰©æ•°: <span id="currentWaveSpawned">-</span> / <span id="currentWaveTotal">-</span></div>
                            <div>å­˜æ´»æ€ªç‰©æ•°: <span id="currentWaveAlive">-</span></div>
                        </div>
                    </div>
                </div>

                <!-- å¯è§†åŒ–æˆ˜æ–—åœºæ™¯å’Œç›¸å…³ä¿¡æ¯ï¼ˆåœ¨tab-battleé¡µç­¾å†…ï¼‰ -->
                <div class="battle-area" id="waveBattleArea" style="display: none;">
                    <div class="section-title">âš”ï¸ æˆ˜æ–—è¿›è¡Œä¸­</div>
                    <div class="battle-stats" id="waveBattleStats"></div>
                    
                    <!-- å¯è§†åŒ–æˆ˜æ–—åœºæ™¯ -->
                    <div class="battle-scene" id="waveBattleScene">
                        <div class="wave-indicator" id="waveIndicator" style="display: none;">ç¬¬ 0 æ³¢</div>
                        
                        <!-- é“¶å¸å’Œå‡çº§æŒ‰é’®ï¼ˆåœ¨æ³¢æ¬¡æŒ‡ç¤ºå™¨ä¸‹æ–¹ï¼‰ -->
                        <div class="battle-ui-panel" id="waveBattleUIPanel" style="margin-top: 15px; display: none;">
                            <div class="coins-display">
                                ğŸ’° <span id="waveCoinsDisplay">0</span>
                            </div>
                            <div class="upgrade-buttons">
                                <button class="upgrade-btn weapon" id="waveUpgradeWeaponBtn" onclick="upgradeWeapon()">
                                    âš”ï¸ æ­¦å™¨å‡çº§
                                    <div class="upgrade-info" id="waveWeaponUpgradeInfo">Lv.0</div>
                                </button>
                                <button class="upgrade-btn skill" id="waveUpgradeSkillBtn" onclick="upgradeSkill()">
                                    âœ¨ æŠ€èƒ½å‡çº§
                                    <div class="upgrade-info" id="waveSkillUpgradeInfo">Lv.0</div>
                                </button>
                            </div>
                        </div>
                        <div class="battle-field">
                            <div class="characters-side" id="waveCharactersSide"></div>
                            <div class="monsters-side" id="waveMonstersSide"></div>
                        </div>
                    </div>
                    
                    <div class="characters-panel">
                        <div class="section-title" style="margin-bottom: 15px;">ğŸ‘¥ è§’è‰²çŠ¶æ€</div>
                        <div class="characters-panel-grid" id="waveCharactersPanel"></div>
                    </div>
                    <div class="battle-log" id="waveBattleLog"></div>
                </div>
            </div>

            <!-- æ–¹æ¡ˆå¯¼å…¥æ ‡ç­¾é¡µ -->
            <div id="tab-import" class="tab-content">
                <div class="scheme-manager">
                    <div class="section-title">â˜ï¸ å…±äº«å­˜å‚¨é…ç½®ï¼ˆæ‰€æœ‰äººå…±äº«æ•°æ®ï¼‰</div>
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin-bottom: 10px;">
                            <input type="text" id="sharedGistId" placeholder="è¾“å…¥GitHub Gist IDï¼ˆç•™ç©ºåˆ™ä»…æœ¬åœ°å­˜å‚¨ï¼‰" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            <button class="btn btn-primary" onclick="saveSharedGistId()" style="padding: 8px 16px; font-size: 0.9em;">ä¿å­˜Gist ID</button>
                        </div>
                        <div style="font-size: 0.85em; color: #856404; margin-bottom: 8px;">
                            <div>ğŸ“ ä½¿ç”¨è¯´æ˜ï¼š</div>
                            <div style="margin-left: 15px; margin-top: 5px;">
                                1. åˆ›å»ºGitHub Gistï¼šè®¿é—® <a href="https://gist.github.com" target="_blank" style="color: #667eea;">gist.github.com</a>ï¼Œåˆ›å»ºå…¬å¼€Gist<br/>
                                2. å¤åˆ¶Gist IDï¼ˆURLä¸­çš„32ä½å­—ç¬¦ï¼Œå¦‚ï¼šabc123def456...ï¼‰<br/>
                                3. ç²˜è´´åˆ°ä¸Šæ–¹è¾“å…¥æ¡†å¹¶ä¿å­˜<br/>
                                4. æ‰€æœ‰äººä½¿ç”¨åŒä¸€ä¸ªGist IDå³å¯å…±äº«æ•°æ®
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="btn btn-success" onclick="syncFromShared()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66;">ğŸ”„ ä»å…±äº«å­˜å‚¨åŒæ­¥</button>
                            <button class="btn btn-info" onclick="syncToShared()" style="padding: 8px 16px; font-size: 0.9em; background: #17a2b8;">ğŸ“¤ ä¸Šä¼ åˆ°å…±äº«å­˜å‚¨</button>
                            <span id="sharedStorageStatus" style="color: #666; font-size: 0.85em; line-height: 32px; margin-left: 10px;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ•°æ®è¡¨å¯¼å…¥æ ‡ç­¾é¡µ -->
            <div id="tab-data" class="tab-content">
                <div class="scheme-manager">
                    <div class="section-title">ğŸ“¦ è£…å¤‡è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="equipmentFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadEquipmentTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('equipmentFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ è£…å¤‡è¡¨</button>
                            <span id="equipmentTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½è£…å¤‡è¡¨</span>
                        </div>
                        <div id="equipmentTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">ğŸ¦¸ è‹±é›„è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="heroFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadHeroTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('heroFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ è‹±é›„è¡¨</button>
                            <span id="heroTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½è‹±é›„è¡¨</span>
                        </div>
                        <div id="heroTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">ğŸ‘¹ æ€ªç‰©è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="monsterFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadMonsterTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('monsterFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ æ€ªç‰©è¡¨</button>
                            <span id="monsterTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½æ€ªç‰©è¡¨</span>
                        </div>
                        <div id="monsterTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">ğŸ° æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="recruitInfoFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadRecruitInfoTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('recruitInfoFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨</button>
                            <span id="recruitInfoTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨</span>
                        </div>
                        <div id="recruitInfoTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">ğŸ“Š ç©å®¶è´¦å·ç­‰çº§è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="accountLevelTableFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadAccountLevelTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('accountLevelTableFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ ç©å®¶è´¦å·ç­‰çº§è¡¨</button>
                            <span id="accountLevelTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨</span>
                        </div>
                        <div id="accountLevelTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">ğŸ“¦ ç‰©å“æ€»è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="itemTableFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadItemTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('itemTableFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ ç‰©å“æ€»è¡¨</button>
                            <span id="itemTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½ç‰©å“æ€»è¡¨</span>
                        </div>
                        <div id="itemTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="scheme-manager">
                    <div class="section-title">âš”ï¸ å±€å†…æ­¦å™¨æŠ€èƒ½å‡çº§è¡¨ç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="upgradeFileInput" accept=".xlsx,.xls" style="display: none;" onchange="loadUpgradeTable(event)" />
                            <button class="btn btn-primary" onclick="document.getElementById('upgradeFileInput').click()" style="padding: 8px 20px;">ä¸Šä¼ å‡çº§è¡¨</button>
                            <span id="upgradeTableStatus" style="color: #666; font-size: 0.9em;">æœªåŠ è½½å‡çº§è¡¨</span>
                        </div>
                        
                        <!-- æ­¦å™¨å‡çº§ç³»æ•°æŸ¥çœ‹æ¨¡å— -->
                        <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #333;">ğŸ” æ­¦å™¨å‡çº§ç³»æ•°æŸ¥çœ‹</div>
                            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                                <label style="font-size: 0.9em; color: #666;">é€‰æ‹©æ­¦å™¨å‡çº§æ¬¡æ•°ï¼š</label>
                                <select id="weaponLevelViewer" onchange="updateWeaponCoeffViewer()" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 120px;">
                                    <option value="-1">è¯·é€‰æ‹©</option>
                                </select>
                            </div>
                            <div id="weaponCoeffInfo" style="display: none; padding: 12px; background: #f8f9ff; border-radius: 6px; font-size: 0.9em;">
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">å½“å‰ç­‰çº§ï¼š</span>
                                    <span id="currentWeaponLevelView" style="font-weight: 600; color: #667eea;"></span>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">å½“å‰ä¼¤å®³ç³»æ•°ï¼š</span>
                                    <span id="currentWeaponCoeffView" style="font-weight: 600; color: #51cf66;"></span>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <span style="color: #666;">å‡çº§æ¶ˆè€—ï¼š</span>
                                    <span id="weaponUpgradeCostView" style="font-weight: 600; color: #f59f00;"></span>
                                </div>
                                <div>
                                    <span style="color: #666;">ä¸‹ä¸€çº§æå‡å€¼ï¼š</span>
                                    <span id="weaponUpgradeRatioView" style="font-weight: 600; color: #f5576c;"></span>
                                </div>
                            </div>
                        </div>
                        <div id="upgradeTableInfo" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ” è‹±é›„å±æ€§æŸ¥çœ‹</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="input-group">
                        <label style="font-weight: 600; color: #333; margin-bottom: 8px;">é€‰æ‹©è‹±é›„</label>
                        <select id="heroSelect" onchange="updateHeroLevelSelect()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">è¯·å…ˆä¸Šä¼ è‹±é›„è¡¨</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label style="font-weight: 600; color: #333; margin-bottom: 8px;">é€‰æ‹©ç­‰çº§</label>
                        <select id="heroLevelSelect" onchange="updateHeroAttributes()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">è¯·å…ˆé€‰æ‹©è‹±é›„</option>
                        </select>
                    </div>
                </div>
                <div id="heroAttributesDisplay" style="background: white; border-radius: 8px; padding: 20px; border: 2px solid #e0e0e0; display: none;">
                    <div style="font-size: 1.1em; font-weight: 600; color: #667eea; margin-bottom: 15px;" id="heroDisplayName"></div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">æ”»å‡»åŠ›</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #f44336;" id="heroAttrAttack">-</div>
                        </div>
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">é˜²å¾¡åŠ›</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #2196F3;" id="heroAttrDefense">-</div>
                        </div>
                        <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">ç”Ÿå‘½å€¼</div>
                            <div style="font-size: 1.3em; font-weight: 600; color: #4CAF50;" id="heroAttrHp">-</div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;" id="heroAttrInfo"></div>
                </div>
            </div>
        </div>

                <div class="config-section">
                    <div class="section-title">ğŸ‘¹ æ€ªç‰©å±æ€§æŸ¥çœ‹</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div class="input-group">
                                <label style="font-weight: 600; color: #333; margin-bottom: 8px;">é€‰æ‹©æ€ªç‰©</label>
                                <select id="monsterSelect" onchange="updateMonsterAttributes()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                                    <option value="">è¯·å…ˆä¸Šä¼ æ€ªç‰©è¡¨</option>
                                </select>
                            </div>
                        </div>
                        <div id="monsterAttributesDisplay" style="background: white; border-radius: 8px; padding: 20px; border: 2px solid #e0e0e0; display: none;">
                            <div style="font-size: 1.1em; font-weight: 600; color: #667eea; margin-bottom: 15px;" id="monsterDisplayName"></div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">æ”»å‡»åŠ›</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #f44336;" id="monsterAttrAttack">-</div>
                                </div>
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">é˜²å¾¡åŠ›</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #2196F3;" id="monsterAttrDefense">-</div>
                                </div>
                                <div style="padding: 12px; background: #f8f9ff; border-radius: 6px;">
                                    <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">ç”Ÿå‘½å€¼</div>
                                    <div style="font-size: 1.3em; font-weight: 600; color: #4CAF50;" id="monsterAttrHp">-</div>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;" id="monsterAttrInfo"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ç©å®¶ç»æµæ¨¡æ‹Ÿæ ‡ç­¾é¡µ -->
            <div id="tab-economy" class="tab-content">
                <div class="config-section">
                    <div class="section-title">ğŸ’¾ ç»æµæ–¹æ¡ˆç®¡ç†</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 12px;">
                            <input type="text" id="economySchemeNameInput" placeholder="æ–¹æ¡ˆåç§°" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 140px;" />
                            <button class="btn btn-primary" onclick="saveEconomyScheme()" style="padding: 8px 16px; font-size: 0.9em;">ä¿å­˜æ–¹æ¡ˆ</button>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <select id="economySchemeSelect" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 180px;">
                                <option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>
                            </select>
                            <button class="btn btn-secondary" onclick="newEconomyScheme()" style="padding: 8px 16px; font-size: 0.9em;">æ–°å»ºæ–¹æ¡ˆ</button>
                            <button class="btn btn-secondary" onclick="loadEconomySchemeById()" style="padding: 8px 16px; font-size: 0.9em;">åŠ è½½æ–¹æ¡ˆ</button>
                            <button class="btn btn-secondary" onclick="copyEconomyScheme()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white;">å¤åˆ¶æ–¹æ¡ˆ</button>
                            <button class="btn btn-danger" onclick="deleteEconomyScheme()" style="padding: 8px 16px; font-size: 0.9em;">åˆ é™¤æ–¹æ¡ˆ</button>
                        </div>
                        <div id="economySchemeStatus" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ’ ç©å®¶è´¦å·æ¯æ—¥èµ„æº</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label>ä½“åŠ›</label>
                                <input type="number" id="playerStamina" min="0" value="100" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                <div style="font-size: 0.8em; color: #666; margin-top: 4px;">ä¸‹ä¸€å¤©å¢åŠ </div>
                            </div>
                            <div class="input-group">
                                <label>é‡‘å¸</label>
                                <input type="number" id="playerDailyGold" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                <div style="font-size: 0.8em; color: #666; margin-top: 4px;">ä¸‹ä¸€å¤©å¢åŠ </div>
                            </div>
                            <div class="input-group">
                                <label>é’»çŸ³</label>
                                <input type="number" id="playerDailyDiamond" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                <div style="font-size: 0.8em; color: #666; margin-top: 4px;">ä¸‹ä¸€å¤©å¢åŠ </div>
                            </div>
                            <div class="input-group">
                                <label>æ‹›å‹Ÿåˆ¸</label>
                                <input type="number" id="playerDailyRecruitTickets" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                <div style="font-size: 0.8em; color: #666; margin-top: 4px;">ä¸‹ä¸€å¤©å¢åŠ </div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <span style="font-weight: 600; color: #333;">å½“å‰å¤©æ•°ï¼š<span id="playerCurrentDay">1</span> å¤©</span>
                            <button class="btn btn-primary" onclick="nextDay()" style="padding: 8px 16px; font-size: 0.9em;">ğŸ“… ä¸‹ä¸€å¤©</button>
                            <button class="btn btn-primary" onclick="nextTenDays()" style="padding: 8px 16px; font-size: 0.9em;">ğŸ“… ä¸‹10å¤©</button>
                            <button class="btn btn-danger" onclick="resetAccountInfo()" style="padding: 8px 16px; font-size: 0.9em;">ğŸ”„ é‡ç½®è´¦å·ä¿¡æ¯</button>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ“Š ç©å®¶è´¦å·å½“å‰èµ„æº</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label>ä½“åŠ›</label>
                                <input type="number" id="playerCurrentStamina" min="0" value="100" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                <div style="font-size: 0.8em; color: #666; margin-top: 4px;">å½“å‰å¯ç”¨ä½“åŠ›ï¼ˆæ— ä¸Šé™ï¼‰</div>
                            </div>
                            <div class="input-group">
                                <label>é‡‘å¸</label>
                                <input type="number" id="playerGold" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                            </div>
                            <div class="input-group">
                                <label>é’»çŸ³</label>
                                <input type="number" id="playerDiamond" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ“¦ ç©å®¶è´¦å·ç­‰çº§åŠèƒŒåŒ…</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                            <div>
                                <div class="section-title" style="font-size: 1em; margin-bottom: 15px;">è´¦å·ä¿¡æ¯</div>
                                <div class="input-group">
                                    <label>è´¦å·ç­‰çº§</label>
                                    <input type="number" id="playerLevel" min="1" value="1" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                </div>
                                <div class="input-group">
                                    <label>ç»éªŒå€¼</label>
                                    <input type="number" id="playerExp" min="0" value="0" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                </div>
                                <div class="input-group">
                                    <label>å‡çº§æ‰€éœ€ç»éªŒ</label>
                                    <input type="number" id="playerExpRequired" min="0" value="100" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;" />
                                </div>
                            </div>
                            <div>
                                <div class="section-title" style="font-size: 1em; margin-bottom: 15px;">èƒŒåŒ…ç‰©å“</div>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                                    <select id="newItemResourceSelect" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 200px;">
                                        <option value="">è¯·é€‰æ‹©èµ„æºï¼ˆéœ€å…ˆä¸Šä¼ ç‰©å“æ€»è¡¨ï¼‰</option>
                                    </select>
                                    <input type="number" id="newItemCount" placeholder="æ•°é‡" min="1" value="1" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                                    <button class="btn btn-primary" onclick="addItemToBag()" style="padding: 8px 16px; font-size: 0.9em;">â• æ·»åŠ </button>
                                </div>
                                <div id="bagItemsList" style="max-height: 300px; overflow-y: auto;">
                                    <!-- èƒŒåŒ…ç‰©å“åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ® ç©å®¶ç©æ³•æ±‡æ€»</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <input type="text" id="newGameplayName" placeholder="ç©æ³•åç§°" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 150px;" />
                            <input type="number" id="newGameplayStaminaCost" placeholder="ä½“åŠ›æ¶ˆè€—" min="0" value="0" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 120px;" />
                            <button class="btn btn-primary" onclick="addGameplay()" style="padding: 8px 16px; font-size: 0.9em;">â• æ·»åŠ ç©æ³•</button>
                        </div>
                        <div id="gameplayList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                            <!-- ç©æ³•åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ’ èµ„æºæ¶ˆè€—ç©æ³•æ±‡æ€»</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <input type="text" id="newResourceGameplayName" placeholder="ç©æ³•åç§°" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 150px;" />
                            <input type="text" id="newResourceGameplayItemName" placeholder="æ¶ˆè€—é“å…·åç§°" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 150px;" />
                            <button class="btn btn-primary" onclick="addResourceGameplay()" style="padding: 8px 16px; font-size: 0.9em;">â• æ·»åŠ ç©æ³•</button>
                        </div>
                        <div id="resourceGameplayList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                            <!-- èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">â­ è‹±é›„å‡çº§é…ç½®ï¼ˆ1~30çº§æ‰€éœ€æœ¬ä½“æ•°é‡ï¼‰</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                            é…ç½®æ¯ä¸ªç­‰çº§å‡çº§æ‰€éœ€çš„è‹±é›„æœ¬ä½“æ•°é‡ï¼ˆ1çº§ä¸º0ï¼Œ2çº§å¼€å§‹éœ€è¦æœ¬ä½“ï¼‰
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <button type="button" id="heroUpgradeConfigToggleBtn" onclick="toggleHeroUpgradeConfigValues()" style="padding: 6px 14px; font-size: 0.9em; border: 2px solid #667eea; border-radius: 6px; background: #f0f4ff; color: #667eea; cursor: pointer;">å±•å¼€æ•°å€¼</button>
                        </div>
                        <div id="heroUpgradeConfigValuesArea" style="display: none;">
                            <div id="heroUpgradeConfigGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; max-height: 400px; overflow-y: auto; padding: 10px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                                <!-- é…ç½®è¾“å…¥æ¡†å°†åŠ¨æ€ç”Ÿæˆ -->
                            </div>
                            <div style="margin-top: 15px;">
                                <button class="btn btn-primary" onclick="resetHeroUpgradeConfig()" style="padding: 8px 16px; font-size: 0.9em;">ğŸ”„ æ¢å¤é»˜è®¤é…ç½®</button>
                                <button class="btn btn-success" onclick="saveHeroUpgradeConfig()" style="padding: 8px 16px; font-size: 0.9em; margin-left: 10px;">ğŸ’¾ ä¿å­˜é…ç½®</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">ğŸ¦¸ ç©å®¶è‹±é›„æ‹¥æœ‰æƒ…å†µ</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <select id="addHeroSelect" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 200px;">
                                <option value="">é€‰æ‹©è‹±é›„ï¼ˆä»è‹±é›„è¡¨è¯»å–ï¼‰</option>
                            </select>
                            <input type="number" id="addHeroLevel" placeholder="ç­‰çº§" min="1" value="1" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; width: 100px;" />
                            <button class="btn btn-primary" onclick="addPlayerHero()" style="padding: 8px 16px; font-size: 0.9em;">â• æ·»åŠ è‹±é›„</button>
                        </div>
                        <div id="playerHeroesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                            <!-- è‹±é›„åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="section-title">âš”ï¸ ç©å®¶è£…å¤‡æ‹¥æœ‰æƒ…å†µ</div>
                    <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <select id="addEquipmentSelect" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; flex: 1; min-width: 200px;">
                                <option value="">é€‰æ‹©è£…å¤‡ï¼ˆä»è£…å¤‡è¡¨è¯»å–ï¼‰</option>
                            </select>
                            <button class="btn btn-primary" onclick="addPlayerEquipment()" style="padding: 8px 16px; font-size: 0.9em;">â• æ·»åŠ è£…å¤‡</button>
                        </div>
                        
                        <div style="min-height: 200px;">
                            <div class="section-title" style="font-size: 1em; margin-bottom: 15px;">ğŸ“¦ å·²æ‹¥æœ‰è£…å¤‡</div>
                            <div id="playerOwnedEquipmentPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; min-height: 100px; width: 100%; overflow: visible;">
                                <!-- å·²æ‹¥æœ‰è£…å¤‡é¢æ¿å°†åŠ¨æ€ç”Ÿæˆ -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¸»é…ç½®å†…å®¹ -->
        <div id="main-content">
        <div class="config-section">
            <div class="section-title">ğŸ’° ç©å®¶ç»æµæ¨¡æ‹Ÿå…³è”</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 500; color: #333;">
                        <input type="checkbox" id="useEconomySimulationCheckbox" onchange="toggleUseEconomySimulation()" style="width: 18px; height: 18px;" />
                        <span>è¯»å–ç©å®¶ç»æµæ¨¡æ‹Ÿä¿¡æ¯</span>
                    </label>
                    <div id="mainConfigEconomySchemeWrap" style="display: none; align-items: center; gap: 10px;">
                        <span style="color: #666; font-size: 0.9em;">ç»æµæ–¹æ¡ˆï¼š</span>
                        <select id="mainConfigEconomySchemeSelect" onchange="onMainConfigEconomySchemeChange()" style="padding: 6px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; min-width: 180px;">
                            <option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>
                        </select>
                    </div>
                </div>
                <div id="mainConfigEconomyHint" style="display: none; margin-top: 10px; font-size: 0.85em; color: #666;">
                    è§’è‰²ä»…å¯é€‰ç»æµæ–¹æ¡ˆä¸­çš„è‹±é›„ä¸”ç­‰çº§ä¸è¶…è¿‡å·²æœ‰ç­‰çº§ï¼›èŒä¸šè£…å¤‡ä»…å¯é€‰ç»æµæ–¹æ¡ˆä¸­å·²æ‹¥æœ‰çš„è£…å¤‡ã€‚
                </div>
            </div>
        </div>

        <div class="scheme-manager">
            <div class="section-title">ğŸ’¾ æ–¹æ¡ˆç®¡ç†ï¼ˆæœ€å¤š10ä¸ªæ–¹æ¡ˆï¼‰</div>
            <div class="scheme-controls">
                <input type="text" class="scheme-input" id="schemeNameInput" placeholder="è¾“å…¥æ–¹æ¡ˆåç§°..." maxlength="20" />
                <button class="btn btn-primary" onclick="saveScheme()" style="padding: 8px 20px; flex: 0;">ä¿å­˜æ–¹æ¡ˆ</button>
                <button class="btn btn-secondary" onclick="newScheme()" style="padding: 8px 20px; flex: 0;">æ–°å»ºæ–¹æ¡ˆ</button>
                <button class="btn btn-secondary" onclick="clearCurrentScheme()" style="padding: 8px 20px; flex: 0;">æ¸…ç©ºé…ç½®</button>
            </div>
            <div class="scheme-list" id="schemeList"></div>
            <div class="scheme-warning" id="schemeWarning"></div>
        </div>

        <div class="config-section">
            <div class="section-title" style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                <span>ğŸ‘¥ è§’è‰²åŸºç¡€å±æ€§é…ç½®ï¼ˆ5ä¸ªè§’è‰²ï¼‰</span>
                <button class="btn btn-primary" onclick="autoDeployHeroes()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white;">âš¡ ä¸€é”®ä¸Šé˜µ</button>
            </div>
            <div class="characters-grid" id="charactersGrid"></div>
        </div>

        <div class="config-section">
            <div class="section-title" style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                <span>âš”ï¸ èŒä¸šè£…å¤‡é…ç½®</span>
                <button class="btn btn-primary" onclick="autoEquipAllJobs()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white;">âš¡ ä¸€é”®ç©¿æˆ´</button>
            </div>
            <div id="jobEquipmentPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;"></div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸ“ˆ å¹³å°å±æ€§é…ç½®</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    å¹³å°å±æ€§åŠ æˆå…¬å¼ï¼šæœ€ç»ˆå±æ€§ = åŸºç¡€å±æ€§ + ç³»æ•° Ã— (å±€å¤–è‹±é›„æ•°é‡ + å±€å¤–è‹±é›„ç­‰çº§å’Œ)
                </div>
                <div id="platformEconomyHeroWrap" style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: default; user-select: none; font-size: 0.95em; color: #666;">
                        <input type="checkbox" id="platformEconomyHeroCheckbox" disabled style="width: 18px; height: 18px; pointer-events: none;" />
                        <span>è¯»å–è´¦å·è‹±é›„æ•°é‡åŠç­‰çº§å’Œ</span>
                    </label>
                    <span id="platformEconomyHeroDisplay" style="font-size: 0.9em; color: #667eea;"></span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="input-group">
                        <label>å±€å¤–è‹±é›„æ•°é‡</label>
                        <input type="number" id="platformHeroCount" min="0" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>å±€å¤–è‹±é›„ç­‰çº§å’Œ</label>
                        <input type="number" id="platformHeroLevelSum" min="0" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>æ”»å‡»ç³»æ•°</label>
                        <input type="number" id="platformAttackCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>é˜²å¾¡ç³»æ•°</label>
                        <input type="number" id="platformDefenseCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>ç”Ÿå‘½å€¼ç³»æ•°</label>
                        <input type="number" id="platformHpCoeff" min="0" step="0.01" value="0" onchange="updatePlatformAttributes()" />
                    </div>
                </div>
                <div id="platformBonusInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666;">
                    <div>å½“å‰å¹³å°åŠ æˆï¼šæ”»å‡» +0ï¼Œé˜²å¾¡ +0ï¼Œç”Ÿå‘½ +0</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸš— å¹³å°å±æ€§ï¼ˆè½¦è¾†ï¼‰é…ç½®</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    è½¦è¾†å±æ€§ä¼šç›´æ¥åŠ åˆ°æ‰€æœ‰è§’è‰²çš„æœ€ç»ˆå±æ€§ä¸Š
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="input-group">
                        <label>æ”»å‡»åŠ›</label>
                        <input type="number" id="vehicleAttack" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>é˜²å¾¡åŠ›</label>
                        <input type="number" id="vehicleDefense" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                    <div class="input-group">
                        <label>ç”Ÿå‘½å€¼</label>
                        <input type="number" id="vehicleHp" min="0" value="0" onchange="updateVehicleAttributes()" />
                    </div>
                </div>
                <div id="vehicleBonusInfo" style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 0.9em; color: #666;">
                    <div>å½“å‰è½¦è¾†åŠ æˆï¼šæ”»å‡» +0ï¼Œé˜²å¾¡ +0ï¼Œç”Ÿå‘½ +0</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">âš¡ è£…å¤‡å¼ºåŒ–é…ç½®</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    æ‰‹åŠ¨é…ç½®å„ä¸ªèŒä¸šå„ä¸ªéƒ¨ä½çš„å¼ºåŒ–ç­‰çº§ï¼ˆç”¨äºä¸»é…ç½®è®¡ç®—ï¼Œä¸å½±å“ç»æµæ¨¡æ‹Ÿæ•°æ®ï¼‰
                </div>
                <div id="mainConfigEquipSlotEnhancePanel" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px;">
                    <!-- è£…å¤‡å¼ºåŒ–é¢æ¿å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸ“Š è§’è‰²æœ€ç»ˆå±æ€§ï¼ˆç”¨äºæˆ˜æ–—è®¡ç®—ï¼‰</div>
            <div id="finalAttributesPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px;"></div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸ“Š ä¼¤å®³å…¬å¼è¯´æ˜</div>
            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                <div style="font-weight: 600; color: #333; margin-bottom: 10px;">å½“å‰åº”ç”¨çš„ä¼¤å®³è®¡ç®—å…¬å¼ï¼š</div>
                <div style="color: #666; font-size: 0.9em; line-height: 1.8;">
                    <div><strong>è§’è‰²å¯¹æ€ªç‰©ä¼¤å®³ï¼š</strong>åŸºç¡€ä¼¤å®³ = æ”»å‡»åŠ› - æ€ªç‰©é˜²å¾¡åŠ›ï¼ˆæœ€å°1ç‚¹ï¼‰</div>
                    <div style="margin-left: 20px;">â€¢ è§’è‰²2ã€3ã€4ï¼šæœ€ç»ˆä¼¤å®³ = åŸºç¡€ä¼¤å®³ Ã— (1 + æŠ€èƒ½ä¼¤å®³ç³»æ•°%)</div>
                    <div><strong>æ€ªç‰©å¯¹è§’è‰²ä¼¤å®³ï¼š</strong>åŸºç¡€ä¼¤å®³ = æ€ªç‰©æ”»å‡»åŠ› - è§’è‰²é˜²å¾¡åŠ›ï¼ˆæœ€å°1ç‚¹ï¼‰</div>
                    <div style="margin-left: 20px;">â€¢ è§’è‰²1ï¼šæœ€ç»ˆä¼¤å®³ = åŸºç¡€ä¼¤å®³ Ã— (1 - å‡ä¼¤ç™¾åˆ†æ¯”%)</div>
                </div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸ† å…³å¡æŒ‘æˆ˜é…ç½®ï¼ˆ1-20å…³ï¼‰</div>
            <div style="background: #f8f9ff; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <div style="margin-bottom: 15px; text-align: center;">
                    <button class="btn btn-success" onclick="challengeAllStages()" style="padding: 12px 30px; font-size: 1em; font-weight: 600; background: #51cf66;">
                        âš¡ ä¸€é”®æŒ‘æˆ˜æ‰€æœ‰å…³å¡
                    </button>
                    <div id="allStagesProgress" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
                </div>
                <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
                    æ¯å…³å¯é…ç½®ä¸€ä¸ªæ€ªç‰©IDï¼Œæ”»é˜²è¡€ä»æ€ªç‰©è¡¨è¯»å–ï¼Œå…¶ä»–å±æ€§æ‰‹åŠ¨é…ç½®
                </div>
                <div id="stageConfigGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;"></div>
            </div>
        </div>

        <div class="config-section">
            <div class="section-title">ğŸ‘¹ æ€ªç‰©é…ç½®</div>
            <div class="monster-config">
                <div class="monster-spawn-rate">
                    <label>æ¯ç§’åˆ·æ–°æ•°é‡ï¼š</label>
                    <input type="number" id="spawnRate" min="0.1" max="10" step="0.1" value="1" style="width: 100px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px;">
                    <span>ä¸ª/ç§’</span>
                </div>
                <div class="monster-config-grid">
                    <div class="input-group">
                        <label>æ”»å‡»åŠ›</label>
                        <input type="number" id="monsterAttack" min="1" value="10" />
                    </div>
                    <div class="input-group">
                        <label>é˜²å¾¡åŠ›</label>
                        <input type="number" id="monsterDefense" min="0" value="5" />
                    </div>
                    <div class="input-group">
                        <label>è¡€é‡</label>
                        <input type="number" id="monsterHp" min="1" value="50" />
                    </div>
                    <div class="input-group">
                        <label>æ”»å‡»é€Ÿåº¦ï¼ˆæ¬¡/ç§’ï¼‰</label>
                        <input type="number" id="monsterAtkSpeed" min="0.1" max="10" step="0.1" value="1" />
                    </div>
                    <div class="input-group">
                        <label>æ”»å‡»ç³»æ•°</label>
                        <input type="number" id="monsterDamageCoeff" min="0" step="0.01" value="1" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">æœ€ç»ˆä¼¤å®³ = åŸºç¡€ä¼¤å®³ Ã— æ”»å‡»ç³»æ•°</div>
                    </div>
                    <div class="input-group">
                        <label>è¡€é‡ç³»æ•°</label>
                        <input type="number" id="monsterHpCoeff" min="0" step="0.01" value="0" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">è¿›å…¥æˆ˜æ–—æ—¶è¡€é‡ = åŸºç¡€è¡€é‡ Ã— (1 + è¡€é‡ç³»æ•°)</div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <button class="btn btn-secondary" onclick="resetConfig()">é‡ç½®é…ç½®</button>
            <button class="btn btn-primary" id="startBtn" onclick="startBattle()">å¼€å§‹æˆ˜æ–—</button>
            <button class="btn btn-success" id="quickResultBtn" onclick="quickBattle()" style="background: #51cf66;">ç›´æ¥æ˜¾ç¤ºç»“æœ</button>
            <button class="btn btn-danger" id="stopBtn" onclick="stopBattle()" style="display: none;">åœæ­¢æˆ˜æ–—</button>
        </div>
        </div>

        <div class="message" id="message"></div>

        <div class="battle-area" id="battleArea">
            <div class="section-title">âš”ï¸ æˆ˜æ–—è¿›è¡Œä¸­</div>
            <div class="battle-stats" id="battleStats"></div>
            
            <!-- å¯è§†åŒ–æˆ˜æ–—åœºæ™¯ï¼ˆä¸»é…ç½®é¡µç­¾ä¸ä½¿ç”¨ï¼Œéšè—èƒŒæ™¯ï¼‰ -->
            <div class="battle-scene" id="battleScene" style="background: transparent; min-height: 0; padding: 0; display: none;">
                <div class="battle-field">
                    <div class="characters-side" id="charactersSide"></div>
                    <div class="monsters-side" id="monstersSide"></div>
                </div>
            </div>
            
            <div class="characters-panel">
                <div class="section-title" style="margin-bottom: 15px;">ğŸ‘¥ è§’è‰²çŠ¶æ€</div>
                <div class="characters-panel-grid" id="charactersPanel"></div>
            </div>
            <div class="battle-log" id="battleLog"></div>
        </div>
    </div>

    <script>
        // ç‰ˆæœ¬å·ç®¡ç†
        const VERSION = '2.4.5';
        document.getElementById('version').textContent = VERSION;
        document.title = `æˆ˜æ–—æ¨¡æ‹Ÿå™¨ v${VERSION}`;

        // èŒä¸šç±»å‹
        const JOB_TYPES = {
            TANK: 1,      // å¦å…‹
            WARRIOR: 2,  // æˆ˜å£«
            ARCHER: 3,   // å°„æ‰‹
            SUPPORT: 4   // è¾…åŠ©
        };

        const JOB_NAMES = {
            1: 'å¦å…‹',
            2: 'æˆ˜å£«',
            3: 'å°„æ‰‹',
            4: 'è¾…åŠ©'
        };

        // è£…å¤‡è¡¨æ•°æ®
        let equipmentTable = [];
        const EQUIPMENT_STORAGE_KEY = 'battleSimulatorEquipmentTable';
        
        // è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨æ•°æ®ï¼ˆä»EquipSlotLevelé¡µç­¾è¯»å–ï¼‰
        let equipSlotLevelTable = []; // [{type, heroClasses, slotLevel, costItem, attribute}, ...]
        const EQUIP_SLOT_LEVEL_STORAGE_KEY = 'battleSimulatorEquipSlotLevelTable';
        
        // ç©å®¶è£…å¤‡æ§½ä½å¼ºåŒ–ç­‰çº§æ•°æ® {jobId: {type: level}, ...}
        // jobId: 1=å¦å…‹, 2=æˆ˜å£«, 3=å°„æ‰‹, 4=è¾…åŠ©
        // type: 'å¤´'=1, 'èº«'=2, 'æ‰‹'=3, 'è„š'=4
        let equipSlotLevels = {
            1: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            2: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            3: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            4: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 }
        };
        
        // ä¸»é…ç½®é¡µç­¾çš„è£…å¤‡å¼ºåŒ–ç­‰çº§æ•°æ®ï¼ˆç‹¬ç«‹äºç»æµæ¨¡æ‹Ÿæ•°æ®ï¼‰
        let mainConfigEquipSlotLevels = {
            1: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            2: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            3: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
            4: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 }
        };
        
        // è‹±é›„è¡¨æ•°æ®
        let heroTable = [];
        let monsterTable = []; // æ€ªç‰©è¡¨æ•°æ®
        const HERO_STORAGE_KEY = 'battleSimulatorHeroTable';
        const MONSTER_STORAGE_KEY = 'battleSimulatorMonsterTable';
        
        // èµ„æºç±»ç‰©å“è¡¨æ•°æ®ï¼ˆä»item_10é¡µç­¾è¯»å–ï¼‰
        let resourceItemTable = []; // [{id, name}, ...]
        const RESOURCE_ITEM_STORAGE_KEY = 'battleSimulatorResourceItemTable';
        
        // æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨æ•°æ®
        let recruitInfoTable = [];
        const RECRUIT_INFO_STORAGE_KEY = 'battleSimulatorRecruitInfoTable';
        const RECRUIT_BOX_LEVEL_STORAGE_KEY = 'battleSimulatorRecruitBoxLevelTable';
        const RECRUIT_POOL_STORAGE_KEY = 'battleSimulatorRecruitPoolTable';
        
        // æ‹›å‹Ÿå¥–æ± ç­‰çº§è¡¨æ•°æ®ï¼ˆä»HeroBoxLevelé¡µç­¾è¯»å–ï¼‰
        let recruitBoxLevelTable = []; // [{level, requiredCount}, ...]
        // HeroPoolGroup å¥–æ± è¡¨ï¼šC=ç­‰çº§ D=å“è´¨(1~4â†’3~6)æˆ–é‡‘å¸ E=æƒé‡
        let recruitPoolTable = []; // [{level, qualityOrGold, weight}, ...]
        
        // æ‹›å‹Ÿå¥–æ± çŠ¶æ€
        let recruitBoxLevel = 1; // å½“å‰å¥–æ± ç­‰çº§ï¼Œåˆå§‹1çº§
        let recruitCount = 0; // å½“å‰æ‹›å‹Ÿæ¬¡æ•°
        let lastRecruitResult = { heroes: [], gold: 0 }; // æœ¬æ¬¡æ‹›å‹Ÿè·å¾—ï¼Œç”¨äºå±•ç¤º { heroes: [{heroId, name, quality, count}], gold }
        
        // ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼šBåˆ—=ç­‰çº§ Cåˆ—=å‡åˆ°æœ¬çº§åˆ«éœ€è¦çš„ç»éªŒï¼Œå‰5è¡Œè¡¨å¤´
        let accountLevelTable = []; // [{ level, expRequired }, ...]
        const ACCOUNT_LEVEL_TABLE_STORAGE_KEY = 'battleSimulatorAccountLevelTable';
        
        // éƒ¨ä½ç±»å‹
        const EQUIPMENT_TYPES = {
            HEAD: 'å¤´',
            BODY: 'èº«',
            HAND: 'æ‰‹',
            FOOT: 'è„š'
        };
        
        // è§’è‰²è£…å¤‡é…ç½®ï¼ˆèŒä¸š -> éƒ¨ä½ -> è£…å¤‡IDï¼‰
        let characterEquipment = {
            1: { head: null, body: null, hand: null, foot: null }, // å¦å…‹
            2: { head: null, body: null, hand: null, foot: null }, // æˆ˜å£«
            3: { head: null, body: null, hand: null, foot: null }, // å°„æ‰‹
            4: { head: null, body: null, hand: null, foot: null }  // è¾…åŠ©
        };

        // è§’è‰²æ•°æ®
        const characters = Array.from({ length: 5 }, (_, i) => {
            let job = JOB_TYPES.SUPPORT; // é»˜è®¤è¾…åŠ©
            if (i === 0) job = JOB_TYPES.TANK;      // è§’è‰²1ï¼šå¦å…‹
            else if (i === 1) job = JOB_TYPES.WARRIOR; // è§’è‰²2ï¼šæˆ˜å£«
            else if (i === 2 || i === 3) job = JOB_TYPES.ARCHER; // è§’è‰²3ã€4ï¼šå°„æ‰‹
            else if (i === 4) job = JOB_TYPES.SUPPORT; // è§’è‰²5ï¼šè¾…åŠ©

            return {
                id: i + 1,
                name: `è§’è‰²${i + 1}`,
                job: job, // èŒä¸š
                equipmentId: null, // å½“å‰è£…å¤‡ID
                baseAttack: 20, // åŸºç¡€æ”»å‡»åŠ›ï¼ˆä¸å«è£…å¤‡åŠ æˆï¼‰
                baseDefense: 10, // åŸºç¡€é˜²å¾¡åŠ›ï¼ˆä¸å«è£…å¤‡åŠ æˆï¼‰
                baseHp: 100, // åŸºç¡€è¡€é‡ï¼ˆä¸å«è£…å¤‡åŠ æˆï¼‰
                attack: 20,
                defense: 10,
                hp: 100,
                maxHp: 100,
                atkSpeed: 1, // æ¯ç§’1æ¬¡
                healRate: i === 4 ? 0.2 : 0, // è§’è‰²5é»˜è®¤å›è¡€ç³»æ•°0.2ï¼Œå…¶ä»–è§’è‰²ä¸º0
                damageReduction: i === 0 ? 15 : 0, // è§’è‰²1å‡ä¼¤ç™¾åˆ†æ¯”ï¼ˆ0-100ï¼‰ï¼Œé»˜è®¤15
                skillDamage: (i === 1 || i === 2 || i === 3) ? 0 : 0, // è§’è‰²2ã€3ã€4æŠ€èƒ½ä¼¤å®³ç³»æ•°ï¼ˆç™¾åˆ†æ¯”ï¼‰
                isAlive: true
            };
        });

        // æ€ªç‰©é…ç½®
        let monsterConfig = {
            spawnRate: 1, // æ¯ç§’xä¸ª
            attack: 10,
            defense: 5,
            hp: 50,
            atkSpeed: 1,
            damageCoeff: 1, // æ”»å‡»ç³»æ•°ï¼Œæœ€ç»ˆä¼¤å®³ = åŸºç¡€ä¼¤å®³ Ã— æ”»å‡»ç³»æ•°
            hpCoeff: 0 // è¡€é‡ç³»æ•°ï¼Œè¿›å…¥æˆ˜æ–—æ—¶è¡€é‡ = åŸºç¡€è¡€é‡ Ã— (1 + è¡€é‡ç³»æ•°)
        };

        // å…³å¡é…ç½®ï¼ˆ1-20å…³ï¼‰
        let stageConfig = {};
        for (let i = 1; i <= 20; i++) {
            stageConfig[i] = {
                monsterId: '', // æ€ªç‰©IDï¼ˆä»æ€ªç‰©è¡¨é€‰æ‹©ï¼‰
                atkSpeed: 0.33, // æ”»å‡»é€Ÿåº¦ï¼ˆæ¬¡/ç§’ï¼‰
                damageCoeff: 1, // æ”»å‡»ç³»æ•°
                hpCoeff: 0 // è¡€é‡ç³»æ•°
            };
        }

        // 25æ³¢æ€ªç‰©æ•°æ®è¾“å…¥é…ç½®ï¼ˆç”¨äºå±€å†…æˆ˜æ–—æ¨¡æ‹Ÿï¼‰
        let battleWaveData = {};
        for (let i = 1; i <= 25; i++) {
            battleWaveData[i] = {
                monsterId: '', // æ€ªç‰©IDï¼ˆä»æ€ªç‰©è¡¨é€‰æ‹©ï¼Œä¸ºç©ºåˆ™æ‰‹åŠ¨è¾“å…¥ï¼‰
                attack: 10, // æ”»å‡»åŠ›ï¼ˆé€‰æ‹©æ€ªç‰©IDæ—¶è‡ªåŠ¨å¡«å……ï¼Œä¹Ÿå¯æ‰‹åŠ¨è¾“å…¥ï¼‰
                defense: 5, // é˜²å¾¡åŠ›ï¼ˆé€‰æ‹©æ€ªç‰©IDæ—¶è‡ªåŠ¨å¡«å……ï¼Œä¹Ÿå¯æ‰‹åŠ¨è¾“å…¥ï¼‰
                hp: 50, // ç”Ÿå‘½å€¼ï¼ˆé€‰æ‹©æ€ªç‰©IDæ—¶è‡ªåŠ¨å¡«å……ï¼Œä¹Ÿå¯æ‰‹åŠ¨è¾“å…¥ï¼‰
                atkSpeed: 0.33, // æ”»é€Ÿï¼ˆæ‰‹åŠ¨è¾“å…¥ï¼‰
                damageCoeff: 1, // ä¼¤å®³ç³»æ•°ï¼ˆæ‰‹åŠ¨è¾“å…¥ï¼‰
                hpCoeff: 1, // ç”Ÿå‘½å€¼å€ç‡ï¼ˆæ‰‹åŠ¨è¾“å…¥ï¼‰
                spawnRate: 1, // æ¯ç§’å‡ºå‡ åªæ€ª
                duration: 10, // æŒç»­å¤šå°‘ç§’
                coinReward: 0 // å‡»æ€æ€ªç‰©è·å¾—çš„é“¶å¸å¥–åŠ±
            };
        }
        
        // æ®ç‚¹ç³»ç»Ÿé…ç½®ï¼ˆæ¯5æ³¢ä¸€ä¸ªæ®ç‚¹ï¼Œå…±5ä¸ªæ®ç‚¹ï¼‰
        let strongholdRewards = {}; // æ®ç‚¹å¥–åŠ±é…ç½® {1: 100, 2: 200, ...} è¡¨ç¤ºç¬¬1ã€2ã€3ã€4ã€5ä¸ªæ®ç‚¹çš„é“¶å¸å¥–åŠ±
        for (let i = 1; i <= 5; i++) {
            strongholdRewards[i] = 0; // é»˜è®¤å¥–åŠ±ä¸º0
        }
        
        // è·å–æ³¢æ¬¡æ‰€å±çš„æ®ç‚¹ç¼–å·ï¼ˆ1-5ï¼‰
        function getStrongholdForWave(wave) {
            return Math.ceil(wave / 5);
        }
        
        // è·å–æ®ç‚¹çš„æ³¢æ¬¡èŒƒå›´
        function getStrongholdWaveRange(stronghold) {
            const startWave = (stronghold - 1) * 5 + 1;
            const endWave = Math.min(stronghold * 5, 25);
            return { start: startWave, end: endWave };
        }

        // æ­¦å™¨å’ŒæŠ€èƒ½å‡çº§è¡¨
        let weaponCostTable = []; // æ­¦å™¨å‡çº§æ¶ˆè€—è¡¨ [{level: 0, cost: 10, damageCoeff: 1.0}, ...]
        let skillCostTable = []; // æŠ€èƒ½å‡çº§æ¶ˆè€—è¡¨ [{level: 0, cost: 10, damageCoeff: 1.0}, ...]

        // æ³¢æ¬¡æˆ˜æ–—ä¸­çš„é“¶å¸å’Œå‡çº§çŠ¶æ€
        let waveBattleCoins = 0; // å½“å‰é“¶å¸
        let weaponLevel = 0; // å½“å‰æ­¦å™¨ç­‰çº§
        let skillLevel = 0; // å½“å‰æŠ€èƒ½ç­‰çº§

        // æ€ªç‰©ç”Ÿæˆåå¼€å§‹æ”»å‡»å‰çš„å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤3ç§’ï¼Œå¯åœ¨ç•Œé¢ä¸­é…ç½®
        let monsterAttackDelay = 3;
        // æ€ªç‰©ç”Ÿæˆåä¸å¯è¢«æ”»å‡»çš„æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤1ç§’ï¼Œå¯åœ¨ç•Œé¢ä¸­é…ç½®
        let monsterInvincibleTime = 1;
        // è§’è‰²æ”»å‡»é¢‘ç‡ï¼ˆç§’/æ¬¡ï¼‰ï¼Œé»˜è®¤0.1ç§’æ”»å‡»ä¸€æ¬¡ï¼›ä»¥åŠæ¯æ¬¡æ”»å‡»ä¼¤å®³å€ç‡ï¼Œé»˜è®¤0.1å€ï¼Œå¯åœ¨ç•Œé¢ä¸­é…ç½®
        let characterAttackInterval = 0.1;
        let characterDamageScale = 0.1;

        // å¹³å°å±æ€§é…ç½®
        let platformConfig = {
            heroCount: 0,        // å±€å¤–è‹±é›„æ•°é‡
            heroLevelSum: 0,      // å±€å¤–è‹±é›„ç­‰çº§å’Œ
            attackCoeff: 0,       // æ”»å‡»ç³»æ•°
            defenseCoeff: 0,      // é˜²å¾¡ç³»æ•°
            hpCoeff: 0            // ç”Ÿå‘½å€¼ç³»æ•°
        };

        // å¹³å°å±æ€§ï¼ˆè½¦è¾†ï¼‰é…ç½®
        let vehicleConfig = {
            attack: 0,           // è½¦è¾†æ”»å‡»åŠ›
            defense: 0,          // è½¦è¾†é˜²å¾¡åŠ›
            hp: 0                // è½¦è¾†ç”Ÿå‘½å€¼
        };

        // æˆ˜æ–—çŠ¶æ€
        let battleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            totalMonstersSpawned: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            char1NeverDies: false // æ ‡è®°è§’è‰²1æ˜¯å¦"å‡ ä¹ä¸ä¼šæ­»"ï¼ˆè¶…è¿‡200ç§’ä»å­˜æ´»ï¼‰
        };
        
        // æ— æµªè´¹æ¨¡å¼æˆ˜æ–—çŠ¶æ€ï¼ˆå‰©ä½™ä¼¤å®³ä¼ é€’ï¼‰
        let noWasteBattleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            totalMonstersSpawned: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            overflowDamage: 0 // æº¢å‡ºä¼¤å®³ï¼Œä¼šä¼ é€’åˆ°ä¸‹ä¸€åªæ€ªç‰©
        };

        // æ³¢æ¬¡æˆ˜æ–—çŠ¶æ€ï¼ˆç”¨äºå¯è§†åŒ–æ¨¡æ‹Ÿï¼‰
        let waveBattleState = {
            isRunning: false,
            startTime: null,
            elapsedTime: 0,
            characters: [],
            monsters: [],
            currentWave: 0, // å½“å‰æ³¢æ¬¡ï¼ˆ1-25ï¼‰
            currentStronghold: 0, // å½“å‰æ®ç‚¹ï¼ˆ1-5ï¼‰
            strongholdCompleted: {}, // å·²å®Œæˆçš„æ®ç‚¹ {1: true, 2: true, ...}
            waveStartTime: 0, // å½“å‰æ³¢æ¬¡å¼€å§‹æ—¶é—´
            waveSpawnedCount: 0, // å½“å‰æ³¢æ¬¡å·²å‡ºæ€ªç‰©æ•°
            waveTotalCount: 0, // å½“å‰æ³¢æ¬¡æ€»æ€ªç‰©æ•°
            nextSpawnTime: 0, // ä¸‹æ¬¡å‡ºæ€ªæ—¶é—´ï¼ˆä¿ç•™ç”¨äºå…¼å®¹ï¼Œå®é™…ä½¿ç”¨ç´¯è®¡æœºåˆ¶ï¼‰
            monsterIdCounter: 0,
            totalMonstersKilled: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            spawnAccumulator: 0, // æ€ªç‰©ç”Ÿæˆç´¯è®¡å€¼ï¼ˆç”¨äºå°æ•°ç”Ÿæˆç‡ï¼‰
            lastSpawnCheckTime: null // ä¸Šæ¬¡æ£€æŸ¥ç”Ÿæˆçš„æ—¶é—´
        };

        // åŠ è½½è‹±é›„è¡¨ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.loadHeroTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // æŸ¥æ‰¾heroå’Œherolevelé¡µç­¾
                    const heroSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'hero' || name.toLowerCase().includes('hero')
                    );
                    const heroLevelSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'herolevel' || name.toLowerCase().includes('herolevel')
                    );
                    
                    if (!heroSheetName) {
                        showMessage('æœªæ‰¾åˆ°heroé¡µç­¾', 'error');
                        return;
                    }
                    
                    // è¯»å–heroé¡µç­¾ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    const heroSheet = workbook.Sheets[heroSheetName];
                    const heroJsonData = XLSX.utils.sheet_to_json(heroSheet, { 
                        header: 1,  // ä½¿ç”¨æ•°ç»„æ ¼å¼ï¼Œä¿ç•™åŸå§‹è¡Œåˆ—ä¿¡æ¯
                        defval: ''   // ç©ºå•å…ƒæ ¼é»˜è®¤å€¼
                    });
                    
                    // è§£æèŒä¸š
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // å¦‚æœæ˜¯æ•°å­—ï¼Œç›´æ¥è½¬æ¢
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // å¦‚æœæ˜¯æ–‡æœ¬ï¼Œè½¬æ¢ä¸ºæ•°å­—
                        const textValue = String(heroclassValue).trim();
                        if (textValue === 'å¦å…‹' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === 'æˆ˜å£«' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === 'å°„æ‰‹' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === 'è¾…åŠ©' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // è§£æheroé¡µç­¾æ•°æ®ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    // Aåˆ—(ç´¢å¼•0): ä¸­æ–‡å, Båˆ—(ç´¢å¼•1): ID, Iåˆ—(ç´¢å¼•8): å“è´¨, Låˆ—(ç´¢å¼•11): èŒä¸š
                    const heroMap = new Map();
                    for (let i = 5; i < heroJsonData.length; i++) {
                        const row = heroJsonData[i];
                        if (!row || row.length === 0) continue;
                        
                        const id = String(row[1] || '').trim(); // Båˆ—
                        const namecn = String(row[0] || '').trim(); // Aåˆ—
                        const quality = parseInt(row[8]) || 1; // Iåˆ—ï¼Œå“è´¨ï¼ˆ1-6å¯¹åº”ç™½ã€ç»¿ã€è“ã€ç´«ã€æ©™ã€çº¢ï¼‰
                        const heroclass = parseHeroClass(row[11]); // Låˆ—
                        
                        // è·³è¿‡ç©ºè¡Œå’ŒIDä»¥119å¼€å¤´çš„æµ‹è¯•æ•°æ®
                        if (!id || id.startsWith('119')) continue;
                        if (!namecn) continue;
                        
                        heroMap.set(id, {
                            id: id,
                            namecn: namecn,
                            quality: quality, // å“è´¨ï¼ˆ1-6ï¼‰
                            heroclass: heroclass,
                            levels: {} // å­˜å‚¨å„ç­‰çº§å±æ€§
                        });
                    }
                    
                    // è¯»å–herolevelé¡µç­¾ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (heroLevelSheetName) {
                        const heroLevelSheet = workbook.Sheets[heroLevelSheetName];
                        const heroLevelJsonData = XLSX.utils.sheet_to_json(heroLevelSheet, {
                            header: 1,
                            defval: ''
                        });
                        
                        // è§£æå±æ€§å­—ç¬¦ä¸²ï¼šç”¨ç«–çº¿åˆ†å‰²ä¸åŒå±æ€§ï¼Œç”¨åˆ†å·åˆ†å‰²å±æ€§idå’Œå±æ€§å€¼
                        // æ ¼å¼ï¼šå±æ€§id;å±æ€§å€¼|å±æ€§id;å±æ€§å€¼
                        // ç¤ºä¾‹ï¼š102001;180|103001;50|101001;1400 è¡¨ç¤ºæ”»å‡»åŠ›180ï¼Œé˜²å¾¡åŠ›50ï¼Œç”Ÿå‘½å€¼1400
                        function parseAttributes(attrStr) {
                            if (!attrStr) return {};
                            
                            const result = {
                                baseAttack: 0,
                                baseDefense: 0,
                                baseHp: 0
                            };
                            
                            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶å»é™¤é¦–å°¾ç©ºæ ¼
                            const attrStrClean = String(attrStr).trim();
                            
                            if (!attrStrClean) return result;
                            
                            // ç”¨ç«–çº¿åˆ†å‰²ä¸åŒçš„å±æ€§
                            const attributes = attrStrClean.split('|');
                            
                            attributes.forEach(attr => {
                                const attrTrimmed = attr.trim();
                                if (!attrTrimmed) return;
                                
                                // ç”¨åˆ†å·åˆ†å‰²å±æ€§idå’Œå±æ€§å€¼
                                const parts = attrTrimmed.split(';').map(s => s.trim());
                                
                                if (parts.length >= 2) {
                                    const attrId = parts[0];
                                    const value = parts[1];
                                    
                                    if (attrId && value) {
                                        // å°†å±æ€§IDè½¬æ¢ä¸ºæ•°å­—ï¼ˆæ”¯æŒå­—ç¬¦ä¸²å’Œæ•°å­—æ ¼å¼ï¼‰
                                        const attrIdNum = parseInt(attrId);
                                        const numValue = parseFloat(value);
                                        
                                        if (!isNaN(numValue) && !isNaN(attrIdNum)) {
                                            // å±æ€§IDæ˜ å°„ï¼š102001=æ”»å‡»åŠ›ï¼Œ103001=é˜²å¾¡åŠ›ï¼Œ101001=ç”Ÿå‘½å€¼
                                            if (attrIdNum === 102001) {
                                                result.baseAttack = numValue;
                                            } else if (attrIdNum === 103001) {
                                                result.baseDefense = numValue;
                                            } else if (attrIdNum === 101001) {
                                                result.baseHp = numValue;
                                            }
                                        }
                                    }
                                }
                            });
                            
                            return result;
                        }
                        
                        // Cåˆ—(ç´¢å¼•2): è‹±é›„ID, Dåˆ—(ç´¢å¼•3): ç­‰çº§, Låˆ—(ç´¢å¼•11): å±æ€§å­—ç¬¦ä¸²
                        let parsedCount = 0;
                        for (let i = 0; i < heroLevelJsonData.length; i++) {
                            const row = heroLevelJsonData[i];
                            if (!row || row.length === 0) continue;
                            
                            const heroId = String(row[2] || '').trim(); // Cåˆ—
                            const level = parseInt(row[3] || 0); // Dåˆ—
                            const attributes = String(row[11] || '').trim(); // Låˆ—
                            
                            if (!heroId || !level || !attributes) continue;
                            
                            const hero = heroMap.get(heroId);
                            if (hero) {
                                const parsedAttrs = parseAttributes(attributes);
                                hero.levels[level] = parsedAttrs;
                                parsedCount++;
                                
                                // è°ƒè¯•ï¼šæ˜¾ç¤ºå‰å‡ æ¡è§£æç»“æœ
                                if (parsedCount <= 3) {
                                    console.log(`è§£æè‹±é›„ç­‰çº§å±æ€§ - ID: ${heroId}, ç­‰çº§: ${level}, åŸå§‹å­—ç¬¦ä¸²: "${attributes}", è§£æç»“æœ:`, parsedAttrs);
                                }
                            }
                        }
                        
                        if (parsedCount > 0) {
                            console.log(`æˆåŠŸè§£æ ${parsedCount} æ¡è‹±é›„ç­‰çº§å±æ€§æ•°æ®`);
                        }
                    }
                    
                    // è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼
                    heroTable = Array.from(heroMap.values());
                    
                    // ä¸ºæ¯ä¸ªè‹±é›„è®¡ç®—åŸºç¡€å±æ€§ï¼ˆä½¿ç”¨ç­‰çº§1çš„å±æ€§ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                    heroTable.forEach(hero => {
                        const level1Attrs = hero.levels[1] || {};
                        hero.baseAttack = level1Attrs.baseAttack || 0;
                        hero.baseDefense = level1Attrs.baseDefense || 0;
                        hero.baseHp = level1Attrs.baseHp || 0;
                    });

                    // ä¿å­˜åˆ°localStorageï¼ˆæ°¸ä¹…ä¿å­˜ï¼Œç›´åˆ°ä¸‹æ¬¡æ‰‹åŠ¨ä¸Šä¼ æ›¿æ¢ï¼‰
                    localStorage.setItem(HERO_STORAGE_KEY, JSON.stringify(heroTable));
                    console.log('è‹±é›„è¡¨å·²ä¿å­˜åˆ°æœ¬åœ°ï¼Œå…±', heroTable.length, 'ä¸ªè‹±é›„');
                    console.log('è‹±é›„è¡¨ç¤ºä¾‹ï¼ˆå‰3ä¸ªï¼‰:', heroTable.slice(0, 3).map(hero => ({
                        id: hero.id,
                        namecn: hero.namecn,
                        heroclass: hero.heroclass,
                        quality: hero.quality,
                        baseAttack: hero.baseAttack,
                        baseDefense: hero.baseDefense,
                        baseHp: hero.baseHp,
                        levelCount: Object.keys(hero.levels || {}).length
                    })));

                    // æ›´æ–°ç•Œé¢
                    updateHeroTableInfo();
                    // å¦‚æœç©å®¶ç»æµæ¨¡æ‹Ÿé¡µç­¾å·²æ‰“å¼€ï¼Œæ›´æ–°è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
                    const economyTab = document.getElementById('tab-economy');
                    if (economyTab && economyTab.classList.contains('active')) {
                        updateHeroSelects();
                        renderPlayerHeroes();
                    }
                    
                    showMessage(`æˆåŠŸåŠ è½½${heroTable.length}ä¸ªè‹±é›„ï¼Œå·²ä¿å­˜åˆ°æœ¬åœ°`, 'success');
                } catch (error) {
                    console.error('è¯»å–è‹±é›„è¡¨å¤±è´¥:', error);
                    showMessage('è¯»å–è‹±é›„è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // åŠ è½½æ€ªç‰©è¡¨ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.loadMonsterTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªé¡µç­¾ï¼ˆæˆ–monsteré¡µç­¾ï¼‰
                    const monsterSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'monster' || name.toLowerCase().includes('monster')
                    ) || workbook.SheetNames[0];
                    
                    if (!monsterSheetName) {
                        showMessage('æœªæ‰¾åˆ°æ€ªç‰©è¡¨é¡µç­¾', 'error');
                        return;
                    }
                    
                    // è¯»å–æ€ªç‰©è¡¨é¡µç­¾ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    const monsterSheet = workbook.Sheets[monsterSheetName];
                    const monsterJsonData = XLSX.utils.sheet_to_json(monsterSheet, { 
                        header: 1,  // ä½¿ç”¨æ•°ç»„æ ¼å¼ï¼Œä¿ç•™åŸå§‹è¡Œåˆ—ä¿¡æ¯
                        defval: ''   // ç©ºå•å…ƒæ ¼é»˜è®¤å€¼
                    });
                    
                    // è§£æå±æ€§å­—ç¬¦ä¸²ï¼šç”¨ç«–çº¿åˆ†å‰²ä¸åŒå±æ€§ï¼Œç”¨åˆ†å·åˆ†å‰²å±æ€§idå’Œå±æ€§å€¼
                    // æ ¼å¼ï¼šå±æ€§id;å±æ€§å€¼|å±æ€§id;å±æ€§å€¼
                    // ç¤ºä¾‹ï¼š102001;180|103001;50|101001;1400 è¡¨ç¤ºæ”»å‡»åŠ›180ï¼Œé˜²å¾¡åŠ›50ï¼Œç”Ÿå‘½å€¼1400
                    function parseMonsterAttributes(attrStr) {
                        if (!attrStr) return {};
                        
                        const result = {
                            baseAttack: 0,
                            baseDefense: 0,
                            baseHp: 0
                        };
                        
                        const attrStrClean = String(attrStr).trim();
                        if (!attrStrClean) return result;
                        
                        const attributes = attrStrClean.split('|');
                        attributes.forEach(attr => {
                            if (!attr.trim()) return;
                            const parts = attr.split(';').map(s => s.trim());
                            if (parts.length >= 2) {
                                const attrId = parts[0];
                                const value = parts[1];
                                if (attrId && value) {
                                    const numValue = parseFloat(value);
                                    if (!isNaN(numValue)) {
                                        const attrIdNum = parseInt(attrId);
                                        if (attrIdNum === 102001 || attrId === '102001') {
                                            result.baseAttack = numValue;
                                        } else if (attrIdNum === 103001 || attrId === '103001') {
                                            result.baseDefense = numValue;
                                        } else if (attrIdNum === 101001 || attrId === '101001') {
                                            result.baseHp = numValue;
                                        }
                                    }
                                }
                            }
                        });
                        return result;
                    }
                    
                    // è§£ææ€ªç‰©è¡¨æ•°æ®ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    // Båˆ—(ç´¢å¼•1): æ€ªç‰©ID, Dåˆ—(ç´¢å¼•3): å±æ€§å­—ç¬¦ä¸²
                    monsterTable = [];
                    for (let i = 5; i < monsterJsonData.length; i++) {
                        const row = monsterJsonData[i];
                        if (!row || row.length === 0) continue;
                        
                        const id = String(row[1] || '').trim(); // Båˆ—
                        const attrStr = String(row[3] || '').trim(); // Dåˆ—
                        
                        // è·³è¿‡ç©ºè¡Œ
                        if (!id) continue;
                        
                        // è§£æå±æ€§
                        const attrs = parseMonsterAttributes(attrStr);
                        
                        monsterTable.push({
                            id: id,
                            baseAttack: attrs.baseAttack || 0,
                            baseDefense: attrs.baseDefense || 0,
                            baseHp: attrs.baseHp || 0
                        });
                    }
                    
                    // ä¿å­˜åˆ°localStorage
                    localStorage.setItem(MONSTER_STORAGE_KEY, JSON.stringify(monsterTable));
                    console.log('æ€ªç‰©è¡¨å·²ä¿å­˜åˆ°æœ¬åœ°ï¼Œå…±', monsterTable.length, 'ä¸ªæ€ªç‰©');
                    console.log('æ€ªç‰©è¡¨ç¤ºä¾‹ï¼ˆå‰3ä¸ªï¼‰:', monsterTable.slice(0, 3));

                    // æ›´æ–°ç•Œé¢
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects(); // æ›´æ–°å…³å¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
                    updateBattleWaveMonsterSelects(); // æ›´æ–°æ³¢æ¬¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
                    
                    showMessage(`æˆåŠŸåŠ è½½${monsterTable.length}ä¸ªæ€ªç‰©ï¼Œå·²ä¿å­˜åˆ°æœ¬åœ°`, 'success');
                } catch (error) {
                    console.error('è¯»å–æ€ªç‰©è¡¨å¤±è´¥:', error);
                    showMessage('è¯»å–æ€ªç‰©è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // åŠ è½½æ­¦å™¨æŠ€èƒ½å‡çº§è¡¨ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.loadUpgradeTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // æŸ¥æ‰¾RogueWpnCostå’ŒRogueSkillCosté¡µç­¾
                    const weaponSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'roguewpncost' || name.toLowerCase().includes('roguewpncost')
                    );
                    const skillSheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'rogueskillcost' || name.toLowerCase().includes('rogueskillcost')
                    );
                    
                    if (!weaponSheetName) {
                        showMessage('æœªæ‰¾åˆ°RogueWpnCosté¡µç­¾', 'error');
                        return;
                    }
                    if (!skillSheetName) {
                        showMessage('æœªæ‰¾åˆ°RogueSkillCosté¡µç­¾', 'error');
                        return;
                    }
                    
                    // è¯»å–æ­¦å™¨å‡çº§è¡¨ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    const weaponSheet = workbook.Sheets[weaponSheetName];
                    const weaponJsonData = XLSX.utils.sheet_to_json(weaponSheet, { 
                        header: 1,
                        defval: '',
                        range: 5 // è·³è¿‡å‰5è¡Œ
                    });
                    
                    weaponCostTable = [];
                    console.log('=== æ­¦å™¨å‡çº§è¡¨è¯»å– ===');
                    weaponJsonData.forEach((row, index) => {
                        if (row.length >= 3) {
                            const level = parseInt(row[1]) || 0; // Båˆ—ï¼šç¬¬å‡ æ¬¡è´­ä¹°ï¼ˆä»0å¼€å§‹ï¼‰
                            const cost = parseFloat(row[2]) || 0; // Cåˆ—ï¼šé“¶å¸æ¶ˆè€—
                            const rawEValue = row[4]; // Eåˆ—åŸå§‹å€¼
                            const damageCoeff = parseFloat(row[4]) || 1; // Eåˆ—ï¼šæ­¦å™¨ä¼¤å®³ç³»æ•°
                            
                            // è¾“å‡ºè¯»å–çš„å†…å®¹
                            console.log(`è¡Œ${index + 6} (è·³è¿‡5è¡Œè¡¨å¤´): ç­‰çº§=${level}, æ¶ˆè€—=${cost}, Eåˆ—åŸå§‹å€¼=${rawEValue}, ä¼¤å®³ç³»æ•°=${damageCoeff}`);
                            
                            if (!isNaN(level) && !isNaN(cost)) {
                                weaponCostTable.push({ level, cost, damageCoeff });
                            }
                        }
                    });
                    console.log(`æ€»å…±è¯»å– ${weaponCostTable.length} æ¡æ­¦å™¨å‡çº§æ•°æ®`);
                    console.log('æ­¦å™¨å‡çº§è¡¨å†…å®¹:', weaponCostTable);
                    
                    // è¯»å–æŠ€èƒ½å‡çº§è¡¨ï¼ˆè·³è¿‡å‰5è¡Œè¡¨å¤´ï¼‰
                    const skillSheet = workbook.Sheets[skillSheetName];
                    const skillJsonData = XLSX.utils.sheet_to_json(skillSheet, { 
                        header: 1,
                        defval: '',
                        range: 5 // è·³è¿‡å‰5è¡Œ
                    });
                    
                    skillCostTable = [];
                    console.log('=== æŠ€èƒ½å‡çº§è¡¨è¯»å– ===');
                    skillJsonData.forEach((row, index) => {
                        if (row.length >= 3) {
                            const level = parseInt(row[1]) || 0; // Båˆ—ï¼šç¬¬å‡ æ¬¡è´­ä¹°ï¼ˆä»0å¼€å§‹ï¼‰
                            const cost = parseFloat(row[2]) || 0; // Cåˆ—ï¼šé“¶å¸æ¶ˆè€—
                            const rawEValue = row[4]; // Eåˆ—åŸå§‹å€¼
                            const damageCoeff = parseFloat(row[4]) || 1; // Eåˆ—ï¼šæŠ€èƒ½å‡çº§ä¼¤å®³ç³»æ•°
                            
                            // è¾“å‡ºè¯»å–çš„å†…å®¹
                            console.log(`è¡Œ${index + 6} (è·³è¿‡5è¡Œè¡¨å¤´): ç­‰çº§=${level}, æ¶ˆè€—=${cost}, Eåˆ—åŸå§‹å€¼=${rawEValue}, ä¼¤å®³ç³»æ•°=${damageCoeff}`);
                            
                            if (!isNaN(level) && !isNaN(cost)) {
                                skillCostTable.push({ level, cost, damageCoeff });
                            }
                        }
                    });
                    console.log(`æ€»å…±è¯»å– ${skillCostTable.length} æ¡æŠ€èƒ½å‡çº§æ•°æ®`);
                    console.log('æŠ€èƒ½å‡çº§è¡¨å†…å®¹:', skillCostTable);
                    
                    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                    localStorage.setItem('weaponCostTable', JSON.stringify(weaponCostTable));
                    localStorage.setItem('skillCostTable', JSON.stringify(skillCostTable));
                    
                    // æ›´æ–°æ˜¾ç¤º
                    updateUpgradeTableInfo();
                    
                    showMessage(`æˆåŠŸåŠ è½½æ­¦å™¨å‡çº§è¡¨ï¼ˆ${weaponCostTable.length}æ¡ï¼‰å’ŒæŠ€èƒ½å‡çº§è¡¨ï¼ˆ${skillCostTable.length}æ¡ï¼‰`, 'success');
                } catch (error) {
                    console.error('åŠ è½½å‡çº§è¡¨å¤±è´¥:', error);
                    showMessage('åŠ è½½å‡çº§è¡¨å¤±è´¥: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // åŠ è½½ä¿å­˜çš„å‡çº§è¡¨
        function loadSavedUpgradeTable() {
            try {
                const savedWeaponTable = localStorage.getItem('weaponCostTable');
                const savedSkillTable = localStorage.getItem('skillCostTable');
                
                if (savedWeaponTable) {
                    weaponCostTable = JSON.parse(savedWeaponTable);
                }
                if (savedSkillTable) {
                    skillCostTable = JSON.parse(savedSkillTable);
                }
                
                if (weaponCostTable.length > 0 || skillCostTable.length > 0) {
                    updateUpgradeTableInfo();
                }
            } catch (error) {
                console.error('åŠ è½½ä¿å­˜çš„å‡çº§è¡¨å¤±è´¥:', error);
            }
        }

        // æ›´æ–°å‡çº§è¡¨ä¿¡æ¯æ˜¾ç¤º
        function updateUpgradeTableInfo() {
            const statusEl = document.getElementById('upgradeTableStatus');
            const infoEl = document.getElementById('upgradeTableInfo');
            
            if (weaponCostTable.length > 0 || skillCostTable.length > 0) {
                statusEl.textContent = `å·²åŠ è½½æ­¦å™¨è¡¨ï¼ˆ${weaponCostTable.length}æ¡ï¼‰å’ŒæŠ€èƒ½è¡¨ï¼ˆ${skillCostTable.length}æ¡ï¼‰`;
                statusEl.style.color = '#51cf66';
                
                let infoText = `æ­¦å™¨å‡çº§è¡¨: ${weaponCostTable.length}æ¡è®°å½•`;
                if (weaponCostTable.length > 0) {
                    const maxLevel = Math.max(...weaponCostTable.map(w => w.level));
                    const maxCost = Math.max(...weaponCostTable.map(w => w.cost));
                    infoText += ` | æœ€é«˜ç­‰çº§: ${maxLevel}, æœ€é«˜æ¶ˆè€—: ${maxCost}`;
                    
                    // æ˜¾ç¤ºæ­¦å™¨ç³»æ•°è¯¦æƒ…
                    infoText += `<br><br><strong>æ­¦å™¨ç³»æ•°è¯¦æƒ…ï¼ˆä»Eåˆ—è¯»å–ï¼‰ï¼š</strong><br>`;
                    weaponCostTable.sort((a, b) => a.level - b.level).forEach(weapon => {
                        const coeff = (weapon.damageCoeff !== undefined) ? parseFloat(weapon.damageCoeff) : 1.0;
                        infoText += `ç­‰çº§ ${weapon.level}: æ¶ˆè€— ${weapon.cost} é“¶å¸, ä¼¤å®³ç³»æ•° ${coeff.toFixed(2)}<br>`;
                    });
                }
                infoText += `<br><br>æŠ€èƒ½å‡çº§è¡¨: ${skillCostTable.length}æ¡è®°å½•`;
                if (skillCostTable.length > 0) {
                    const maxLevel = Math.max(...skillCostTable.map(s => s.level));
                    const maxCost = Math.max(...skillCostTable.map(s => s.cost));
                    infoText += ` | æœ€é«˜ç­‰çº§: ${maxLevel}, æœ€é«˜æ¶ˆè€—: ${maxCost}`;
                    
                    // æ˜¾ç¤ºæŠ€èƒ½ç³»æ•°è¯¦æƒ…
                    infoText += `<br><br><strong>æŠ€èƒ½ç³»æ•°è¯¦æƒ…ï¼ˆä»Eåˆ—è¯»å–ï¼‰ï¼š</strong><br>`;
                    skillCostTable.sort((a, b) => a.level - b.level).forEach(skill => {
                        const coeff = (skill.damageCoeff !== undefined) ? parseFloat(skill.damageCoeff) : 1.0;
                        infoText += `ç­‰çº§ ${skill.level}: æ¶ˆè€— ${skill.cost} é“¶å¸, ä¼¤å®³ç³»æ•° ${coeff.toFixed(2)}<br>`;
                    });
                }
                
                // æ›´æ–°æ­¦å™¨å‡çº§ç³»æ•°æŸ¥çœ‹å™¨çš„ä¸‹æ‹‰é€‰é¡¹
                updateWeaponLevelViewerOptions();
                
                infoEl.innerHTML = infoText;
            } else {
                statusEl.textContent = 'æœªåŠ è½½å‡çº§è¡¨';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
            }
        }
        
        // æ›´æ–°æ­¦å™¨å‡çº§æ¬¡æ•°ä¸‹æ‹‰é€‰é¡¹
        function updateWeaponLevelViewerOptions() {
            const selectEl = document.getElementById('weaponLevelViewer');
            if (!selectEl) return;
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™"è¯·é€‰æ‹©"ï¼‰
            selectEl.innerHTML = '<option value="-1">è¯·é€‰æ‹©</option>';
            
            if (weaponCostTable.length > 0) {
                // æŒ‰ç­‰çº§æ’åº
                const sortedTable = [...weaponCostTable].sort((a, b) => a.level - b.level);
                sortedTable.forEach(weapon => {
                    const option = document.createElement('option');
                    option.value = weapon.level;
                    option.textContent = `å‡çº§æ¬¡æ•° ${weapon.level}`;
                    selectEl.appendChild(option);
                });
            }
        }
        
        // æ›´æ–°æ­¦å™¨å‡çº§ç³»æ•°æŸ¥çœ‹å™¨æ˜¾ç¤º
        window.updateWeaponCoeffViewer = function() {
            const selectEl = document.getElementById('weaponLevelViewer');
            const infoEl = document.getElementById('weaponCoeffInfo');
            const levelView = document.getElementById('currentWeaponLevelView');
            const coeffView = document.getElementById('currentWeaponCoeffView');
            const costView = document.getElementById('weaponUpgradeCostView');
            const ratioView = document.getElementById('weaponUpgradeRatioView');
            
            if (!selectEl || !infoEl) return;
            
            const selectedLevel = parseInt(selectEl.value);
            if (selectedLevel === -1) {
                infoEl.style.display = 'none';
                return;
            }
            
            // æŸ¥æ‰¾å½“å‰ç­‰çº§çš„æ•°æ®
            const currentWeaponData = weaponCostTable.find(w => w.level === selectedLevel);
            if (!currentWeaponData) {
                infoEl.style.display = 'none';
                return;
            }
            
            // æŸ¥æ‰¾ä¸‹ä¸€çº§çš„æ•°æ®
            const nextWeaponData = weaponCostTable.find(w => w.level === selectedLevel + 1);
            
            // è·å–å½“å‰å’Œä¸‹ä¸€çº§çš„ä¼¤å®³ç³»æ•°
            const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            const nextCoeff = (nextWeaponData && nextWeaponData.damageCoeff !== undefined) ? parseFloat(nextWeaponData.damageCoeff) : currentCoeff;
            const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
            const upgradePercent = ((upgradeRatio - 1) * 100).toFixed(1);
            
            // æ›´æ–°æ˜¾ç¤º
            if (levelView) levelView.textContent = `Lv.${selectedLevel}`;
            if (coeffView) coeffView.textContent = currentCoeff.toFixed(2);
            if (costView) costView.textContent = `${currentWeaponData.cost} é“¶å¸`;
            if (ratioView) {
                if (nextWeaponData) {
                    ratioView.textContent = `${upgradeRatio.toFixed(3)} (æå‡ ${upgradePercent > 0 ? '+' : ''}${upgradePercent}%)`;
                    ratioView.style.color = upgradePercent > 0 ? '#51cf66' : '#ff6b6b';
                } else {
                    ratioView.textContent = 'å·²è¾¾æœ€é«˜ç­‰çº§';
                    ratioView.style.color = '#999';
                }
            }
            
            infoEl.style.display = 'block';
        };

        // æ›´æ–°æ€ªç‰©è¡¨ä¿¡æ¯æ˜¾ç¤º
        function updateMonsterTableInfo() {
            const statusEl = document.getElementById('monsterTableStatus');
            const infoEl = document.getElementById('monsterTableInfo');
            
            if (monsterTable.length > 0) {
                statusEl.textContent = `å·²åŠ è½½ ${monsterTable.length} ä¸ªæ€ªç‰©ï¼ˆå·²ä¿å­˜åˆ°æœ¬åœ°ï¼‰`;
                statusEl.style.color = '#51cf66';
                
                // ç»Ÿè®¡å±æ€§èŒƒå›´
                const attacks = monsterTable.map(m => m.baseAttack).filter(a => a > 0);
                const defenses = monsterTable.map(m => m.baseDefense).filter(d => d > 0);
                const hps = monsterTable.map(m => m.baseHp).filter(h => h > 0);
                
                let infoText = `æ€ªç‰©æ•°é‡: ${monsterTable.length}`;
                if (attacks.length > 0) {
                    infoText += ` | æ”»å‡»åŠ›èŒƒå›´: ${Math.min(...attacks)} - ${Math.max(...attacks)}`;
                }
                if (defenses.length > 0) {
                    infoText += ` | é˜²å¾¡åŠ›èŒƒå›´: ${Math.min(...defenses)} - ${Math.max(...defenses)}`;
                }
                if (hps.length > 0) {
                    infoText += ` | ç”Ÿå‘½å€¼èŒƒå›´: ${Math.min(...hps)} - ${Math.max(...hps)}`;
                }
                
                infoEl.textContent = infoText;
            } else {
                statusEl.textContent = 'æœªåŠ è½½æ€ªç‰©è¡¨';
                statusEl.style.color = '#666';
                infoEl.textContent = '';
            }
        }

        // æ›´æ–°æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateMonsterSelect() {
            const monsterSelect = document.getElementById('monsterSelect');
            if (!monsterSelect) return;
            
            monsterSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ€ªç‰©</option>';
            
            if (monsterTable.length === 0) {
                monsterSelect.innerHTML = '<option value="">è¯·å…ˆä¸Šä¼ æ€ªç‰©è¡¨</option>';
                return;
            }
            
            // æŒ‰IDæ’åº
            const sortedMonsters = [...monsterTable].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedMonsters.forEach(monster => {
                const option = document.createElement('option');
                option.value = monster.id;
                option.textContent = `æ€ªç‰© #${monster.id} (æ”»å‡»${monster.baseAttack} é˜²å¾¡${monster.baseDefense} ç”Ÿå‘½${monster.baseHp})`;
                monsterSelect.appendChild(option);
            });
        }

        // æ›´æ–°æ€ªç‰©å±æ€§æ˜¾ç¤ºï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateMonsterAttributes = function() {
            const monsterSelect = document.getElementById('monsterSelect');
            const attributesDisplay = document.getElementById('monsterAttributesDisplay');
            const monsterDisplayName = document.getElementById('monsterDisplayName');
            const monsterAttrAttack = document.getElementById('monsterAttrAttack');
            const monsterAttrDefense = document.getElementById('monsterAttrDefense');
            const monsterAttrHp = document.getElementById('monsterAttrHp');
            const monsterAttrInfo = document.getElementById('monsterAttrInfo');
            
            if (!monsterSelect || !attributesDisplay) return;
            
            const selectedMonsterId = monsterSelect.value;
            
            if (!selectedMonsterId) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            const monster = monsterTable.find(m => m.id === selectedMonsterId);
            if (!monster) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            // æ˜¾ç¤ºæ€ªç‰©ä¿¡æ¯
            monsterDisplayName.textContent = `æ€ªç‰© #${monster.id}`;
            monsterAttrAttack.textContent = monster.baseAttack || 0;
            monsterAttrDefense.textContent = monster.baseDefense || 0;
            monsterAttrHp.textContent = monster.baseHp || 0;
            
            // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            let infoText = `æ€ªç‰©ID: ${monster.id}`;
            if (monster.baseAttack > 0) {
                infoText += ` | æ”»å‡»åŠ›: ${monster.baseAttack}`;
            }
            if (monster.baseDefense > 0) {
                infoText += ` | é˜²å¾¡åŠ›: ${monster.baseDefense}`;
            }
            if (monster.baseHp > 0) {
                infoText += ` | ç”Ÿå‘½å€¼: ${monster.baseHp}`;
            }
            monsterAttrInfo.textContent = infoText;
            
            attributesDisplay.style.display = 'block';
        };

        // æ›´æ–°è‹±é›„è¡¨ä¿¡æ¯æ˜¾ç¤º
        function updateHeroTableInfo() {
            const statusEl = document.getElementById('heroTableStatus');
            const infoEl = document.getElementById('heroTableInfo');
            
            if (heroTable.length > 0) {
                statusEl.textContent = `å·²åŠ è½½ ${heroTable.length} ä¸ªè‹±é›„ï¼ˆå·²ä¿å­˜åˆ°æœ¬åœ°ï¼‰`;
                statusEl.style.color = '#51cf66';
                
                // æŒ‰èŒä¸šç»Ÿè®¡è‹±é›„æ•°é‡
                const statsByJob = {};
                let totalLevels = 0;
                let heroesWithLevels = 0;
                
                heroTable.forEach(hero => {
                    const jobId = parseInt(hero.heroclass) || 0;
                    const jobName = JOB_NAMES[jobId] || 'æœªçŸ¥';
                    if (!statsByJob[jobName]) {
                        statsByJob[jobName] = 0;
                    }
                    statsByJob[jobName]++;
                    
                    // ç»Ÿè®¡ç­‰çº§æ•°æ®
                    if (hero.levels && Object.keys(hero.levels).length > 0) {
                        totalLevels += Object.keys(hero.levels).length;
                        heroesWithLevels++;
                    }
                });
                
                const statsText = Object.keys(statsByJob).map(job => {
                    const count = statsByJob[job];
                    return `${job}:${count}ä¸ª`;
                }).join('ï¼›');
                
                let levelInfo = '';
                if (heroesWithLevels > 0) {
                    levelInfo = `<div style="margin-top: 5px;">ç­‰çº§æ•°æ®ï¼š${heroesWithLevels}ä¸ªè‹±é›„æœ‰ç­‰çº§æ•°æ®ï¼Œå…±${totalLevels}æ¡è®°å½•</div>`;
                }
                
                infoEl.innerHTML = `<div style="margin-top: 5px;">è‹±é›„ç»Ÿè®¡ï¼š${statsText}</div>${levelInfo}`;
                
                // æ›´æ–°è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
                updateHeroSelect();
                
                // æ›´æ–°æ‰€æœ‰è§’è‰²çš„è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
                updateAllCharacterHeroSelects();
            } else {
                statusEl.textContent = 'æœªåŠ è½½è‹±é›„è¡¨';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
                
                // æ¸…ç©ºè‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
                const heroSelect = document.getElementById('heroSelect');
                if (heroSelect) {
                    heroSelect.innerHTML = '<option value="">è¯·å…ˆä¸Šä¼ è‹±é›„è¡¨</option>';
                }
            }
        }

        // æ›´æ–°è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateHeroSelect() {
            const heroSelect = document.getElementById('heroSelect');
            if (!heroSelect) return;
            
            heroSelect.innerHTML = '<option value="">è¯·é€‰æ‹©è‹±é›„</option>';
            
            if (heroTable.length === 0) {
                heroSelect.innerHTML = '<option value="">è¯·å…ˆä¸Šä¼ è‹±é›„è¡¨</option>';
                return;
            }
            
            // æŒ‰IDæ’åº
            const sortedHeroes = [...heroTable].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedHeroes.forEach(hero => {
                const jobName = JOB_NAMES[hero.heroclass] || 'æœªçŸ¥';
                const option = document.createElement('option');
                option.value = hero.id;
                option.textContent = `${hero.id} - ${hero.namecn} [${jobName}]${hero.quality ? ' - ' + hero.quality : ''}`;
                heroSelect.appendChild(option);
            });
        }

        // æ›´æ–°è‹±é›„ç­‰çº§é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateHeroLevelSelect = function() {
            const heroSelect = document.getElementById('heroSelect');
            const levelSelect = document.getElementById('heroLevelSelect');
            const attributesDisplay = document.getElementById('heroAttributesDisplay');
            
            if (!heroSelect || !levelSelect) return;
            
            const selectedHeroId = heroSelect.value;
            levelSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ç­‰çº§</option>';
            if (attributesDisplay) {
                attributesDisplay.style.display = 'none';
            }
            
            if (!selectedHeroId) {
                levelSelect.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©è‹±é›„</option>';
                return;
            }
            
            const hero = heroTable.find(h => h.id === selectedHeroId);
            if (!hero) return;
            
            // è·å–è¯¥è‹±é›„çš„æ‰€æœ‰ç­‰çº§
            const levels = hero.levels ? Object.keys(hero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
            
            if (levels.length === 0) {
                levelSelect.innerHTML = '<option value="">è¯¥è‹±é›„æš‚æ— ç­‰çº§æ•°æ®</option>';
                return;
            }
            
            levels.forEach(level => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `ç­‰çº§ ${level}`;
                levelSelect.appendChild(option);
            });
            
            // è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªç­‰çº§å¹¶æ˜¾ç¤ºå±æ€§
            if (levels.length > 0) {
                levelSelect.value = levels[0];
                updateHeroAttributes();
            }
        }

        // æ›´æ–°è‹±é›„å±æ€§æ˜¾ç¤ºï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateHeroAttributes = function() {
            const heroSelect = document.getElementById('heroSelect');
            const levelSelect = document.getElementById('heroLevelSelect');
            const attributesDisplay = document.getElementById('heroAttributesDisplay');
            const heroDisplayName = document.getElementById('heroDisplayName');
            const heroAttrAttack = document.getElementById('heroAttrAttack');
            const heroAttrDefense = document.getElementById('heroAttrDefense');
            const heroAttrHp = document.getElementById('heroAttrHp');
            const heroAttrInfo = document.getElementById('heroAttrInfo');
            
            if (!heroSelect || !levelSelect || !attributesDisplay) return;
            
            const selectedHeroId = heroSelect.value;
            const selectedLevel = parseInt(levelSelect.value);
            
            if (!selectedHeroId || !selectedLevel) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            const hero = heroTable.find(h => h.id === selectedHeroId);
            if (!hero) {
                attributesDisplay.style.display = 'none';
                return;
            }
            
            // è·å–è¯¥ç­‰çº§çš„å±æ€§
            const levelAttrs = hero.levels && hero.levels[selectedLevel] ? hero.levels[selectedLevel] : {};
            
            // è°ƒè¯•ï¼šæ˜¾ç¤ºè‹±é›„ç­‰çº§æ•°æ®
            console.log(`æŸ¥çœ‹è‹±é›„å±æ€§ - ID: ${selectedHeroId}, ç­‰çº§: ${selectedLevel}`, {
                hero: hero,
                hasLevels: !!hero.levels,
                levelKeys: hero.levels ? Object.keys(hero.levels) : [],
                currentLevelAttrs: levelAttrs
            });
            
            // è®¡ç®—ç´¯è®¡å±æ€§ï¼ˆä»ç­‰çº§1åˆ°å½“å‰ç­‰çº§ï¼‰
            let totalAttack = 0;
            let totalDefense = 0;
            let totalHp = 0;
            
            for (let level = 1; level <= selectedLevel; level++) {
                if (hero.levels && hero.levels[level]) {
                    const levelData = hero.levels[level];
                    totalAttack += (levelData.baseAttack || 0);
                    totalDefense += (levelData.baseDefense || 0);
                    totalHp += (levelData.baseHp || 0);
                    
                    // è°ƒè¯•ï¼šæ˜¾ç¤ºæ¯çº§å±æ€§
                    if (level <= 3) {
                        console.log(`ç­‰çº§ ${level} å±æ€§:`, levelData);
                    }
                }
            }
            
            console.log(`ç´¯è®¡å±æ€§ï¼ˆ1-${selectedLevel}çº§ï¼‰:`, { totalAttack, totalDefense, totalHp });
            
            // æ˜¾ç¤ºè‹±é›„ä¿¡æ¯
            const jobName = JOB_NAMES[hero.heroclass] || 'æœªçŸ¥';
            if (heroDisplayName) {
                heroDisplayName.textContent = `${hero.namecn} [${jobName}] - ç­‰çº§ ${selectedLevel}`;
            }
            
            // æ˜¾ç¤ºå±æ€§å€¼
            if (heroAttrAttack) {
                heroAttrAttack.textContent = totalAttack > 0 ? totalAttack.toLocaleString() : '-';
            }
            if (heroAttrDefense) {
                heroAttrDefense.textContent = totalDefense > 0 ? totalDefense.toLocaleString() : '-';
            }
            if (heroAttrHp) {
                heroAttrHp.textContent = totalHp > 0 ? totalHp.toLocaleString() : '-';
            }
            
            // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            if (heroAttrInfo) {
                const levelAttrsText = levelAttrs.baseAttack || levelAttrs.baseDefense || levelAttrs.baseHp 
                    ? `æœ¬çº§å±æ€§ï¼š${levelAttrs.baseAttack || 0} æ”»å‡» / ${levelAttrs.baseDefense || 0} é˜²å¾¡ / ${levelAttrs.baseHp || 0} ç”Ÿå‘½`
                    : 'æœ¬çº§æ— å±æ€§æ•°æ®';
                heroAttrInfo.innerHTML = `
                    <div>è‹±é›„ID: ${hero.id}</div>
                    <div style="margin-top: 5px;">${levelAttrsText}</div>
                    <div style="margin-top: 5px;">ç´¯è®¡å±æ€§ï¼ˆ1-${selectedLevel}çº§ï¼‰: ${totalAttack} æ”»å‡» / ${totalDefense} é˜²å¾¡ / ${totalHp} ç”Ÿå‘½</div>
                `;
            }
            
            // æ˜¾ç¤ºå±æ€§é¢æ¿
            attributesDisplay.style.display = 'block';
        }

        // è§£æ attribute åˆ—å­—ç¬¦ä¸²ï¼š101001;560|103001;24| æ ¼å¼
        // 101001=ç”Ÿå‘½å€¼(hp)ï¼Œ102001=æ”»å‡»åŠ›(atk)ï¼Œ103001=é˜²å¾¡åŠ›(def)
        function parseAttributeColumn(str) {
            const result = { hp: 0, atk: 0, def: 0 };
            if (!str || typeof str !== 'string') return result;
            const raw = String(str).trim();
            if (!raw) return result;
            const pairs = raw.split('|').map(s => s.trim()).filter(Boolean);
            for (const p of pairs) {
                const seg = p.split(';').map(s => s.trim());
                if (seg.length < 2) continue;
                const attrId = String(seg[0]).trim();
                const val = parseFloat(seg[1]);
                if (isNaN(val)) continue;
                if (attrId === '101001') result.hp = val;
                else if (attrId === '102001') result.atk = val;
                else if (attrId === '103001') result.def = val;
            }
            return result;
        }

        // åŠ è½½è£…å¤‡è¡¨ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        // è¡¨å¤´ 5 è¡Œï¼›æ”»/é˜²/è¡€ä»ç¬¬ä¸€è¡Œä¸º attribute çš„åˆ—è§£æï¼Œæ ¼å¼ 101001;560|103001;24|
        window.loadEquipmentTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const rawRows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    
                    if (!rawRows || rawRows.length < 6) {
                        showMessage('è£…å¤‡è¡¨è¡Œæ•°ä¸è¶³ï¼ˆè‡³å°‘ 5 è¡Œè¡¨å¤´ + 1 è¡Œæ•°æ®ï¼‰', 'error');
                        return;
                    }
                    
                    // è¡¨å¤´ 5 è¡Œ
                    // ç¬¬ä¸€è¡Œï¼ˆrow 0ï¼‰ç”¨æ¥å®šä½ type åˆ—å’Œ attribute åˆ—
                    // åç§°ä»Påˆ—ï¼ˆç´¢å¼•15ï¼‰è¯»å–
                    const headerRow0 = rawRows[0] || [];
                    let colId = -1, colNamecn = -1, colHeroclass = -1, colType = -1, colAttribute = -1, colQuality = -1;
                    
                    // åç§°å›ºå®šä»Påˆ—ï¼ˆç´¢å¼•15ï¼‰è¯»å–
                    colNamecn = 15;
                    
                    // ä»ç¬¬ä¸€è¡Œæ‰¾ type å’Œ attribute
                    for (let i = 0; i < headerRow0.length; i++) {
                        const cell = String(headerRow0[i] || '').trim().toLowerCase();
                        if (cell === 'id') colId = i;
                        else if (cell === 'heroclass' || cell === 'hero_class' || cell === 'èŒä¸š' || cell === 'class' || cell === 'job') colHeroclass = i;
                        else if (cell === 'type' || cell === 'éƒ¨ä½') colType = i;
                        else if (cell === 'attribute') colAttribute = i;
                        else if (cell === 'quality' || cell === 'å“è´¨') colQuality = i;
                    }
                    
                    if (colAttribute < 0) {
                        showMessage('è£…å¤‡è¡¨ç¬¬ä¸€è¡Œæœªæ‰¾åˆ° attribute åˆ—', 'error');
                        return;
                    }
                    
                    // è½¬æ¢éƒ¨ä½ï¼š1=å¤´ï¼Œ2=èº«ï¼Œ3=æ‰‹ï¼Œ4=è„š
                    function parseEquipmentType(typeValue) {
                        if (typeValue == null || typeValue === '') return '';
                        const num = parseInt(typeValue);
                        if (!isNaN(num)) {
                            if (num === 1) return 'å¤´';
                            if (num === 2) return 'èº«';
                            if (num === 3) return 'æ‰‹';
                            if (num === 4) return 'è„š';
                        }
                        // å…¼å®¹æ–‡æœ¬æ ¼å¼
                        const text = String(typeValue).trim().toLowerCase();
                        if (text === 'å¤´' || text === 'head') return 'å¤´';
                        if (text === 'èº«' || text === 'body') return 'èº«';
                        if (text === 'æ‰‹' || text === 'hand') return 'æ‰‹';
                        if (text === 'è„š' || text === 'foot') return 'è„š';
                        return String(typeValue).trim();
                    }
                    
                    // ä»è£…å¤‡IDåˆ†æéƒ¨ä½ä¿¡æ¯
                    // IDæ ¼å¼å¯èƒ½å¦‚ï¼š13111001ï¼Œå…¶ä¸­æŸä½å¯èƒ½è¡¨ç¤ºéƒ¨ä½
                    function parseTypeFromId(idStr) {
                        if (!idStr || typeof idStr !== 'string') return '';
                        const id = String(idStr).trim();
                        // å¦‚æœIDé•¿åº¦è¶³å¤Ÿï¼Œå°è¯•ä»ç‰¹å®šä½ç½®è§£æéƒ¨ä½
                        // å¸¸è§æ ¼å¼ï¼š13111001ï¼Œå¯èƒ½ç¬¬4ä½æˆ–ç¬¬5ä½è¡¨ç¤ºéƒ¨ä½ï¼ˆ1=å¤´ï¼Œ2=èº«ï¼Œ3=æ‰‹ï¼Œ4=è„šï¼‰
                        if (id.length >= 4) {
                            // å°è¯•ç¬¬4ä½ï¼ˆç´¢å¼•3ï¼‰
                            const pos4 = parseInt(id[3]);
                            if (!isNaN(pos4) && pos4 >= 1 && pos4 <= 4) {
                                if (pos4 === 1) return 'å¤´';
                                if (pos4 === 2) return 'èº«';
                                if (pos4 === 3) return 'æ‰‹';
                                if (pos4 === 4) return 'è„š';
                            }
                        }
                        if (id.length >= 5) {
                            // å°è¯•ç¬¬5ä½ï¼ˆç´¢å¼•4ï¼‰
                            const pos5 = parseInt(id[4]);
                            if (!isNaN(pos5) && pos5 >= 1 && pos5 <= 4) {
                                if (pos5 === 1) return 'å¤´';
                                if (pos5 === 2) return 'èº«';
                                if (pos5 === 3) return 'æ‰‹';
                                if (pos5 === 4) return 'è„š';
                            }
                        }
                        return '';
                    }

                    function parseHeroClass(heroclassValue) {
                        if (heroclassValue == null || heroclassValue === '') return 0;
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) return numValue;
                        const textValue = String(heroclassValue).trim().toLowerCase();
                        if (textValue === 'å¦å…‹' || textValue === 'tank' || textValue === '1') return 1;
                        if (textValue === 'æˆ˜å£«' || textValue === 'warrior' || textValue === '2') return 2;
                        if (textValue === 'å°„æ‰‹' || textValue === 'archer' || textValue === '3') return 3;
                        if (textValue === 'è¾…åŠ©' || textValue === 'support' || textValue === '4') return 4;
                        return 0;
                    }
                    
                    const dataRows = rawRows.slice(5);
                    equipmentTable = dataRows.map((row, index) => {
                        const id = (colId >= 0 && row[colId] != null && row[colId] !== '') 
                            ? String(row[colId]).trim() 
                            : `eq_${index + 1}`;
                        const namecn = (colNamecn >= 0 && row[colNamecn] != null && row[colNamecn] !== '') 
                            ? String(row[colNamecn]).trim() 
                            : `è£…å¤‡${index + 1}`;
                        
                        let heroclass = parseHeroClass(colHeroclass >= 0 ? row[colHeroclass] : null);
                        if (heroclass === 0 && namecn) {
                            const nameStr = String(namecn).trim();
                            if (nameStr.includes('å¦å…‹')) heroclass = 1;
                            else if (nameStr.includes('æˆ˜å£«')) heroclass = 2;
                            else if (nameStr.includes('å°„æ‰‹')) heroclass = 3;
                            else if (nameStr.includes('è¾…åŠ©')) heroclass = 4;
                        }
                        if (heroclass === 0 && id) {
                            const idStr = String(id).trim();
                            if (idStr.length >= 3) {
                                const third = parseInt(idStr[2]);
                                if (third >= 1 && third <= 4) heroclass = third;
                            }
                        }
                        
                        // å…ˆå°è¯•ä»typeåˆ—è¯»å–ï¼Œå¦‚æœå–ä¸åˆ°å€¼åˆ™ä»IDåˆ†æ
                        let type = '';
                        if (colType >= 0 && row[colType] != null && row[colType] !== '') {
                            type = parseEquipmentType(row[colType]);
                        }
                        // å¦‚æœtypeåˆ—å–ä¸åˆ°å€¼ï¼Œä»IDåˆ†æ
                        if (!type && id) {
                            type = parseTypeFromId(id);
                        }
                        const attr = parseAttributeColumn(colAttribute >= 0 ? row[colAttribute] : '');
                        const quality = (colQuality >= 0 && row[colQuality] != null) 
                            ? (parseInt(row[colQuality]) || 1) 
                            : 1;
                        
                        return {
                            id: id.toString(),
                            namecn: namecn,
                            heroclass: heroclass,
                            type: type,
                            hp: attr.hp,
                            atk: attr.atk,
                            def: attr.def,
                            quality: quality >= 1 ? quality : 1
                        };
                    });

                    // ä¿å­˜åˆ°localStorageï¼ˆæ°¸ä¹…ä¿å­˜ï¼Œç›´åˆ°ä¸‹æ¬¡æ‰‹åŠ¨ä¸Šä¼ æ›¿æ¢ï¼‰
                    localStorage.setItem(EQUIPMENT_STORAGE_KEY, JSON.stringify(equipmentTable));
                    console.log('è£…å¤‡è¡¨å·²ä¿å­˜åˆ°æœ¬åœ°ï¼Œå…±', equipmentTable.length, 'ä»¶è£…å¤‡');
                    console.log('è£…å¤‡è¡¨ç¤ºä¾‹ï¼ˆå‰3ä»¶ï¼‰:', equipmentTable.slice(0, 3).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        type: eq.type,
                        hp: eq.hp,
                        atk: eq.atk,
                        def: eq.def
                    })));

                    // è¯»å–EquipSlotLevelé¡µç­¾
                    try {
                        const slotLevelSheetName = workbook.SheetNames.find(name => 
                            name.toLowerCase().includes('equipslotlevel') || name.toLowerCase().includes('equip_slot_level')
                        );
                        if (slotLevelSheetName) {
                            const slotLevelSheet = workbook.Sheets[slotLevelSheetName];
                            const slotLevelRows = XLSX.utils.sheet_to_json(slotLevelSheet, { header: 1 });
                            
                            if (slotLevelRows && slotLevelRows.length >= 6) {
                                const headerRow0 = slotLevelRows[0] || [];
                                let colType = -1, colHeroClasses = -1, colSlotLevel = -1, colCostItem = -1, colAttribute = -1;
                                
                                for (let i = 0; i < headerRow0.length; i++) {
                                    const cell = String(headerRow0[i] || '').trim().toLowerCase();
                                    if (cell === 'type' || cell === 'éƒ¨ä½') colType = i;
                                    else if (cell === 'heroclasses' || cell === 'hero_classes' || cell === 'èŒä¸š') colHeroClasses = i;
                                    else if (cell === 'slotlevel' || cell === 'slot_level' || cell === 'æ§½ä½ç­‰çº§') colSlotLevel = i;
                                    else if (cell === 'costitem' || cell === 'cost_item' || cell === 'æ¶ˆè€—ææ–™') colCostItem = i;
                                    else if (cell === 'attribute' || cell === 'å±æ€§') colAttribute = i;
                                }
                                
                                if (colType >= 0 && colHeroClasses >= 0 && colSlotLevel >= 0 && colCostItem >= 0 && colAttribute >= 0) {
                                    const dataRows = slotLevelRows.slice(5);
                                    equipSlotLevelTable = dataRows.map(row => {
                                        const type = parseInt(row[colType]) || 0;
                                        const heroClasses = parseInt(row[colHeroClasses]) || 0;
                                        const slotLevel = parseInt(row[colSlotLevel]) || 0;
                                        const costItem = String(row[colCostItem] || '').trim();
                                        const attribute = String(row[colAttribute] || '').trim();
                                        
                                        // è§£æcostItem: "1011;5|1001;20" -> [{resourceId: '1011', count: 5}, {resourceId: '1001', count: 20}]
                                        const costItems = [];
                                        if (costItem) {
                                            costItem.split('|').forEach(part => {
                                                const [resourceId, count] = part.split(';');
                                                if (resourceId && count) {
                                                    costItems.push({
                                                        resourceId: resourceId.trim(),
                                                        count: parseInt(count.trim()) || 0
                                                    });
                                                }
                                            });
                                        }
                                        
                                        // è§£æattribute: "101001;140|103001;6|" -> {hp: 140, def: 6}
                                        const attrs = { hp: 0, atk: 0, def: 0 };
                                        if (attribute) {
                                            attribute.split('|').forEach(part => {
                                                if (!part.trim()) return;
                                                const [attrId, value] = part.split(';');
                                                if (attrId && value) {
                                                    const attrIdNum = parseInt(attrId.trim());
                                                    const attrValue = parseInt(value.trim()) || 0;
                                                    if (attrIdNum === 101001) attrs.hp = attrValue;
                                                    else if (attrIdNum === 102001) attrs.atk = attrValue;
                                                    else if (attrIdNum === 103001) attrs.def = attrValue;
                                                }
                                            });
                                        }
                                        
                                        return {
                                            type: type, // 1=å¤´, 2=èº«, 3=æ‰‹, 4=è„š
                                            heroClasses: heroClasses, // 1=å¦å…‹, 2=æˆ˜å£«, 3=å°„æ‰‹, 4=è¾…åŠ©
                                            slotLevel: slotLevel,
                                            costItems: costItems,
                                            attribute: attrs
                                        };
                                    }).filter(row => row.type > 0 && row.heroClasses > 0 && row.slotLevel > 0);
                                    
                                    localStorage.setItem(EQUIP_SLOT_LEVEL_STORAGE_KEY, JSON.stringify(equipSlotLevelTable));
                                    console.log('è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨å·²ä¿å­˜åˆ°æœ¬åœ°ï¼Œå…±', equipSlotLevelTable.length, 'æ¡è®°å½•');
                                    
                                    // æ£€æŸ¥æ˜¯å¦æœ‰è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ·»åŠ 
                                    const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
                                    if (!hasEquipSlotEnhance) {
                                        const maxId = resourceConsumptionGameplayList.length > 0 
                                            ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                                            : 0;
                                        resourceConsumptionGameplayList.push({
                                            id: maxId + 1,
                                            name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                                            itemName: '',
                                            type: 'equipSlotEnhance'
                                        });
                                        savePlayerEconomyData();
                                        console.log('å·²è‡ªåŠ¨æ·»åŠ è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•');
                                    }
                                } else {
                                    console.warn('EquipSlotLevelé¡µç­¾ç¼ºå°‘å¿…è¦çš„åˆ—');
                                }
                            }
                        }
                    } catch (slotError) {
                        console.warn('è¯»å–EquipSlotLevelé¡µç­¾å¤±è´¥:', slotError);
                    }
                    
                    // æ›´æ–°ç•Œé¢
                    updateJobEquipmentPanel();
                    updateEquipmentTableInfo();
                    renderMainConfigEquipSlotEnhancePanel(); // åˆ·æ–°ä¸»é…ç½®è£…å¤‡å¼ºåŒ–é¢æ¿ // åˆ·æ–°ä¸»é…ç½®è£…å¤‡å¼ºåŒ–é¢æ¿
                    // å¦‚æœç©å®¶ç»æµæ¨¡æ‹Ÿé¡µç­¾å·²æ‰“å¼€ï¼Œæ›´æ–°è£…å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†å’Œè£…å¤‡é¢æ¿
                    const economyTab = document.getElementById('tab-economy');
                    if (economyTab && economyTab.classList.contains('active')) {
                        updateEquipmentSelect();
                        renderPlayerOwnedEquipment();
                        renderResourceGameplayList(); // åˆ·æ–°èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨ï¼Œæ˜¾ç¤ºè£…å¤‡æ§½ä½å¼ºåŒ–
                    }
                    
                    showMessage(`æˆåŠŸåŠ è½½${equipmentTable.length}ä»¶è£…å¤‡ï¼Œå·²ä¿å­˜åˆ°æœ¬åœ°`, 'success');
                } catch (error) {
                    console.error('è¯»å–è£…å¤‡è¡¨å¤±è´¥:', error);
                    showMessage('è¯»å–è£…å¤‡è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // åŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼ˆå¤´5è¡Œè¡¨å¤´ï¼›HeroBoxLevel é¡µç­¾ D=ç­‰çº§ E=å‡çº§éœ€è¦æ‹›å‹Ÿæ¬¡æ•°ï¼‰
        window.loadRecruitInfoTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    recruitInfoTable = [];
                    recruitBoxLevelTable = [];
                    recruitPoolTable = [];
                    
                    // HeroBoxLevel é¡µç­¾ï¼šDåˆ—=ç­‰çº§ï¼ŒEåˆ—=å‡çº§éœ€è¦æ‹›å‹Ÿæ¬¡æ•°
                    const heroBoxSheet = workbook.SheetNames.find(n => 
                        String(n).toLowerCase().includes('heroboxlevel')
                    );
                    if (heroBoxSheet) {
                        const raw = XLSX.utils.sheet_to_json(workbook.Sheets[heroBoxSheet], { header: 1 });
                        raw.forEach((row) => {
                            const level = parseInt(row[3]);
                            const required = parseInt(row[4]);
                            if (isNaN(level) || isNaN(required) || level < 1) return;
                            recruitBoxLevelTable.push({ level, requiredCount: required });
                        });
                        recruitBoxLevelTable.sort((a, b) => a.level - b.level);
                    }
                    
                    // HeroPoolGroup é¡µç­¾ï¼šC=å¥–æ± ç­‰çº§ D=å“è´¨(1~4â†’3~6)æˆ–é‡‘å¸ E=æƒé‡
                    const poolSheet = workbook.SheetNames.find(n => 
                        String(n).toLowerCase().includes('heropoolgroup')
                    );
                    if (poolSheet) {
                        const raw = XLSX.utils.sheet_to_json(workbook.Sheets[poolSheet], { header: 1 });
                        raw.forEach((row) => {
                            const level = parseInt(row[2]); // Cåˆ—
                            const d = parseInt(row[3]);     // Dåˆ—
                            const weight = parseInt(row[4]) || 0; // Eåˆ—
                            if (isNaN(level) || level < 1 || isNaN(d) || weight <= 0) return;
                            recruitPoolTable.push({ level, qualityOrGold: d, weight });
                        });
                    }
                    
                    // æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼šç¬¬ä¸€ä¸ªå·¥ä½œè¡¨ï¼Œå¤´5è¡Œè¡¨å¤´
                    const first = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(first, { header: 1 });
                    const header = rows.slice(0, 5);
                    const dataRows = rows.slice(5);
                    const headers = header[header.length - 1] || [];
                    dataRows.forEach(row => {
                        const obj = {};
                        headers.forEach((h, i) => { obj[h] = row[i]; });
                        if (Object.keys(obj).length) recruitInfoTable.push(obj);
                    });
                    
                    const status = document.getElementById('recruitInfoTableStatus');
                    const info = document.getElementById('recruitInfoTableInfo');
                    if (status) status.textContent = `å·²åŠ è½½æ‹›å‹Ÿè¡¨ ${recruitInfoTable.length} æ¡ï¼Œå¥–æ± ç­‰çº§ ${recruitBoxLevelTable.length} æ¡£ï¼ŒHeroPoolGroup ${recruitPoolTable.length} æ¡`;
                    if (info) info.innerHTML = `HeroBoxLevel: ${recruitBoxLevelTable.length} æ¡ï¼›HeroPoolGroup: ${recruitPoolTable.length} æ¡ï¼›æ‹›å‹Ÿä¿¡æ¯: ${recruitInfoTable.length} æ¡`;
                    try {
                        localStorage.setItem(RECRUIT_INFO_STORAGE_KEY, JSON.stringify(recruitInfoTable));
                        localStorage.setItem(RECRUIT_BOX_LEVEL_STORAGE_KEY, JSON.stringify(recruitBoxLevelTable));
                        localStorage.setItem(RECRUIT_POOL_STORAGE_KEY, JSON.stringify(recruitPoolTable));
                    } catch (err) {}
                    showMessage('æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨åŠ è½½æˆåŠŸ', 'success');
                } catch (err) {
                    console.error('åŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨å¤±è´¥', err);
                    showMessage('åŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨å¤±è´¥ï¼š' + (err.message || err), 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // ä»æœ¬åœ°åŠ è½½å·²ä¿å­˜çš„æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨
        function loadSavedRecruitInfoTable() {
            try {
                const savedInfo = localStorage.getItem(RECRUIT_INFO_STORAGE_KEY);
                if (savedInfo) {
                    recruitInfoTable = JSON.parse(savedInfo);
                    console.log('ä»æœ¬åœ°åŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼Œå…±', recruitInfoTable.length, 'æ¡');
                }
                const savedLevel = localStorage.getItem(RECRUIT_BOX_LEVEL_STORAGE_KEY);
                if (savedLevel) {
                    recruitBoxLevelTable = JSON.parse(savedLevel);
                    console.log('ä»æœ¬åœ°åŠ è½½æ‹›å‹Ÿå¥–æ± ç­‰çº§è¡¨ï¼Œå…±', recruitBoxLevelTable.length, 'æ¡£');
                }
                const savedPool = localStorage.getItem(RECRUIT_POOL_STORAGE_KEY);
                if (savedPool) {
                    recruitPoolTable = JSON.parse(savedPool);
                    console.log('ä»æœ¬åœ°åŠ è½½HeroPoolGroupï¼Œå…±', recruitPoolTable.length, 'æ¡');
                }
                const status = document.getElementById('recruitInfoTableStatus');
                const info = document.getElementById('recruitInfoTableInfo');
                if (recruitInfoTable.length || recruitBoxLevelTable.length || recruitPoolTable.length) {
                    if (status) status.textContent = `å·²åŠ è½½æ‹›å‹Ÿè¡¨ ${recruitInfoTable.length} æ¡ï¼Œå¥–æ± ç­‰çº§ ${recruitBoxLevelTable.length} æ¡£ï¼ŒHeroPoolGroup ${recruitPoolTable.length} æ¡`;
                    if (info) info.innerHTML = `HeroBoxLevel: ${recruitBoxLevelTable.length} æ¡ï¼›HeroPoolGroup: ${recruitPoolTable.length} æ¡ï¼›æ‹›å‹Ÿä¿¡æ¯: ${recruitInfoTable.length} æ¡`;
                }
            } catch (err) {
                console.error('åŠ è½½æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨å¤±è´¥', err);
            }
        }

        // åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼ˆå‰5è¡Œè¡¨å¤´ï¼›Båˆ—=è´¦å·ç­‰çº§ï¼ŒCåˆ—=å‡åˆ°æœ¬çº§åˆ«éœ€è¦çš„ç»éªŒï¼‰
        window.loadAccountLevelTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const first = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(first, { header: 1 });
                    const dataRows = rows.slice(5);
                    accountLevelTable = [];
                    dataRows.forEach(row => {
                        const level = parseInt(row[1]);
                        const expRequired = parseInt(row[2]);
                        if (isNaN(level) || level < 1) return;
                        accountLevelTable.push({ level, expRequired: isNaN(expRequired) ? 0 : expRequired });
                    });
                    accountLevelTable.sort((a, b) => a.level - b.level);
                    try {
                        localStorage.setItem(ACCOUNT_LEVEL_TABLE_STORAGE_KEY, JSON.stringify(accountLevelTable));
                    } catch (err) {}
                    const status = document.getElementById('accountLevelTableStatus');
                    const info = document.getElementById('accountLevelTableInfo');
                    if (status) status.textContent = `å·²åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨ ${accountLevelTable.length} æ¡`;
                    if (info) info.innerHTML = `å…± ${accountLevelTable.length} æ¡ï¼Œå‡åˆ°å„çº§æ‰€éœ€ç»éªŒå·²å¯¼å…¥`;
                    showMessage('ç©å®¶è´¦å·ç­‰çº§è¡¨åŠ è½½æˆåŠŸ', 'success');
                } catch (err) {
                    console.error('åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨å¤±è´¥', err);
                    showMessage('åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨å¤±è´¥ï¼š' + (err.message || err), 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // ä»æœ¬åœ°åŠ è½½å·²ä¿å­˜çš„ç©å®¶è´¦å·ç­‰çº§è¡¨
        function loadSavedAccountLevelTable() {
            try {
                const raw = localStorage.getItem(ACCOUNT_LEVEL_TABLE_STORAGE_KEY);
                if (raw) {
                    accountLevelTable = JSON.parse(raw);
                    console.log('ä»æœ¬åœ°åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼Œå…±', accountLevelTable.length, 'æ¡');
                }
                const status = document.getElementById('accountLevelTableStatus');
                const info = document.getElementById('accountLevelTableInfo');
                if (accountLevelTable.length) {
                    if (status) status.textContent = `å·²åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨ ${accountLevelTable.length} æ¡`;
                    if (info) info.innerHTML = `å…± ${accountLevelTable.length} æ¡ï¼Œå‡åˆ°å„çº§æ‰€éœ€ç»éªŒ`;
                }
            } catch (err) {
                console.error('åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨å¤±è´¥', err);
            }
        }

        // åŠ è½½ç‰©å“æ€»è¡¨ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.loadItemTable = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // æŸ¥æ‰¾item_10é¡µç­¾
                    const item10SheetName = workbook.SheetNames.find(name => 
                        name.toLowerCase() === 'item_10' || name.toLowerCase().includes('item_10')
                    );
                    
                    if (!item10SheetName) {
                        showMessage('æœªæ‰¾åˆ°item_10é¡µç­¾', 'error');
                        return;
                    }
                    
                    // è¯»å–item_10é¡µç­¾ï¼ˆå¤´5è¡Œæ˜¯è¡¨å¤´ï¼‰
                    const item10Sheet = workbook.Sheets[item10SheetName];
                    const rawRows = XLSX.utils.sheet_to_json(item10Sheet, { 
                        header: 1,
                        defval: ''
                    });
                    
                    // è·³è¿‡å‰5è¡Œè¡¨å¤´ï¼Œä»ç¬¬6è¡Œå¼€å§‹è¯»å–æ•°æ®
                    const dataRows = rawRows.slice(5);
                    
                    // æŸ¥æ‰¾idå’Œnameåˆ—çš„ç´¢å¼•ï¼ˆä»ç¬¬ä¸€è¡Œè¡¨å¤´æŸ¥æ‰¾ï¼‰
                    const headerRow0 = rawRows[0] || [];
                    let colId = -1;
                    let colName = -1;
                    
                    for (let i = 0; i < headerRow0.length; i++) {
                        const cellValue = String(headerRow0[i] || '').toLowerCase().trim();
                        if (cellValue === 'id') {
                            colId = i;
                        } else if (cellValue === 'name') {
                            colName = i;
                        }
                    }
                    
                    if (colId < 0 || colName < 0) {
                        showMessage('æœªæ‰¾åˆ°idåˆ—æˆ–nameåˆ—', 'error');
                        return;
                    }
                    
                    resourceItemTable = [];
                    dataRows.forEach((row, index) => {
                        if (!row || row.length === 0) return;
                        
                        const id = String(row[colId] || '').trim();
                        const name = String(row[colName] || '').trim();
                        
                        if (id && name) {
                            resourceItemTable.push({ id, name });
                        }
                    });
                    
                    // ä¿å­˜åˆ°localStorage
                    try {
                        localStorage.setItem(RESOURCE_ITEM_STORAGE_KEY, JSON.stringify(resourceItemTable));
                    } catch (err) {
                        console.error('ä¿å­˜èµ„æºç‰©å“è¡¨å¤±è´¥', err);
                    }
                    
                    const status = document.getElementById('itemTableStatus');
                    const info = document.getElementById('itemTableInfo');
                    if (status) {
                        status.textContent = `å·²åŠ è½½èµ„æºç‰©å“è¡¨ ${resourceItemTable.length} æ¡`;
                        status.style.color = '#51cf66';
                    }
                    if (info) {
                        info.textContent = `å…± ${resourceItemTable.length} æ¡èµ„æºç±»ç‰©å“`;
                    }
                    
                    // æ›´æ–°èµ„æºé€‰æ‹©ä¸‹æ‹‰æ¡†
                    updateResourceSelect();
                    
                    showMessage('ç‰©å“æ€»è¡¨åŠ è½½æˆåŠŸ', 'success');
                } catch (err) {
                    console.error('åŠ è½½ç‰©å“æ€»è¡¨å¤±è´¥', err);
                    showMessage('åŠ è½½ç‰©å“æ€»è¡¨å¤±è´¥ï¼š' + (err.message || err), 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // ä»æœ¬åœ°åŠ è½½å·²ä¿å­˜çš„èµ„æºç‰©å“è¡¨
        function loadSavedResourceItemTable() {
            try {
                const raw = localStorage.getItem(RESOURCE_ITEM_STORAGE_KEY);
                if (raw) {
                    resourceItemTable = JSON.parse(raw);
                    console.log('ä»æœ¬åœ°åŠ è½½èµ„æºç‰©å“è¡¨ï¼Œå…±', resourceItemTable.length, 'æ¡');
                }
                const status = document.getElementById('itemTableStatus');
                const info = document.getElementById('itemTableInfo');
                if (resourceItemTable.length) {
                    if (status) {
                        status.textContent = `å·²åŠ è½½èµ„æºç‰©å“è¡¨ ${resourceItemTable.length} æ¡`;
                        status.style.color = '#51cf66';
                    }
                    if (info) {
                        info.textContent = `å…± ${resourceItemTable.length} æ¡èµ„æºç±»ç‰©å“`;
                    }
                }
                // æ›´æ–°èµ„æºé€‰æ‹©ä¸‹æ‹‰æ¡†å’Œèµ„æºæ ‡ç­¾
                updateResourceSelect();
                updateResourceLabels();
            } catch (err) {
                console.error('åŠ è½½èµ„æºç‰©å“è¡¨å¤±è´¥', err);
            }
        }

        // æ ¹æ®èµ„æºIDè·å–èµ„æºåç§°
        function getResourceName(resourceId) {
            if (!resourceItemTable || resourceItemTable.length === 0) {
                // å¦‚æœèµ„æºè¡¨æœªåŠ è½½ï¼Œè¿”å›é»˜è®¤åç§°
                const defaultNames = {
                    '1001': 'é‡‘å¸',
                    '1002': 'é’»çŸ³',
                    '1003': 'ä½“åŠ›',
                    '1021': 'æ‹›å‹Ÿåˆ¸'
                };
                return defaultNames[String(resourceId)] || '';
            }
            const resource = resourceItemTable.find(r => String(r.id).trim() === String(resourceId).trim());
            return resource ? resource.name : '';
        }

        // è·å–æ‹›å‹Ÿåˆ¸èµ„æºåç§°ï¼ˆèµ„æºID 1021ï¼‰
        function getRecruitTicketName() {
            return getResourceName('1021');
        }

        // æ›´æ–°èµ„æºæ ‡ç­¾æ˜¾ç¤º
        function updateResourceLabels() {
            // æ›´æ–°ä½“åŠ›æ ‡ç­¾
            const staminaLabel = document.querySelector('label[for="playerCurrentStamina"]');
            if (!staminaLabel) {
                // å¦‚æœæ²¡æœ‰forå±æ€§ï¼ŒæŸ¥æ‰¾åŒ…å«"ä½“åŠ›"çš„label
                const labels = document.querySelectorAll('label');
                labels.forEach(label => {
                    if (label.textContent.trim() === 'ä½“åŠ›' && label.nextElementSibling && label.nextElementSibling.id === 'playerCurrentStamina') {
                        const resourceName = getResourceName('1003');
                        if (resourceName) label.textContent = resourceName;
                    }
                });
            } else {
                const resourceName = getResourceName('1003');
                if (resourceName) staminaLabel.textContent = resourceName;
            }
            
            // æ›´æ–°é‡‘å¸æ ‡ç­¾
            const goldLabel = document.querySelector('label[for="playerGold"]');
            if (!goldLabel) {
                const labels = document.querySelectorAll('label');
                labels.forEach(label => {
                    if (label.textContent.trim() === 'é‡‘å¸' && label.nextElementSibling && label.nextElementSibling.id === 'playerGold') {
                        const resourceName = getResourceName('1001');
                        if (resourceName) label.textContent = resourceName;
                    }
                });
            } else {
                const resourceName = getResourceName('1001');
                if (resourceName) goldLabel.textContent = resourceName;
            }
            
            // æ›´æ–°é’»çŸ³æ ‡ç­¾
            const diamondLabel = document.querySelector('label[for="playerDiamond"]');
            if (!diamondLabel) {
                const labels = document.querySelectorAll('label');
                labels.forEach(label => {
                    if (label.textContent.trim() === 'é’»çŸ³' && label.nextElementSibling && label.nextElementSibling.id === 'playerDiamond') {
                        const resourceName = getResourceName('1002');
                        if (resourceName) label.textContent = resourceName;
                    }
                });
            } else {
                const resourceName = getResourceName('1002');
                if (resourceName) diamondLabel.textContent = resourceName;
            }
            
            // æ›´æ–°æ‹›å‹Ÿåˆ¸æ ‡ç­¾
            const recruitLabel = document.querySelector('label[for="playerDailyRecruitTickets"]');
            if (!recruitLabel) {
                const labels = document.querySelectorAll('label');
                labels.forEach(label => {
                    if (label.textContent.trim() === 'æ‹›å‹Ÿåˆ¸' && label.nextElementSibling && label.nextElementSibling.id === 'playerDailyRecruitTickets') {
                        const resourceName = getResourceName('1021');
                        if (resourceName) label.textContent = resourceName;
                    }
                });
            } else {
                const resourceName = getResourceName('1021');
                if (resourceName) recruitLabel.textContent = resourceName;
            }
        }

        // æ›´æ–°èµ„æºé€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateResourceSelect() {
            const select = document.getElementById('newItemResourceSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">è¯·é€‰æ‹©èµ„æº</option>';
            
            if (resourceItemTable.length === 0) {
                select.innerHTML = '<option value="">è¯·å…ˆä¸Šä¼ ç‰©å“æ€»è¡¨</option>';
                return;
            }
            
            // æŒ‰IDæ’åº
            const sortedResources = [...resourceItemTable].sort((a, b) => {
                const idA = String(a.id).trim();
                const idB = String(b.id).trim();
                // å°è¯•æ•°å­—æ¯”è¾ƒï¼Œå¦åˆ™å­—ç¬¦ä¸²æ¯”è¾ƒ
                const numA = parseInt(idA);
                const numB = parseInt(idB);
                if (!isNaN(numA) && !isNaN(numB)) {
                    return numA - numB;
                }
                return idA.localeCompare(idB);
            });
            
            sortedResources.forEach(resource => {
                const option = document.createElement('option');
                option.value = resource.id;
                option.textContent = `${resource.id} - ${resource.name}`;
                option.setAttribute('data-name', resource.name);
                select.appendChild(option);
            });
            
            // æ›´æ–°èµ„æºæ ‡ç­¾
            updateResourceLabels();
        }

        // æ ¹æ®è´¦å·ç­‰çº§è¡¨è·å–ã€Œå‡åˆ°è¯¥çº§åˆ«éœ€è¦çš„ç»éªŒã€ï¼›è‹¥è¡¨æ— æ­¤çº§åˆ™å›é€€é»˜è®¤
        function getExpRequiredForLevel(level) {
            if (!accountLevelTable || !accountLevelTable.length) return null;
            const row = accountLevelTable.find(r => r.level === level);
            return row ? row.expRequired : null;
        }

        // æ›´æ–°èŒä¸šè£…å¤‡é¢æ¿
        function updateJobEquipmentPanel() {
            const panel = document.getElementById('jobEquipmentPanel');
            if (!panel) return;

            const eco = getMainConfigEconomySchemeData();
            const ownedEqIds = (useEconomySimulation && eco && Array.isArray(eco.playerEquipment))
                ? new Set(eco.playerEquipment.map(x => String(x))) : null;

            if (ownedEqIds) {
                [1, 2, 3, 4].forEach(jobId => {
                    const je = characterEquipment[jobId];
                    if (!je) return;
                    ['head', 'body', 'hand', 'foot'].forEach(type => {
                        const eid = je[type];
                        if (eid && !ownedEqIds.has(String(eid))) {
                            je[type] = null;
                        }
                    });
                });
            }

            panel.innerHTML = Object.keys(JOB_NAMES).map(jobId => {
                const jobIdNum = parseInt(jobId);
                const jobName = JOB_NAMES[jobIdNum];
                const jobEquipment = characterEquipment[jobIdNum] || { head: null, body: null, hand: null, foot: null };
                
                // è·å–è¯¥èŒä¸šçš„è£…å¤‡åˆ—è¡¨ï¼ˆæŒ‰éƒ¨ä½åˆ†ç»„ï¼‰
                // ä½¿ç”¨parseHeroClasså‡½æ•°å…¼å®¹æ–‡æœ¬æ ¼å¼
                function parseHeroClassForFilter(heroclassValue) {
                    if (!heroclassValue) return 0;
                    
                    // å¦‚æœæ˜¯æ•°å­—ï¼Œç›´æ¥è½¬æ¢
                    const numValue = parseInt(heroclassValue);
                    if (!isNaN(numValue) && numValue > 0) {
                        return numValue;
                    }
                    
                    // å¦‚æœæ˜¯æ–‡æœ¬ï¼Œè½¬æ¢ä¸ºæ•°å­—
                    const textValue = String(heroclassValue).trim();
                    if (textValue === 'å¦å…‹' || textValue === 'Tank' || textValue === '1') return 1;
                    if (textValue === 'æˆ˜å£«' || textValue === 'Warrior' || textValue === '2') return 2;
                    if (textValue === 'å°„æ‰‹' || textValue === 'Archer' || textValue === '3') return 3;
                    if (textValue === 'è¾…åŠ©' || textValue === 'Support' || textValue === '4') return 4;
                    
                    return 0;
                }
                
                // ç­›é€‰è£…å¤‡ï¼šå…¼å®¹å¤šç§æ ¼å¼
                const equipmentByType = {
                    head: equipmentTable.filter(eq => {
                        // heroclasså¯èƒ½æ˜¯æ•°å­—æˆ–éœ€è¦è§£æçš„æ–‡æœ¬
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        // å…¼å®¹å¤šç§éƒ¨ä½åç§°æ ¼å¼
                        return eqJob === jobIdNum && (
                            eqType === 'å¤´' || eqType === 'head' || eqType === 'Head' || 
                            eqType === 'å¤´éƒ¨' || eqType === 'å¤´ç›”'
                        );
                    }),
                    body: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === 'èº«' || eqType === 'body' || eqType === 'Body' || 
                            eqType === 'èº«ä½“' || eqType === 'èƒ¸ç”²' || eqType === 'æŠ¤ç”²'
                        );
                    }),
                    hand: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === 'æ‰‹' || eqType === 'hand' || eqType === 'Hand' || 
                            eqType === 'æ‰‹éƒ¨' || eqType === 'æ­¦å™¨'
                        );
                    }),
                    foot: equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = String(eq.type || '').trim();
                        return eqJob === jobIdNum && (
                            eqType === 'è„š' || eqType === 'foot' || eqType === 'Foot' || 
                            eqType === 'è„šéƒ¨' || eqType === 'é‹å­' || eqType === 'é´å­'
                        );
                    })
                };
                
                // è°ƒè¯•ä¿¡æ¯
                console.log(`èŒä¸š${jobName}(${jobIdNum})è£…å¤‡ç­›é€‰ç»“æœ:`, {
                    head: equipmentByType.head.length,
                    body: equipmentByType.body.length,
                    hand: equipmentByType.hand.length,
                    foot: equipmentByType.foot.length
                });
                
                // è¯¦ç»†è°ƒè¯•ï¼šæ˜¾ç¤ºå‰5ä»¶è£…å¤‡çš„æ•°æ®æ ¼å¼ï¼ˆä»…å¯¹ç¬¬ä¸€ä¸ªèŒä¸šæ‰§è¡Œä¸€æ¬¡ï¼‰
                if (jobIdNum === 1 && equipmentTable.length > 0) {
                    console.log('è£…å¤‡è¡¨æ•°æ®ç¤ºä¾‹ï¼ˆå‰5ä»¶ï¼‰:', equipmentTable.slice(0, 5).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        heroclassType: typeof eq.heroclass,
                        type: eq.type,
                        typeType: typeof eq.type
                    })));
                    
                    // æµ‹è¯•ç­›é€‰é€»è¾‘
                    const testEq = equipmentTable[0];
                    if (testEq) {
                        console.log('æµ‹è¯•è£…å¤‡ç­›é€‰:', {
                            testEq: testEq,
                            parsedHeroclass: parseHeroClassForFilter(testEq.heroclass),
                            parsedType: String(testEq.type || '').trim(),
                            matchesJob1: parseHeroClassForFilter(testEq.heroclass) === 1,
                            matchesHead: String(testEq.type || '').trim() === 'å¤´'
                        });
                    }
                    
                    // ç»Ÿè®¡æ‰€æœ‰å”¯ä¸€çš„heroclasså’Œtypeå€¼
                    const uniqueHeroclass = [...new Set(equipmentTable.map(eq => eq.heroclass))].slice(0, 10);
                    const uniqueType = [...new Set(equipmentTable.map(eq => String(eq.type || '').trim()))].slice(0, 10);
                    console.log('è£…å¤‡è¡¨ä¸­å”¯ä¸€çš„heroclasså€¼ï¼ˆå‰10ä¸ªï¼‰:', uniqueHeroclass);
                    console.log('è£…å¤‡è¡¨ä¸­å”¯ä¸€çš„typeå€¼ï¼ˆå‰10ä¸ªï¼‰:', uniqueType);
                }
                
                // è¯¦ç»†è°ƒè¯•ï¼šæ˜¾ç¤ºå‰5ä»¶è£…å¤‡çš„æ•°æ®æ ¼å¼
                if (jobIdNum === 1 && equipmentTable.length > 0) {
                    console.log('è£…å¤‡è¡¨æ•°æ®ç¤ºä¾‹ï¼ˆå‰5ä»¶ï¼‰:', equipmentTable.slice(0, 5).map(eq => ({
                        id: eq.id,
                        namecn: eq.namecn,
                        heroclass: eq.heroclass,
                        heroclassType: typeof eq.heroclass,
                        type: eq.type,
                        typeType: typeof eq.type
                    })));
                    
                    // æµ‹è¯•ç­›é€‰é€»è¾‘
                    const testEq = equipmentTable[0];
                    if (testEq) {
                        console.log('æµ‹è¯•è£…å¤‡ç­›é€‰:', {
                            testEq: testEq,
                            parsedHeroclass: parseHeroClassForFilter(testEq.heroclass),
                            parsedType: String(testEq.type || '').trim(),
                            matchesJob1: parseHeroClassForFilter(testEq.heroclass) === 1,
                            matchesHead: String(testEq.type || '').trim() === 'å¤´'
                        });
                    }
                }

                // è®¡ç®—å½“å‰èŒä¸šçš„æ€»è£…å¤‡åŠ æˆ
                let totalHpBonus = 0, totalAtkBonus = 0, totalDefBonus = 0;
                let maxQuality = 1; // ç”¨äºç¡®å®šèƒŒæ™¯é¢œè‰²
                ['head', 'body', 'hand', 'foot'].forEach(type => {
                    const equipmentId = jobEquipment[type];
                    if (equipmentId) {
                        const equipment = equipmentTable.find(eq => eq.id === equipmentId);
                        if (equipment) {
                            totalHpBonus += equipment.hp || 0;
                            totalAtkBonus += equipment.atk || 0;
                            totalDefBonus += equipment.def || 0;
                            const eqQuality = getEquipmentQuality(equipmentId);
                            if (eqQuality > maxQuality) maxQuality = eqQuality;
                        }
                    }
                });
                
                const qualityBg = getQualityBgColor(maxQuality);
                return `
                    <div style="background: ${qualityBg.bg}; border-radius: 12px; padding: 15px; border: 2px solid ${qualityBg.border};">
                        <div style="font-weight: 600; font-size: 1.1em; color: #667eea; margin-bottom: 15px;">${jobName}</div>
                        ${Object.keys(EQUIPMENT_TYPES).map(typeKey => {
                            const typeName = EQUIPMENT_TYPES[typeKey];
                            const typeKeyLower = typeKey.toLowerCase();
                            let availableEquipments = equipmentByType[typeKeyLower] || [];
                            if (ownedEqIds) {
                                availableEquipments = availableEquipments.filter(eq => ownedEqIds.has(String(eq.id)));
                            }
                            const currentEquipmentId = jobEquipment[typeKeyLower] || '';
                            const currentEquipment = currentEquipmentId ? equipmentTable.find(eq => eq.id === currentEquipmentId) : null;
                            
                            return `
                                <div style="margin-bottom: 12px;">
                                    <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666;">${typeName}éƒ¨ï¼š</label>
                                    <select 
                                        class="job-equipment-select" 
                                        data-job="${jobIdNum}" 
                                        data-type="${typeKeyLower}"
                                        onchange="updateJobEquipment(${jobIdNum}, '${typeKeyLower}', this.value)"
                                        style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                                        <option value="">æ— è£…å¤‡</option>
                                        ${availableEquipments.length > 0 ? availableEquipments.map(eq => {
                                            const displayName = eq.namecn || eq.name || eq.id || 'æœªçŸ¥è£…å¤‡';
                                            const isSelected = String(eq.id) === String(currentEquipmentId);
                                            const stats = [];
                                            if (eq.hp) stats.push(`HP+${eq.hp}`);
                                            if (eq.atk) stats.push(`æ”»å‡»+${eq.atk}`);
                                            if (eq.def) stats.push(`é˜²å¾¡+${eq.def}`);
                                            const statsText = stats.length > 0 ? ` (${stats.join(', ')})` : '';
                                            return `<option value="${eq.id}" ${isSelected ? 'selected' : ''}>${displayName}${statsText}</option>`;
                                        }).join('') : '<option value="" disabled>æš‚æ— è¯¥éƒ¨ä½è£…å¤‡</option>'}
                                    </select>
                                    ${currentEquipment ? `
                                        <div style="margin-top: 4px; font-size: 0.8em; color: #888; padding-left: 4px;">
                                            ${currentEquipment.hp ? `<span style="color: #4CAF50;">HP +${currentEquipment.hp}</span>` : ''}
                                            ${currentEquipment.atk ? `<span style="color: #f44336; margin-left: 8px;">æ”»å‡» +${currentEquipment.atk}</span>` : ''}
                                            ${currentEquipment.def ? `<span style="color: #2196F3; margin-left: 8px;">é˜²å¾¡ +${currentEquipment.def}</span>` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }).join('')}
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">æ€»åŠ æˆï¼š</div>
                            <div style="font-size: 0.9em; font-weight: 600;">
                                ${totalHpBonus > 0 ? `<span style="color: #4CAF50;">HP +${totalHpBonus}</span>` : ''}
                                ${totalAtkBonus > 0 ? `<span style="color: #f44336; margin-left: 8px;">æ”»å‡» +${totalAtkBonus}</span>` : ''}
                                ${totalDefBonus > 0 ? `<span style="color: #2196F3; margin-left: 8px;">é˜²å¾¡ +${totalDefBonus}</span>` : ''}
                                ${totalHpBonus === 0 && totalAtkBonus === 0 && totalDefBonus === 0 ? '<span style="color: #999;">æ— åŠ æˆ</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // æ›´æ–°èŒä¸šè£…å¤‡ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateJobEquipment = function(jobId, type, equipmentId) {
            if (!characterEquipment[jobId]) {
                characterEquipment[jobId] = { head: null, body: null, hand: null, foot: null };
            }
            characterEquipment[jobId][type] = equipmentId || null;
            saveCharacterEquipment();
            
            // æ›´æ–°èŒä¸šè£…å¤‡é¢æ¿ï¼ˆåˆ·æ–°æ€»åŠ æˆæ˜¾ç¤ºï¼‰
            updateJobEquipmentPanel();
            
            // æ›´æ–°æ‰€æœ‰è¯¥èŒä¸šçš„è§’è‰²å±æ€§
            characters.forEach(char => {
                if (char.job == jobId) {
                    applyJobEquipmentStats(char);
                }
            });
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºè£…å¤‡å±æ€§å·²æ”¹å˜ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }
        
        // ä¸€é”®ç©¿æˆ´åŠŸèƒ½ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.autoEquipAllJobs = function() {
            if (equipmentTable.length === 0) {
                showMessage('è¯·å…ˆä¸Šä¼ è£…å¤‡è¡¨', 'error');
                return;
            }
            
            const eco = getMainConfigEconomySchemeData();
            const ownedEqIds = (useEconomySimulation && eco && Array.isArray(eco.playerEquipment))
                ? new Set(eco.playerEquipment.map(x => String(x))) : null;
            
            // è§£æèŒä¸šçš„å‡½æ•°ï¼ˆå…¼å®¹å¤šç§æ ¼å¼ï¼‰
            function parseHeroClassForFilter(heroclassValue) {
                if (!heroclassValue) return 0;
                const numValue = parseInt(heroclassValue);
                if (!isNaN(numValue) && numValue > 0) {
                    return numValue;
                }
                const textValue = String(heroclassValue).trim();
                if (textValue === 'å¦å…‹' || textValue === 'Tank' || textValue === '1') return 1;
                if (textValue === 'æˆ˜å£«' || textValue === 'Warrior' || textValue === '2') return 2;
                if (textValue === 'å°„æ‰‹' || textValue === 'Archer' || textValue === '3') return 3;
                if (textValue === 'è¾…åŠ©' || textValue === 'Support' || textValue === '4') return 4;
                return 0;
            }
            
            // è§£æéƒ¨ä½çš„å‡½æ•°ï¼ˆå…¼å®¹å¤šç§æ ¼å¼ï¼‰
            function parseEquipmentType(eqType) {
                const typeStr = String(eqType || '').trim();
                if (typeStr === 'å¤´' || typeStr === 'head' || typeStr === 'Head' || typeStr === 'å¤´éƒ¨' || typeStr === 'å¤´ç›”') return 'head';
                if (typeStr === 'èº«' || typeStr === 'body' || typeStr === 'Body' || typeStr === 'èº«ä½“' || typeStr === 'èƒ¸ç”²' || typeStr === 'æŠ¤ç”²') return 'body';
                if (typeStr === 'æ‰‹' || typeStr === 'hand' || typeStr === 'Hand' || typeStr === 'æ‰‹éƒ¨' || typeStr === 'æ­¦å™¨') return 'hand';
                if (typeStr === 'è„š' || typeStr === 'foot' || typeStr === 'Foot' || typeStr === 'è„šéƒ¨' || typeStr === 'é‹å­' || typeStr === 'é´å­') return 'foot';
                return null;
            }
            
            // ä¸ºæ¯ä¸ªèŒä¸šçš„æ¯ä¸ªéƒ¨ä½é€‰æ‹©å±æ€§æœ€é«˜çš„è£…å¤‡
            const equipmentTypes = ['head', 'body', 'hand', 'foot'];
            let totalEquipped = 0;
            
            [1, 2, 3, 4].forEach(jobId => {
                if (!characterEquipment[jobId]) {
                    characterEquipment[jobId] = { head: null, body: null, hand: null, foot: null };
                }
                
                equipmentTypes.forEach(type => {
                    // ç­›é€‰è¯¥èŒä¸šè¯¥éƒ¨ä½çš„æ‰€æœ‰è£…å¤‡
                    let availableEquipments = equipmentTable.filter(eq => {
                        let eqJob = eq.heroclass;
                        if (typeof eqJob !== 'number') {
                            eqJob = parseHeroClassForFilter(eqJob);
                        }
                        const eqType = parseEquipmentType(eq.type);
                        return eqJob === jobId && eqType === type;
                    });
                    
                    // å¦‚æœå‹¾é€‰äº†ç»æµæ¨¡æ‹Ÿï¼Œåªä¿ç•™å·²æ‹¥æœ‰çš„è£…å¤‡
                    if (ownedEqIds) {
                        availableEquipments = availableEquipments.filter(eq => ownedEqIds.has(String(eq.id)));
                    }
                    
                    if (availableEquipments.length === 0) {
                        // æ²¡æœ‰å¯ç”¨è£…å¤‡ï¼Œæ¸…ç©ºè¯¥éƒ¨ä½
                        characterEquipment[jobId][type] = null;
                        return;
                    }
                    
                    // è®¡ç®—æ¯ä¸ªè£…å¤‡çš„å±æ€§æ€»å’Œï¼ˆhp + atk + defï¼‰
                    availableEquipments.forEach(eq => {
                        eq.totalPower = (eq.hp || 0) + (eq.atk || 0) + (eq.def || 0);
                    });
                    
                    // æŒ‰å±æ€§æ€»å’Œé™åºæ’åº
                    availableEquipments.sort((a, b) => b.totalPower - a.totalPower);
                    
                    // é€‰æ‹©å±æ€§æœ€é«˜çš„è£…å¤‡
                    const bestEquipment = availableEquipments[0];
                    if (bestEquipment) {
                        characterEquipment[jobId][type] = bestEquipment.id;
                        totalEquipped++;
                    } else {
                        characterEquipment[jobId][type] = null;
                    }
                });
            });
            
            // ä¿å­˜è£…å¤‡é…ç½®
            saveCharacterEquipment();
            
            // æ›´æ–°èŒä¸šè£…å¤‡é¢æ¿
            updateJobEquipmentPanel();
            
            // æ›´æ–°æ‰€æœ‰è§’è‰²çš„è£…å¤‡å±æ€§
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
            
            // æ˜¾ç¤ºç»“æœ
            if (totalEquipped > 0) {
                showMessage(`ä¸€é”®ç©¿æˆ´å®Œæˆï¼å·²ä¸ºæ‰€æœ‰èŒä¸šç©¿æˆ´ ${totalEquipped} ä»¶è£…å¤‡`, 'success');
            } else {
                showMessage('ä¸€é”®ç©¿æˆ´å®Œæˆï¼Œä½†æ²¡æœ‰æ‰¾åˆ°å¯ç©¿æˆ´çš„è£…å¤‡', 'info');
            }
        };

        // åº”ç”¨èŒä¸šè£…å¤‡å±æ€§
        function applyJobEquipmentStats(char) {
            const jobEquipment = characterEquipment[char.job] || { head: null, body: null, hand: null, foot: null };
            let totalHp = 0, totalAtk = 0, totalDef = 0;
            
            // ç´¯åŠ æ‰€æœ‰éƒ¨ä½çš„è£…å¤‡å±æ€§
            ['head', 'body', 'hand', 'foot'].forEach(type => {
                const equipmentId = jobEquipment[type];
                if (equipmentId) {
                    const equipment = equipmentTable.find(eq => eq.id === equipmentId);
                    if (equipment) {
                        totalHp += equipment.hp || 0;
                        totalAtk += equipment.atk || 0;
                        totalDef += equipment.def || 0;
                    }
                }
            });
            
            // ç´¯åŠ è£…å¤‡å¼ºåŒ–å±æ€§åŠ æˆï¼ˆä½¿ç”¨ä¸»é…ç½®çš„å¼ºåŒ–ç­‰çº§ï¼Œåªå–å½“å‰ç­‰çº§çš„å±æ€§ï¼‰
            const jobId = char.job;
            const typeMap = { 'head': 1, 'body': 2, 'hand': 3, 'foot': 4 };
            const typeNames = { 1: 'å¤´', 2: 'èº«', 3: 'æ‰‹', 4: 'è„š' };
            let enhanceHp = 0, enhanceAtk = 0, enhanceDef = 0;
            
            if (mainConfigEquipSlotLevels[jobId] && equipSlotLevelTable && equipSlotLevelTable.length > 0) {
                ['head', 'body', 'hand', 'foot'].forEach(type => {
                    const typeId = typeMap[type];
                    const typeName = typeNames[typeId];
                    const level = mainConfigEquipSlotLevels[jobId][typeName] || 0;
                    
                    if (level > 0) {
                        // åªå–å½“å‰ç­‰çº§çš„å±æ€§åŠ æˆï¼ˆä¸ç´¯åŠ ä¹‹å‰ç­‰çº§ï¼‰
                        const levelData = equipSlotLevelTable.find(row => 
                            row.type === typeId && row.heroClasses === jobId && row.slotLevel === level
                        );
                        if (levelData && levelData.attribute) {
                            enhanceHp += levelData.attribute.hp || 0;
                            enhanceAtk += levelData.attribute.atk || 0;
                            enhanceDef += levelData.attribute.def || 0;
                        }
                    }
                });
            }
            
            // åˆ†åˆ«ä¿å­˜è£…å¤‡åŠ æˆå’Œè£…å¤‡å¼ºåŒ–åŠ æˆ
            char.equipmentHpBonus = totalHp;
            char.equipmentAtkBonus = totalAtk;
            char.equipmentDefBonus = totalDef;
            char.equipSlotEnhanceHpBonus = enhanceHp;
            char.equipSlotEnhanceAtkBonus = enhanceAtk;
            char.equipSlotEnhanceDefBonus = enhanceDef;
            
            // è®¡ç®—å¹³å°å±æ€§åŠ æˆï¼ˆå…ˆåŒæ­¥è‹±é›„æ•°é‡/ç­‰çº§å’Œæ¥æºï¼šç»æµæ–¹æ¡ˆæˆ–è¾“å…¥æ¡†ï¼‰
            if (typeof ensurePlatformConfigFromSource === 'function') {
                ensurePlatformConfigFromSource();
            }
            const platformMultiplier = platformConfig.heroCount + platformConfig.heroLevelSum;
            const platformAttackBonus = platformConfig.attackCoeff * platformMultiplier;
            const platformDefenseBonus = platformConfig.defenseCoeff * platformMultiplier;
            const platformHpBonus = platformConfig.hpCoeff * platformMultiplier;
            
            // ä¿å­˜å¹³å°åŠ æˆ
            char.platformAttackBonus = platformAttackBonus;
            char.platformDefenseBonus = platformDefenseBonus;
            char.platformHpBonus = platformHpBonus;
            
            // ä¿å­˜è½¦è¾†åŠ æˆ
            char.vehicleAttackBonus = vehicleConfig.attack || 0;
            char.vehicleDefenseBonus = vehicleConfig.defense || 0;
            char.vehicleHpBonus = vehicleConfig.hp || 0;
            
            // åº”ç”¨å±æ€§åŠ æˆï¼ˆæœ€ç»ˆå±æ€§ï¼Œç”¨äºæˆ˜æ–—è®¡ç®—ï¼‰
            // æœ€ç»ˆå±æ€§ = åŸºç¡€å±æ€§ + è£…å¤‡åŠ æˆï¼ˆå«å¼ºåŒ–ï¼‰ + å¹³å°åŠ æˆ + è½¦è¾†åŠ æˆ
            char.attack = (char.baseAttack || 0) + totalAtk + enhanceAtk + platformAttackBonus + vehicleConfig.attack;
            char.defense = (char.baseDefense || 0) + totalDef + enhanceDef + platformDefenseBonus + vehicleConfig.defense;
            const hpBonus = totalHp + enhanceHp + platformHpBonus + vehicleConfig.hp;
            char.maxHp = (char.baseHp || 0) + hpBonus;
            char.hp = Math.min(char.hp || char.maxHp, char.maxHp); // è°ƒæ•´å½“å‰è¡€é‡ä¸è¶…è¿‡æœ€å¤§è¡€é‡
            
            // è®¡ç®—è§’è‰²5çš„æœ€ç»ˆå›è¡€é€Ÿåº¦ = æœ€ç»ˆæ”»å‡»åŠ› Ã— å›è¡€ç³»æ•°
            if (char.id === 5 && char.healRate !== undefined && char.healRate !== null) {
                char.finalHealRate = char.attack * (char.healRate || 0);
            } else {
                char.finalHealRate = 0;
            }
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
        }

        // ä»ç»æµæ–¹æ¡ˆæˆ–è¾“å…¥æ¡†åŒæ­¥å¹³å°è‹±é›„æ•°é‡/ç­‰çº§å’Œåˆ° platformConfigï¼ˆç”¨äºåŠ æˆè®¡ç®—ï¼‰
        function ensurePlatformConfigFromSource() {
            const eco = typeof getMainConfigEconomySchemeData === 'function' ? getMainConfigEconomySchemeData() : null;
            if (useEconomySimulation && eco && Array.isArray(eco.playerHeroes)) {
                platformConfig.heroCount = eco.playerHeroes.length;
                platformConfig.heroLevelSum = eco.playerHeroes.reduce((sum, h) => sum + (h.level || 1), 0);
            } else {
                const countEl = document.getElementById('platformHeroCount');
                const sumEl = document.getElementById('platformHeroLevelSum');
                platformConfig.heroCount = (countEl && countEl.value !== '') ? (parseInt(countEl.value) || 0) : 0;
                platformConfig.heroLevelSum = (sumEl && sumEl.value !== '') ? (parseInt(sumEl.value) || 0) : 0;
            }
        }
        
        // æ›´æ–°ã€Œè¯»å–è´¦å·è‹±é›„æ•°é‡åŠç­‰çº§å’Œã€å‹¾é€‰æ¡†åŠæ—æ˜¾ï¼ˆéš useEconomySimulation ä¸æ–¹æ¡ˆå˜åŒ–ï¼‰
        function updatePlatformEconomyHeroDisplay() {
            const cb = document.getElementById('platformEconomyHeroCheckbox');
            const disp = document.getElementById('platformEconomyHeroDisplay');
            if (!cb || !disp) return;
            cb.checked = !!useEconomySimulation;
            if (useEconomySimulation) {
                const eco = typeof getMainConfigEconomySchemeData === 'function' ? getMainConfigEconomySchemeData() : null;
                if (eco && Array.isArray(eco.playerHeroes)) {
                    const count = eco.playerHeroes.length;
                    const levelSum = eco.playerHeroes.reduce((s, h) => s + (h.level || 1), 0);
                    disp.textContent = `è‹±é›„æ•°é‡ ${count}ï¼Œç­‰çº§å’Œ ${levelSum}`;
                } else {
                    disp.textContent = 'æœªé€‰æ‹©ç»æµæ–¹æ¡ˆ';
                }
            } else {
                disp.textContent = '';
            }
        }
        
        // æ›´æ–°å¹³å°å±æ€§é…ç½®ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updatePlatformAttributes = function() {
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            ensurePlatformConfigFromSource();
            updatePlatformEconomyHeroDisplay();
            
            // æ›´æ–°å¹³å°åŠ æˆä¿¡æ¯æ˜¾ç¤º
            const multiplier = platformConfig.heroCount + platformConfig.heroLevelSum;
            const attackBonus = platformConfig.attackCoeff * multiplier;
            const defenseBonus = platformConfig.defenseCoeff * multiplier;
            const hpBonus = platformConfig.hpCoeff * multiplier;
            
            const infoEl = document.getElementById('platformBonusInfo');
            if (infoEl) {
                infoEl.innerHTML = `
                    <div>å½“å‰å¹³å°åŠ æˆï¼šæ”»å‡» +${attackBonus.toFixed(2)}ï¼Œé˜²å¾¡ +${defenseBonus.toFixed(2)}ï¼Œç”Ÿå‘½ +${hpBonus.toFixed(2)}</div>
                    <div style="margin-top: 5px; font-size: 0.85em; color: #999;">
                        è®¡ç®—å…¬å¼ï¼šç³»æ•° Ã— (${platformConfig.heroCount} + ${platformConfig.heroLevelSum}) = ç³»æ•° Ã— ${multiplier}
                    </div>
                `;
            }
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§ï¼ˆåŒ…å«å¹³å°åŠ æˆï¼‰
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºå¹³å°å±æ€§å½±å“è§’è‰²æœ€ç»ˆå±æ€§ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // æ›´æ–°è½¦è¾†å±æ€§é…ç½®ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateVehicleAttributes = function() {
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // æ›´æ–°è½¦è¾†åŠ æˆä¿¡æ¯æ˜¾ç¤º
            const infoEl = document.getElementById('vehicleBonusInfo');
            if (infoEl) {
                infoEl.innerHTML = `
                    <div>å½“å‰è½¦è¾†åŠ æˆï¼šæ”»å‡» +${vehicleConfig.attack}ï¼Œé˜²å¾¡ +${vehicleConfig.defense}ï¼Œç”Ÿå‘½ +${vehicleConfig.hp}</div>
                `;
            }
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§ï¼ˆåŒ…å«è½¦è¾†åŠ æˆï¼‰
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºè½¦è¾†å±æ€§å½±å“è§’è‰²æœ€ç»ˆå±æ€§ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }
        
        // æ›´æ–°è§’è‰²æœ€ç»ˆå±æ€§é¢æ¿ï¼ˆåŒæ—¶æ›´æ–°ä¸»é…ç½®å’Œæˆ˜æ–—æ¨¡æ‹Ÿé¡µç­¾ï¼‰
        function updateFinalAttributesPanel() {
            // ç”Ÿæˆå±æ€§é¢æ¿HTMLå†…å®¹
            const panelContent = characters.map(char => {
                const baseHp = char.baseHp || char.hp;
                const baseAtk = char.baseAttack || char.attack;
                const baseDef = char.baseDefense || char.defense;
                const eqHp = char.equipmentHpBonus || 0;
                const eqAtk = char.equipmentAtkBonus || 0;
                const eqDef = char.equipmentDefBonus || 0;
                const enhanceHp = char.equipSlotEnhanceHpBonus || 0;
                const enhanceAtk = char.equipSlotEnhanceAtkBonus || 0;
                const enhanceDef = char.equipSlotEnhanceDefBonus || 0;
                const platformHp = char.platformHpBonus || 0;
                const platformAtk = char.platformAttackBonus || 0;
                const platformDef = char.platformDefenseBonus || 0;
                const vehicleHp = char.vehicleHpBonus || 0;
                const vehicleAtk = char.vehicleAttackBonus || 0;
                const vehicleDef = char.vehicleDefenseBonus || 0;
                const finalHp = char.maxHp || baseHp;
                const finalAtk = char.attack || baseAtk;
                const finalDef = char.defense || baseDef;
                
                const heroQuality = getCharacterHeroQuality(char.id);
                const qualityBg = getQualityBgColor(heroQuality);
                
                return `
                    <div style="background: ${qualityBg.bg}; border-radius: 12px; padding: 15px; border: 2px solid ${qualityBg.border};">
                        <div style="font-weight: 600; font-size: 1.1em; color: #667eea; margin-bottom: 12px;">
                            ${char.name} <span style="font-size: 0.85em; color: #999; font-weight: 400;">[${JOB_NAMES[char.job]}]</span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">åŸºç¡€å±æ€§ï¼š</div>
                            <div style="font-size: 0.9em;">
                                <span style="color: #4CAF50;">HP ${baseHp}</span>
                                <span style="color: #f44336; margin-left: 12px;">æ”»å‡» ${baseAtk}</span>
                                <span style="color: #2196F3; margin-left: 12px;">é˜²å¾¡ ${baseDef}</span>
                            </div>
                        </div>
                        ${eqHp > 0 || eqAtk > 0 || eqDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">è£…å¤‡åŠ æˆï¼š</div>
                            <div style="font-size: 0.9em;">
                                ${eqHp > 0 ? `<span style="color: #4CAF50;">HP +${eqHp}</span>` : ''}
                                ${eqAtk > 0 ? `<span style="color: #f44336; margin-left: ${eqHp > 0 ? '12px' : '0'};">æ”»å‡» +${eqAtk}</span>` : ''}
                                ${eqDef > 0 ? `<span style="color: #2196F3; margin-left: ${(eqHp > 0 || eqAtk > 0) ? '12px' : '0'};">é˜²å¾¡ +${eqDef}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${enhanceHp > 0 || enhanceAtk > 0 || enhanceDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">è£…å¤‡å¼ºåŒ–åŠ æˆï¼š</div>
                            <div style="font-size: 0.9em;">
                                ${enhanceHp > 0 ? `<span style="color: #4CAF50;">HP +${enhanceHp}</span>` : ''}
                                ${enhanceAtk > 0 ? `<span style="color: #f44336; margin-left: ${enhanceHp > 0 ? '12px' : '0'};">æ”»å‡» +${enhanceAtk}</span>` : ''}
                                ${enhanceDef > 0 ? `<span style="color: #2196F3; margin-left: ${(enhanceHp > 0 || enhanceAtk > 0) ? '12px' : '0'};">é˜²å¾¡ +${enhanceDef}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${platformHp > 0 || platformAtk > 0 || platformDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">å¹³å°åŠ æˆï¼š</div>
                            <div style="font-size: 0.9em;">
                                ${platformHp > 0 ? `<span style="color: #4CAF50;">HP +${platformHp.toFixed(2)}</span>` : ''}
                                ${platformAtk > 0 ? `<span style="color: #f44336; margin-left: ${platformHp > 0 ? '12px' : '0'};">æ”»å‡» +${platformAtk.toFixed(2)}</span>` : ''}
                                ${platformDef > 0 ? `<span style="color: #2196F3; margin-left: ${(platformHp > 0 || platformAtk > 0) ? '12px' : '0'};">é˜²å¾¡ +${platformDef.toFixed(2)}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${vehicleHp > 0 || vehicleAtk > 0 || vehicleDef > 0 ? `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">è½¦è¾†åŠ æˆï¼š</div>
                            <div style="font-size: 0.9em;">
                                ${vehicleHp > 0 ? `<span style="color: #4CAF50;">HP +${vehicleHp}</span>` : ''}
                                ${vehicleAtk > 0 ? `<span style="color: #f44336; margin-left: ${vehicleHp > 0 ? '12px' : '0'};">æ”»å‡» +${vehicleAtk}</span>` : ''}
                                ${vehicleDef > 0 ? `<span style="color: #2196F3; margin-left: ${(vehicleHp > 0 || vehicleAtk > 0) ? '12px' : '0'};">é˜²å¾¡ +${vehicleDef}</span>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        <div style="padding-top: 8px; border-top: 1px solid #e0e0e0; margin-top: 8px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">æœ€ç»ˆå±æ€§ï¼š</div>
                            <div style="font-size: 1em; font-weight: 600;">
                                <span style="color: #4CAF50;">HP ${finalHp}</span>
                                <span style="color: #f44336; margin-left: 12px;">æ”»å‡» ${finalAtk}</span>
                                <span style="color: #2196F3; margin-left: 12px;">é˜²å¾¡ ${finalDef}</span>
                                ${char.id === 5 && char.finalHealRate !== undefined && char.finalHealRate > 0 ? `
                                <span style="color: #9C27B0; margin-left: 12px;">å›è¡€ ${char.finalHealRate.toFixed(2)}/ç§’</span>
                                ` : ''}
                            </div>
                            ${char.id === 5 && char.healRate !== undefined && char.healRate > 0 ? `
                            <div style="font-size: 0.8em; color: #999; margin-top: 4px;">
                                å›è¡€ç³»æ•°: ${char.healRate.toFixed(2)} Ã— æœ€ç»ˆæ”»å‡»åŠ› ${finalAtk} = ${char.finalHealRate ? char.finalHealRate.toFixed(2) : (finalAtk * char.healRate).toFixed(2)}/ç§’
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // æ›´æ–°ä¸»é…ç½®é¡µç­¾ä¸­çš„æœ€ç»ˆå±æ€§é¢æ¿
            const mainPanel = document.getElementById('finalAttributesPanel');
            if (mainPanel) {
                mainPanel.innerHTML = panelContent;
            }
            
            // æ›´æ–°æˆ˜æ–—æ¨¡æ‹Ÿé¡µç­¾ä¸­çš„æœ€ç»ˆå±æ€§é¢æ¿
            const battlePanel = document.getElementById('battleFinalAttributesPanel');
            if (battlePanel) {
                battlePanel.innerHTML = panelContent;
            }
        }

        // æ›´æ–°è£…å¤‡è¡¨ä¿¡æ¯æ˜¾ç¤º
        function updateEquipmentTableInfo() {
            const statusEl = document.getElementById('equipmentTableStatus');
            const infoEl = document.getElementById('equipmentTableInfo');
            
            if (equipmentTable.length > 0) {
                statusEl.textContent = `å·²åŠ è½½ ${equipmentTable.length} ä»¶è£…å¤‡ï¼ˆå·²ä¿å­˜åˆ°æœ¬åœ°ï¼‰`;
                statusEl.style.color = '#51cf66';
                
                // æŒ‰èŒä¸šå’Œéƒ¨ä½ç»Ÿè®¡è£…å¤‡æ•°é‡
                const statsByJob = {};
                equipmentTable.forEach(eq => {
                    const jobId = parseInt(eq.heroclass) || 0;
                    const jobName = JOB_NAMES[jobId] || 'æœªçŸ¥';
                    if (!statsByJob[jobName]) {
                        statsByJob[jobName] = { head: 0, body: 0, hand: 0, foot: 0, total: 0 };
                    }
                    const type = String(eq.type || '').trim();
                    if (type === 'å¤´') statsByJob[jobName].head++;
                    else if (type === 'èº«') statsByJob[jobName].body++;
                    else if (type === 'æ‰‹') statsByJob[jobName].hand++;
                    else if (type === 'è„š') statsByJob[jobName].foot++;
                    statsByJob[jobName].total++;
                });
                
                const statsText = Object.keys(statsByJob).map(job => {
                    const stats = statsByJob[job];
                    return `${job}:${stats.total}ä»¶(å¤´${stats.head}/èº«${stats.body}/æ‰‹${stats.hand}/è„š${stats.foot})`;
                }).join('ï¼›');
                infoEl.innerHTML = `<div style="margin-top: 5px;">è£…å¤‡ç»Ÿè®¡ï¼š${statsText}</div>`;
            } else {
                statusEl.textContent = 'æœªåŠ è½½è£…å¤‡è¡¨';
                statusEl.style.color = '#666';
                infoEl.innerHTML = '';
            }
        }

        // åˆå§‹åŒ–è§’è‰²ç•Œé¢
        // åˆå§‹åŒ–å…³å¡é…ç½®ç•Œé¢
        function initStageConfig() {
            const grid = document.getElementById('stageConfigGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage] || {
                    monsterId: '',
                    atkSpeed: 0.33,
                    damageCoeff: 1,
                    hpCoeff: 0
                };
                
                // è·å–æ€ªç‰©ä¿¡æ¯ï¼ˆå¦‚æœå·²é€‰æ‹©ï¼‰
                let monsterInfo = '';
                if (stageData.monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === stageData.monsterId);
                    if (monster) {
                        monsterInfo = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                    }
                }
                
                const stageCard = document.createElement('div');
                stageCard.id = `stage-card-${stage}`;
                stageCard.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;';
                stageCard.innerHTML = `
                    <div style="font-weight: 600; color: #333; margin-bottom: 10px; font-size: 1.05em;">ç¬¬ ${stage} å…³</div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">æ€ªç‰©ID</label>
                        <select id="stage-${stage}-monster" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                            <option value="">æœªé€‰æ‹©</option>
                        </select>
                        <div style="font-size: 0.8em; color: #999; margin-top: 4px;" id="stage-${stage}-monster-info">${monsterInfo}</div>
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">æ”»å‡»é€Ÿåº¦ï¼ˆæ¬¡/ç§’ï¼‰</label>
                        <input type="number" id="stage-${stage}-atkSpeed" min="0.1" max="10" step="0.01" value="${stageData.atkSpeed}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">æ”»å‡»ç³»æ•°</label>
                        <input type="number" id="stage-${stage}-damageCoeff" min="0" step="0.01" value="${stageData.damageCoeff}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">è¡€é‡ç³»æ•°</label>
                        <input type="number" id="stage-${stage}-hpCoeff" min="0" step="0.01" value="${stageData.hpCoeff}" onchange="updateStageConfig(${stage})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="challengeStage(${stage})" style="padding: 8px 16px; font-size: 0.9em; flex: 1;">æŒ‘æˆ˜</button>
                        <div id="stage-${stage}-result" style="font-size: 0.9em; font-weight: 600; flex: 1; text-align: center;"></div>
                    </div>
                    <div id="stage-${stage}-damage-info" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;">
                        <div style="margin-bottom: 5px;">1. æ€ªç‰©å¯¹è§’è‰²1åŸºç¡€ä¼¤å®³: <span id="stage-${stage}-monster-to-char1">-</span></div>
                        <div style="margin-bottom: 5px;">2. è§’è‰²1å¯¹æ€ªç‰©åŸºç¡€ä¼¤å®³: <span id="stage-${stage}-char1-to-monster">-</span></div>
                        <div>3. è§’è‰²3/è§’è‰²4å¹³å‡åŸºç¡€ä¼¤å®³: <span id="stage-${stage}-char34-avg">-</span></div>
                    </div>
                `;
                grid.appendChild(stageCard);
            }
            
            // æ›´æ–°æ‰€æœ‰å…³å¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼ˆå¡«å……æ€ªç‰©æ•°æ®ï¼‰
            updateStageMonsterSelects();
        }

        // æ›´æ–°æ‰€æœ‰å…³å¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateStageMonsterSelects() {
            for (let stage = 1; stage <= 20; stage++) {
                const select = document.getElementById(`stage-${stage}-monster`);
                if (!select) continue;
                
                // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
                const currentValue = select.value || stageConfig[stage]?.monsterId || '';
                
                // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
                select.innerHTML = '<option value="">æœªé€‰æ‹©</option>';
                
                if (monsterTable.length > 0) {
                    // æŒ‰IDæ’åº
                    const sortedMonsters = [...monsterTable].sort((a, b) => {
                        const idA = parseInt(a.id) || 0;
                        const idB = parseInt(b.id) || 0;
                        return idA - idB;
                    });
                    
                    sortedMonsters.forEach(monster => {
                        const option = document.createElement('option');
                        option.value = monster.id;
                        option.textContent = `æ€ªç‰© #${monster.id} (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        select.appendChild(option);
                    });
                }
                
                // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
                if (currentValue) {
                    select.value = currentValue;
                    updateStageConfig(stage);
                } else {
                    // å³ä½¿æ²¡æœ‰é€‰æ‹©ï¼Œä¹Ÿæ›´æ–°ä¼¤å®³ä¿¡æ¯ï¼ˆæ˜¾ç¤ºä¸º"-"ï¼‰
                    updateStageDamageInfo(stage);
                }
            }
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºè§’è‰²å±æ€§å¯èƒ½å·²æ”¹å˜ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // åˆå§‹åŒ–25æ³¢æ€ªç‰©æ•°æ®è¾“å…¥ç•Œé¢
        function initBattleWaveData() {
            const grid = document.getElementById('battleWaveDataGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            grid.style.display = 'flex';
            grid.style.flexDirection = 'column';
            grid.style.gap = '20px';
            
            // åˆ›å»º5ä¸ªåˆ†ç»„ï¼Œæ¯ç»„5æ³¢
            for (let group = 0; group < 5; group++) {
                const groupStartWave = group * 5 + 1;
                const groupEndWave = group * 5 + 5;
                
                // åˆ›å»ºåˆ†ç»„å®¹å™¨
                const groupContainer = document.createElement('div');
                groupContainer.style.cssText = 'background: #f8f9ff; border: 2px solid #667eea; border-radius: 12px; padding: 20px;';
                
                // åˆ†ç»„æ ‡é¢˜
                const groupTitle = document.createElement('div');
                groupTitle.style.cssText = 'font-weight: 700; color: #667eea; margin-bottom: 15px; font-size: 1.15em; padding-bottom: 10px; border-bottom: 2px solid #667eea;';
                groupTitle.textContent = `æ®ç‚¹${group + 1} (ç¬¬${groupStartWave}-${groupEndWave}æ³¢)`;
                groupContainer.appendChild(groupTitle);
                
                // åˆ›å»ºç»„å†…çš„ç½‘æ ¼å®¹å™¨
                const groupGrid = document.createElement('div');
                groupGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 15px;';
                
                // ä¸ºæ¯ç»„åˆ›å»º5æ³¢
                for (let wave = groupStartWave; wave <= groupEndWave; wave++) {
                    const waveData = battleWaveData[wave] || {
                        monsterId: '',
                        attack: 10,
                        defense: 5,
                        hp: 50,
                        atkSpeed: 0.33,
                        damageCoeff: 1,
                        hpCoeff: 1,
                        spawnRate: 1,
                        duration: 10
                    };
                    
                    // è·å–æ€ªç‰©ä¿¡æ¯ï¼ˆå¦‚æœå·²é€‰æ‹©ï¼‰
                    let monsterInfo = '';
                    if (waveData.monsterId && monsterTable.length > 0) {
                        const monster = monsterTable.find(m => m.id === waveData.monsterId);
                        if (monster) {
                            monsterInfo = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        }
                    }
                    
                    const waveCard = document.createElement('div');
                    waveCard.id = `battle-wave-card-${wave}`;
                    waveCard.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;';
                    
                    // ç¬¬ä¸€æ³¢æ·»åŠ å¤åˆ¶æŒ‰é’®
                    const copyButtonHtml = wave === 1 ? `
                        <div style="margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 8px;">
                            <button class="btn btn-secondary" onclick="copyWave1ToOthers()" style="padding: 8px 16px; font-size: 0.9em; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                                ğŸ“‹ å¤åˆ¶åˆ°å…¶ä»–æ³¢æ¬¡
                            </button>
                            <button class="btn btn-secondary" onclick="copyWave1MonsterIdToOthers()" style="padding: 8px 16px; font-size: 0.9em; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                                ğŸ¯ ä»…å¤åˆ¶æ€ªç‰©IDåˆ°å…¶ä»–æ³¢æ¬¡
                            </button>
                        </div>
                    ` : '';
                    
                    waveCard.innerHTML = `
                        <div style="font-weight: 600; color: #333; margin-bottom: 10px; font-size: 1.05em;">ç¬¬ ${wave} æ³¢</div>
                        ${copyButtonHtml}
                        <div class="input-group" style="margin-bottom: 10px;">
                            <label style="font-size: 0.9em;">æ€ªç‰©ID</label>
                            <select id="battle-wave-${wave}-monster" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                                <option value="">æ‰‹åŠ¨è¾“å…¥</option>
                            </select>
                            <div style="font-size: 0.8em; color: #999; margin-top: 4px;" id="battle-wave-${wave}-monster-info">${monsterInfo}</div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.85em;">æ”»å‡»åŠ›</label>
                                <input type="number" id="battle-wave-${wave}-attack" min="0" value="${waveData.attack}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">é˜²å¾¡åŠ›</label>
                                <input type="number" id="battle-wave-${wave}-defense" min="0" value="${waveData.defense}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">ç”Ÿå‘½å€¼</label>
                                <input type="number" id="battle-wave-${wave}-hp" min="0" value="${waveData.hp}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.85em;">æ”»é€Ÿ</label>
                                <input type="number" id="battle-wave-${wave}-atkSpeed" min="0.1" max="10" step="0.01" value="${waveData.atkSpeed}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">ä¼¤å®³ç³»æ•°</label>
                                <input type="number" id="battle-wave-${wave}-damageCoeff" min="0" step="0.01" value="${waveData.damageCoeff}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.85em;">ç”Ÿå‘½å€¼å€ç‡</label>
                                <input type="number" id="battle-wave-${wave}-hpCoeff" min="0" step="0.01" value="${waveData.hpCoeff}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 6px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.9em;">æ¯ç§’å‡ºå‡ åª</label>
                                <input type="number" id="battle-wave-${wave}-spawnRate" min="0.1" max="100" step="0.1" value="${waveData.spawnRate}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.9em;">æŒç»­å¤šå°‘ç§’</label>
                                <input type="number" id="battle-wave-${wave}-duration" min="1" max="1000" step="1" value="${waveData.duration}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px;">
                            <div class="input-group">
                                <label style="font-size: 0.9em;">å‡»æ€é“¶å¸å¥–åŠ±</label>
                                <input type="number" id="battle-wave-${wave}-coinReward" min="0" value="${waveData.coinReward || 0}" onchange="updateBattleWaveData(${wave})" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;" />
                            </div>
                        </div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                            <div>æ€»æ€ªç‰©æ•°: <span id="battle-wave-${wave}-total-count">-</span></div>
                        </div>
                    `;
                    groupGrid.appendChild(waveCard);
                }
                
                groupContainer.appendChild(groupGrid);
                grid.appendChild(groupContainer);
            }
            
            // æ›´æ–°æ‰€æœ‰æ³¢æ¬¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
            updateBattleWaveMonsterSelects();
            
            // æ›´æ–°æ‰€æœ‰æ³¢æ¬¡çš„æ€»æ€ªç‰©æ•°æ˜¾ç¤º
            updateBattleWaveTotalCounts();
        }

        // æ›´æ–°æ‰€æœ‰æ³¢æ¬¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateBattleWaveMonsterSelects() {
            for (let wave = 1; wave <= 25; wave++) {
                const select = document.getElementById(`battle-wave-${wave}-monster`);
                if (!select) continue;
                
                // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
                const currentValue = select.value || battleWaveData[wave]?.monsterId || '';
                
                // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
                select.innerHTML = '<option value="">æ‰‹åŠ¨è¾“å…¥</option>';
                
                if (monsterTable.length > 0) {
                    // æŒ‰IDæ’åº
                    const sortedMonsters = [...monsterTable].sort((a, b) => {
                        const idA = parseInt(a.id) || 0;
                        const idB = parseInt(b.id) || 0;
                        return idA - idB;
                    });
                    
                    sortedMonsters.forEach(monster => {
                        const option = document.createElement('option');
                        option.value = monster.id;
                        option.textContent = `æ€ªç‰© #${monster.id} (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        select.appendChild(option);
                    });
                }
                
                // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
                if (currentValue) {
                    select.value = currentValue;
                    updateBattleWaveData(wave);
                }
            }
        }

        // æ›´æ–°æ³¢æ¬¡æ•°æ®ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateBattleWaveData = function(wave) {
            const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
            const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
            const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
            const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
            const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
            const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
            const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
            const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
            const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
            const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
            const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
            
            if (!monsterSelect || !attackInput || !defenseInput || !hpInput || 
                !atkSpeedInput || !damageCoeffInput || !hpCoeffInput ||
                !spawnRateInput || !durationInput) return;
            
            // æ›´æ–°é…ç½®
            battleWaveData[wave] = {
                monsterId: monsterSelect.value || '',
                attack: parseFloat(attackInput.value) || 10,
                defense: parseFloat(defenseInput.value) || 5,
                hp: parseFloat(hpInput.value) || 50,
                atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                spawnRate: parseFloat(spawnRateInput.value) || 1,
                duration: parseFloat(durationInput.value) || 10,
                coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
            };
            
            // å¦‚æœé€‰æ‹©äº†æ€ªç‰©IDï¼Œè‡ªåŠ¨å¡«å……æ”»é˜²è¡€
            if (battleWaveData[wave].monsterId && monsterTable.length > 0) {
                const monster = monsterTable.find(m => m.id === battleWaveData[wave].monsterId);
                if (monster) {
                    battleWaveData[wave].attack = monster.baseAttack || 10;
                    battleWaveData[wave].defense = monster.baseDefense || 5;
                    battleWaveData[wave].hp = monster.baseHp || 50;
                    
                    // æ›´æ–°è¾“å…¥æ¡†
                    attackInput.value = battleWaveData[wave].attack;
                    defenseInput.value = battleWaveData[wave].defense;
                    hpInput.value = battleWaveData[wave].hp;
                    
                    // æ›´æ–°æ€ªç‰©ä¿¡æ¯æ˜¾ç¤º
                    if (monsterInfo) {
                        monsterInfo.textContent = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        monsterInfo.style.color = '#51cf66';
                    }
                } else {
                    if (monsterInfo) {
                        monsterInfo.textContent = ' (æ€ªç‰©ä¸å­˜åœ¨)';
                        monsterInfo.style.color = '#f44336';
                    }
                }
            } else {
                if (monsterInfo) {
                    monsterInfo.textContent = '';
                }
            }
            
            // æ›´æ–°æ€»æ€ªç‰©æ•°æ˜¾ç¤º
            updateBattleWaveTotalCount(wave);
        };

        // æ›´æ–°å•ä¸ªæ³¢æ¬¡çš„æ€»æ€ªç‰©æ•°æ˜¾ç¤º
        function updateBattleWaveTotalCount(wave) {
            const totalCountEl = document.getElementById(`battle-wave-${wave}-total-count`);
            if (!totalCountEl) return;
            
            const waveData = battleWaveData[wave];
            if (!waveData) {
                totalCountEl.textContent = '-';
                return;
            }
            
            const totalCount = Math.floor(waveData.spawnRate * waveData.duration);
            totalCountEl.textContent = totalCount;
        }

        // æ›´æ–°æ‰€æœ‰æ³¢æ¬¡çš„æ€»æ€ªç‰©æ•°æ˜¾ç¤º
        function updateBattleWaveTotalCounts() {
            for (let wave = 1; wave <= 25; wave++) {
                updateBattleWaveTotalCount(wave);
            }
        }
        
        // å¤åˆ¶ç¬¬ä¸€æ³¢æ•°æ®åˆ°å…¶ä»–æ³¢æ¬¡
        window.copyWave1ToOthers = function() {
            // ä»ç•Œé¢è¯»å–ç¬¬ä¸€æ³¢çš„æ‰€æœ‰æ•°æ®
            const wave1Data = {
                monsterId: document.getElementById('battle-wave-1-monster')?.value || '',
                attack: parseFloat(document.getElementById('battle-wave-1-attack')?.value) || 10,
                defense: parseFloat(document.getElementById('battle-wave-1-defense')?.value) || 5,
                hp: parseFloat(document.getElementById('battle-wave-1-hp')?.value) || 50,
                atkSpeed: parseFloat(document.getElementById('battle-wave-1-atkSpeed')?.value) || 0.33,
                damageCoeff: parseFloat(document.getElementById('battle-wave-1-damageCoeff')?.value) || 1,
                hpCoeff: parseFloat(document.getElementById('battle-wave-1-hpCoeff')?.value) || 1,
                spawnRate: parseFloat(document.getElementById('battle-wave-1-spawnRate')?.value) || 1,
                duration: parseFloat(document.getElementById('battle-wave-1-duration')?.value) || 10,
                coinReward: parseFloat(document.getElementById('battle-wave-1-coinReward')?.value) || 0
            };
            
            // å¤åˆ¶åˆ°ç¬¬2-25æ³¢
            for (let wave = 2; wave <= 25; wave++) {
                // æ›´æ–°å†…å­˜ä¸­çš„æ•°æ®
                battleWaveData[wave] = {
                    monsterId: wave1Data.monsterId,
                    attack: wave1Data.attack,
                    defense: wave1Data.defense,
                    hp: wave1Data.hp,
                    atkSpeed: wave1Data.atkSpeed,
                    damageCoeff: wave1Data.damageCoeff,
                    hpCoeff: wave1Data.hpCoeff,
                    spawnRate: wave1Data.spawnRate,
                    duration: wave1Data.duration,
                    coinReward: wave1Data.coinReward
                };
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect) monsterSelect.value = wave1Data.monsterId;
                if (attackInput) attackInput.value = wave1Data.attack;
                if (defenseInput) defenseInput.value = wave1Data.defense;
                if (hpInput) hpInput.value = wave1Data.hp;
                if (atkSpeedInput) atkSpeedInput.value = wave1Data.atkSpeed;
                if (damageCoeffInput) damageCoeffInput.value = wave1Data.damageCoeff;
                if (hpCoeffInput) hpCoeffInput.value = wave1Data.hpCoeff;
                if (spawnRateInput) spawnRateInput.value = wave1Data.spawnRate;
                if (durationInput) durationInput.value = wave1Data.duration;
                if (coinRewardInput) coinRewardInput.value = wave1Data.coinReward;
                
                // æ›´æ–°æ€ªç‰©ä¿¡æ¯æ˜¾ç¤º
                if (wave1Data.monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === wave1Data.monsterId);
                    const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
                    if (monsterInfo && monster) {
                        monsterInfo.textContent = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                    } else if (monsterInfo) {
                        monsterInfo.textContent = '';
                    }
                } else {
                    const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
                    if (monsterInfo) monsterInfo.textContent = '';
                }
                
                // æ›´æ–°æ€»æ€ªç‰©æ•°æ˜¾ç¤º
                updateBattleWaveTotalCount(wave);
            }
            
            showMessage('å·²å°†ç¬¬ä¸€æ³¢æ•°æ®å¤åˆ¶åˆ°ç¬¬2-25æ³¢', 'success');
        };
        
        // ä»…å¤åˆ¶ç¬¬ä¸€æ³¢æ€ªç‰©IDåˆ°å…¶ä»–æ³¢æ¬¡ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.copyWave1MonsterIdToOthers = function() {
            const monsterId = document.getElementById('battle-wave-1-monster')?.value || '';
            
            // å¦‚æœé€‰æ‹©äº†æ€ªç‰©IDï¼Œä»æ€ªç‰©è¡¨è·å–æ”»å‡»/é˜²å¾¡/ç”Ÿå‘½å€¼
            let monsterAttack = 10;
            let monsterDefense = 5;
            let monsterHp = 50;
            if (monsterId && monsterTable.length > 0) {
                const monster = monsterTable.find(m => m.id === monsterId);
                if (monster) {
                    monsterAttack = monster.baseAttack || 10;
                    monsterDefense = monster.baseDefense || 5;
                    monsterHp = monster.baseHp || 50;
                }
            }
            
            for (let wave = 2; wave <= 25; wave++) {
                // æ›´æ–°æ€ªç‰©IDå’Œæ”»å‡»/é˜²å¾¡/ç”Ÿå‘½å€¼ï¼Œå…¶ä½™å­—æ®µä¿ç•™å„æ³¢æ¬¡åŸå€¼
                if (battleWaveData[wave]) {
                    battleWaveData[wave].monsterId = monsterId;
                    battleWaveData[wave].attack = monsterAttack;
                    battleWaveData[wave].defense = monsterDefense;
                    battleWaveData[wave].hp = monsterHp;
                } else {
                    battleWaveData[wave] = {
                        monsterId: monsterId,
                        attack: monsterAttack,
                        defense: monsterDefense,
                        hp: monsterHp,
                        atkSpeed: 0.33,
                        damageCoeff: 1,
                        hpCoeff: 1,
                        spawnRate: 1,
                        duration: 10,
                        coinReward: 0
                    };
                }
                
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                
                if (monsterSelect) monsterSelect.value = monsterId;
                if (attackInput) attackInput.value = monsterAttack;
                if (defenseInput) defenseInput.value = monsterDefense;
                if (hpInput) hpInput.value = monsterHp;
                
                // æ›´æ–°æ€ªç‰©ä¿¡æ¯æ˜¾ç¤º
                const monsterInfo = document.getElementById(`battle-wave-${wave}-monster-info`);
                if (monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === monsterId);
                    if (monsterInfo && monster) {
                        monsterInfo.textContent = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        monsterInfo.style.color = '#51cf66';
                    } else if (monsterInfo) {
                        monsterInfo.textContent = monsterId ? ' (æ€ªç‰©ä¸å­˜åœ¨)' : '';
                        monsterInfo.style.color = monsterId ? '#f44336' : '';
                    }
                } else {
                    if (monsterInfo) {
                        monsterInfo.textContent = '';
                    }
                }
                
                updateBattleWaveTotalCount(wave);
            }
            
            showMessage('å·²å°†ç¬¬ä¸€æ³¢æ€ªç‰©IDåŠæ”»å‡»/é˜²å¾¡/ç”Ÿå‘½å€¼å¤åˆ¶åˆ°ç¬¬2-25æ³¢', 'success');
        };
        
        // ========== æ®ç‚¹å¥–åŠ±æ›´æ–°å‡½æ•° ==========
        window.updateStrongholdReward = function(stronghold, reward) {
            strongholdRewards[stronghold] = parseInt(reward) || 0;
        };
        
        // ========== 25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆç®¡ç† ==========
        
        // åŠ è½½25æ³¢æ–¹æ¡ˆåˆ—è¡¨
        function loadBattleWaveSchemes() {
            try {
                const data = localStorage.getItem(BATTLE_WAVE_STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('åŠ è½½25æ³¢æ–¹æ¡ˆå¤±è´¥:', error);
                return [];
            }
        }
        
        // æ›´æ–°25æ³¢æ–¹æ¡ˆä¸‹æ‹‰é€‰æ‹©æ¡†
        function updateBattleWaveSchemeSelect() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl) return;
            
            const schemes = loadBattleWaveSchemes();
            // ä¼˜å…ˆä½¿ç”¨ currentBattleWaveSchemeIdï¼Œç¡®ä¿åˆ‡æ¢ä¸»é…ç½®æ–¹æ¡ˆæ—¶ä¸‹æ‹‰æ¡†èƒ½æ­£ç¡®æ˜¾ç¤º
            const currentValue = currentBattleWaveSchemeId || selectEl.value || '';
            
            // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
            selectEl.innerHTML = '<option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>';
            
            schemes.forEach(scheme => {
                const option = document.createElement('option');
                option.value = scheme.id;
                option.textContent = scheme.name;
                if (scheme.id === currentValue) {
                    option.selected = true;
                }
                selectEl.appendChild(option);
            });
            
            // ç¡®ä¿ä¸‹æ‹‰æ¡†çš„å€¼æ­£ç¡®è®¾ç½®ï¼ˆå¦‚æœ currentBattleWaveSchemeId å­˜åœ¨ï¼‰
            if (currentBattleWaveSchemeId) {
                selectEl.value = currentBattleWaveSchemeId;
            }
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const statusEl = document.getElementById('battleWaveSchemeStatus');
            if (statusEl) {
                if (schemes.length > 0) {
                    statusEl.textContent = `å·²ä¿å­˜ ${schemes.length} ä¸ªæ–¹æ¡ˆï¼ˆæœ€å¤š${MAX_BATTLE_WAVE_SCHEMES}ä¸ªï¼‰`;
                    statusEl.style.color = '#51cf66';
                } else {
                    statusEl.textContent = 'æš‚æ— ä¿å­˜çš„æ–¹æ¡ˆ';
                    statusEl.style.color = '#666';
                }
            }
        }
        
        // ä¿å­˜25æ³¢æ–¹æ¡ˆ
        window.saveBattleWaveScheme = function() {
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (!nameInput) return;
            
            const name = nameInput.value.trim();
            if (!name) {
                showMessage('è¯·è¾“å…¥æ–¹æ¡ˆåç§°', 'error');
                return;
            }
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„25æ³¢æ€ªç‰©æ•°æ®å’Œæ®ç‚¹å¥–åŠ±
            const latestBattleWaveData = {};
            for (let wave = 1; wave <= 25; wave++) {
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect && attackInput && defenseInput && hpInput && 
                    atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                    spawnRateInput && durationInput) {
                    latestBattleWaveData[wave] = {
                        monsterId: monsterSelect.value || '',
                        attack: parseFloat(attackInput.value) || 10,
                        defense: parseFloat(defenseInput.value) || 5,
                        hp: parseFloat(hpInput.value) || 50,
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                        spawnRate: parseFloat(spawnRateInput.value) || 1,
                        duration: parseFloat(durationInput.value) || 10,
                        coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                    };
                }
            }
            
            const schemes = loadBattleWaveSchemes();
            
            // æ£€æŸ¥æ–¹æ¡ˆæ•°é‡
            if (schemes.length >= MAX_BATTLE_WAVE_SCHEMES && !currentBattleWaveSchemeId) {
                showMessage(`æœ€å¤šåªèƒ½ä¿å­˜${MAX_BATTLE_WAVE_SCHEMES}ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆåˆ é™¤ä¸€ä¸ª`, 'error');
                return;
            }
            
            // è¯»å–æ®ç‚¹å¥–åŠ±é…ç½®
            const latestStrongholdRewards = {};
            for (let i = 1; i <= 5; i++) {
                const rewardInput = document.getElementById(`stronghold${i}Reward`);
                latestStrongholdRewards[i] = rewardInput ? (parseInt(rewardInput.value) || 0) : 0;
            }
            
            // è¯»å–æ€ªç‰©æ”»å‡»å»¶è¿Ÿé…ç½®
            const delayInput = document.getElementById('monsterAttackDelayInput');
            const latestMonsterAttackDelay = delayInput ? (parseFloat(delayInput.value) || 3) : 3;
            
            // è¯»å–æ€ªç‰©ä¸å¯è¢«æ”»å‡»æ—¶é—´é…ç½®
            const invincibleInput = document.getElementById('monsterInvincibleTimeInput');
            const latestMonsterInvincibleTime = invincibleInput ? (parseFloat(invincibleInput.value) || 1) : 1;
            
            const schemeData = {
                id: currentBattleWaveSchemeId || Date.now().toString(),
                name: name,
                saveTime: new Date().toISOString(),
                battleWaveData: latestBattleWaveData,
                strongholdRewards: latestStrongholdRewards,
                monsterAttackDelay: latestMonsterAttackDelay,
                monsterInvincibleTime: latestMonsterInvincibleTime
            };
            
            // å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°ï¼›å¦åˆ™æ·»åŠ 
            if (currentBattleWaveSchemeId) {
                const existingIndex = schemes.findIndex(s => s.id === currentBattleWaveSchemeId);
                if (existingIndex >= 0) {
                    schemes[existingIndex] = schemeData;
                } else {
                    schemes.push(schemeData);
                }
            } else {
                schemes.push(schemeData);
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            
            // æ›´æ–°å½“å‰æ–¹æ¡ˆID
            currentBattleWaveSchemeId = schemeData.id;
            
            // æ›´æ–°ä¸‹æ‹‰é€‰æ‹©æ¡†
            updateBattleWaveSchemeSelect();
            
            // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤º
            nameInput.value = name;
            
            showMessage(`25æ³¢æ–¹æ¡ˆ"${name}"å·²ä¿å­˜`, 'success');
        };
        
        // åŠ è½½25æ³¢æ–¹æ¡ˆï¼ˆé€šè¿‡ä¸‹æ‹‰é€‰æ‹©æ¡†ï¼‰
        window.loadBattleWaveScheme = function(schemeId) {
            if (!schemeId) {
                currentBattleWaveSchemeId = null;
                updateBattleWaveSchemeSelect();
                return;
            }
            loadBattleWaveSchemeById(schemeId);
        };
        
        // æ ¹æ®IDåŠ è½½25æ³¢æ–¹æ¡ˆ
        function loadBattleWaveSchemeById(schemeId) {
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            if (!scheme) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            
            // åŠ è½½25æ³¢æ•°æ®
            if (scheme.battleWaveData) {
                for (let wave = 1; wave <= 25; wave++) {
                    if (scheme.battleWaveData[wave]) {
                        battleWaveData[wave] = {
                            monsterId: scheme.battleWaveData[wave].monsterId || '',
                            attack: scheme.battleWaveData[wave].attack !== undefined ? scheme.battleWaveData[wave].attack : 10,
                            defense: scheme.battleWaveData[wave].defense !== undefined ? scheme.battleWaveData[wave].defense : 5,
                            hp: scheme.battleWaveData[wave].hp !== undefined ? scheme.battleWaveData[wave].hp : 50,
                            atkSpeed: scheme.battleWaveData[wave].atkSpeed !== undefined ? scheme.battleWaveData[wave].atkSpeed : 0.33,
                            damageCoeff: scheme.battleWaveData[wave].damageCoeff !== undefined ? scheme.battleWaveData[wave].damageCoeff : 1,
                            hpCoeff: scheme.battleWaveData[wave].hpCoeff !== undefined ? scheme.battleWaveData[wave].hpCoeff : 1,
                            spawnRate: scheme.battleWaveData[wave].spawnRate !== undefined ? scheme.battleWaveData[wave].spawnRate : 1,
                            duration: scheme.battleWaveData[wave].duration !== undefined ? scheme.battleWaveData[wave].duration : 10,
                            coinReward: scheme.battleWaveData[wave].coinReward !== undefined ? scheme.battleWaveData[wave].coinReward : 0
                        };
                    }
                }
            }
            
            // åŠ è½½æ®ç‚¹å¥–åŠ±é…ç½®
            if (scheme.strongholdRewards) {
                for (let i = 1; i <= 5; i++) {
                    strongholdRewards[i] = scheme.strongholdRewards[i] || 0;
                    const rewardInput = document.getElementById(`stronghold${i}Reward`);
                    if (rewardInput) {
                        rewardInput.value = strongholdRewards[i];
                    }
                }
            }
            
            // åŠ è½½æ€ªç‰©æ”»å‡»å»¶è¿Ÿé…ç½®
            if (scheme.monsterAttackDelay !== undefined) {
                monsterAttackDelay = parseFloat(scheme.monsterAttackDelay) || 3;
                const delayInput = document.getElementById('monsterAttackDelayInput');
                if (delayInput) {
                    delayInput.value = monsterAttackDelay;
                }
            }
            
            // åŠ è½½æ€ªç‰©ä¸å¯è¢«æ”»å‡»æ—¶é—´é…ç½®
            if (scheme.monsterInvincibleTime !== undefined) {
                monsterInvincibleTime = parseFloat(scheme.monsterInvincibleTime) || 1;
                const invincibleInput = document.getElementById('monsterInvincibleTimeInput');
                if (invincibleInput) {
                    invincibleInput.value = monsterInvincibleTime;
                }
            }
            
            // é‡æ–°åˆå§‹åŒ–ç•Œé¢ä»¥åº”ç”¨åŠ è½½çš„é…ç½®
            initBattleWaveData();
            
            // æ›´æ–°å½“å‰æ–¹æ¡ˆIDå’Œä¸‹æ‹‰é€‰æ‹©æ¡†
            currentBattleWaveSchemeId = schemeId;
            updateBattleWaveSchemeSelect();
            
            // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤º
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (nameInput) {
                nameInput.value = scheme.name;
            }
            
            showMessage(`å·²åŠ è½½25æ³¢æ–¹æ¡ˆ"${scheme.name}"`, 'success');
        }
        
        // å¤åˆ¶25æ³¢æ–¹æ¡ˆ
        window.copyBattleWaveScheme = function() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl || !selectEl.value) {
                showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ¡ˆ', 'error');
                return;
            }
            
            const schemeId = selectEl.value;
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            
            // æ£€æŸ¥æ–¹æ¡ˆæ•°é‡
            if (schemes.length >= MAX_BATTLE_WAVE_SCHEMES) {
                showMessage(`æœ€å¤šåªèƒ½ä¿å­˜${MAX_BATTLE_WAVE_SCHEMES}ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆåˆ é™¤ä¸€ä¸ª`, 'error');
                return;
            }
            
            // åˆ›å»ºæ–°æ–¹æ¡ˆï¼ˆå¤åˆ¶æ•°æ®ï¼‰
            const newScheme = {
                id: Date.now().toString(),
                name: `${scheme.name} - å‰¯æœ¬`,
                saveTime: new Date().toISOString(),
                battleWaveData: JSON.parse(JSON.stringify(scheme.battleWaveData || {})), // æ·±æ‹·è´25æ³¢æ€ªç‰©æ•°æ®
                strongholdRewards: JSON.parse(JSON.stringify(scheme.strongholdRewards || {})), // æ·±æ‹·è´æ®ç‚¹å¥–åŠ±
                monsterAttackDelay: scheme.monsterAttackDelay !== undefined ? scheme.monsterAttackDelay : 3 // å¤åˆ¶æ€ªç‰©æ”»å‡»å»¶è¿Ÿ
            };
            
            // å¦‚æœåç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
            let copyName = newScheme.name;
            let copyIndex = 1;
            while (schemes.some(s => s.name === copyName)) {
                copyName = `${scheme.name} - å‰¯æœ¬${copyIndex}`;
                copyIndex++;
            }
            newScheme.name = copyName;
            
            // æ·»åŠ åˆ°åˆ—è¡¨
            schemes.push(newScheme);
            localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            
            // åŠ è½½æ–°å¤åˆ¶çš„æ–¹æ¡ˆ
            currentBattleWaveSchemeId = newScheme.id;
            loadBattleWaveSchemeById(newScheme.id);
            
            // æ›´æ–°æ–¹æ¡ˆåç§°è¾“å…¥æ¡†
            const nameInput = document.getElementById('battleWaveSchemeNameInput');
            if (nameInput) nameInput.value = copyName;
            
            showMessage(`å·²å¤åˆ¶æ–¹æ¡ˆ"${scheme.name}"ä¸º"${copyName}"`, 'success');
        };
        
        // åˆ é™¤25æ³¢æ–¹æ¡ˆ
        window.deleteBattleWaveScheme = function() {
            const selectEl = document.getElementById('battleWaveSchemeSelect');
            if (!selectEl || !selectEl.value) {
                showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ¡ˆ', 'error');
                return;
            }
            
            const schemeId = selectEl.value;
            const schemes = loadBattleWaveSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–¹æ¡ˆ"${scheme.name}"å—ï¼Ÿ`)) {
                return;
            }
            
            // åˆ é™¤æ–¹æ¡ˆ
            const index = schemes.findIndex(s => s.id === schemeId);
            if (index >= 0) {
                schemes.splice(index, 1);
                localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(schemes));
            }
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ–¹æ¡ˆï¼Œæ¸…ç©ºå½“å‰æ–¹æ¡ˆID
            if (currentBattleWaveSchemeId === schemeId) {
                currentBattleWaveSchemeId = null;
                const nameInput = document.getElementById('battleWaveSchemeNameInput');
                if (nameInput) nameInput.value = '';
            }
            
            // æ›´æ–°ä¸‹æ‹‰é€‰æ‹©æ¡†
            updateBattleWaveSchemeSelect();
            
            // æ¸…ç©ºé€‰æ‹©
            selectEl.value = '';
            
            showMessage(`æ–¹æ¡ˆ"${scheme.name}"å·²åˆ é™¤`, 'success');
        };

        // æ›´æ–°å…³å¡é…ç½®ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateStageConfig = function(stage) {
            const monsterSelect = document.getElementById(`stage-${stage}-monster`);
            const atkSpeedInput = document.getElementById(`stage-${stage}-atkSpeed`);
            const damageCoeffInput = document.getElementById(`stage-${stage}-damageCoeff`);
            const hpCoeffInput = document.getElementById(`stage-${stage}-hpCoeff`);
            const monsterInfo = document.getElementById(`stage-${stage}-monster-info`);
            
            if (!monsterSelect || !atkSpeedInput || !damageCoeffInput || !hpCoeffInput) return;
            
            // æ›´æ–°é…ç½®
            stageConfig[stage] = {
                monsterId: monsterSelect.value || '',
                atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                hpCoeff: parseFloat(hpCoeffInput.value) || 0
            };
            
            // æ›´æ–°æ€ªç‰©ä¿¡æ¯æ˜¾ç¤º
            if (monsterInfo) {
                if (stageConfig[stage].monsterId && monsterTable.length > 0) {
                    const monster = monsterTable.find(m => m.id === stageConfig[stage].monsterId);
                    if (monster) {
                        monsterInfo.textContent = ` (æ”»${monster.baseAttack} é˜²${monster.baseDefense} è¡€${monster.baseHp})`;
                        monsterInfo.style.color = '#51cf66';
                    } else {
                        monsterInfo.textContent = ' (æ€ªç‰©ä¸å­˜åœ¨)';
                        monsterInfo.style.color = '#f44336';
                    }
                } else {
                    monsterInfo.textContent = '';
                }
            }
            
            // æ›´æ–°ä¼¤å®³ä¿¡æ¯æ˜¾ç¤º
            updateStageDamageInfo(stage);
        };

        // æ›´æ–°å…³å¡ä¼¤å®³ä¿¡æ¯æ˜¾ç¤º
        function updateStageDamageInfo(stage) {
            const stageData = stageConfig[stage];
            if (!stageData || !stageData.monsterId) {
                // å¦‚æœæ²¡æœ‰é€‰æ‹©æ€ªç‰©ï¼Œæ¸…ç©ºæ˜¾ç¤º
                const monsterToChar1 = document.getElementById(`stage-${stage}-monster-to-char1`);
                const char1ToMonster = document.getElementById(`stage-${stage}-char1-to-monster`);
                const char34Avg = document.getElementById(`stage-${stage}-char34-avg`);
                if (monsterToChar1) monsterToChar1.textContent = '-';
                if (char1ToMonster) char1ToMonster.textContent = '-';
                if (char34Avg) char34Avg.textContent = '-';
                return;
            }
            
            // ä»æ€ªç‰©è¡¨è·å–æ€ªç‰©å±æ€§
            const monster = monsterTable.find(m => m.id === stageData.monsterId);
            if (!monster) {
                const monsterToChar1 = document.getElementById(`stage-${stage}-monster-to-char1`);
                const char1ToMonster = document.getElementById(`stage-${stage}-char1-to-monster`);
                const char34Avg = document.getElementById(`stage-${stage}-char34-avg`);
                if (monsterToChar1) monsterToChar1.textContent = '-';
                if (char1ToMonster) char1ToMonster.textContent = '-';
                if (char34Avg) char34Avg.textContent = '-';
                return;
            }
            
            // è·å–è§’è‰²1çš„æœ€ç»ˆå±æ€§ï¼ˆéœ€è¦å…ˆåº”ç”¨è£…å¤‡ã€å¹³å°ã€è½¦è¾†åŠ æˆï¼‰
            const char1 = characters.find(c => c.id === 1);
            if (!char1) return;
            
            // ä¸´æ—¶åº”ç”¨å±æ€§è®¡ç®—ï¼ˆç¡®ä¿æœ‰æœ€æ–°çš„æœ€ç»ˆå±æ€§ï¼‰
            applyJobEquipmentStats(char1);
            const char1FinalAttack = char1.attack || 0;
            const char1FinalDefense = char1.defense || 0;
            
            // è·å–è§’è‰²3å’Œè§’è‰²4çš„æœ€ç»ˆå±æ€§
            const char3 = characters.find(c => c.id === 3);
            const char4 = characters.find(c => c.id === 4);
            let char3FinalAttack = 0;
            let char4FinalAttack = 0;
            if (char3) {
                applyJobEquipmentStats(char3);
                char3FinalAttack = char3.attack || 0;
            }
            if (char4) {
                applyJobEquipmentStats(char4);
                char4FinalAttack = char4.attack || 0;
            }
            
            // è®¡ç®—æ€ªç‰©æœ€ç»ˆæ”»å‡»åŠ›ï¼ˆåº”ç”¨æ”»å‡»ç³»æ•°ï¼‰
            const monsterFinalAttack = (monster.baseAttack || 0) * (stageData.damageCoeff || 1);
            const monsterDefense = monster.baseDefense || 0;
            
            // 1. æ€ªç‰©å¯¹è§’è‰²1åŸºç¡€ä¼¤å®³ = æ€ªç‰©æœ€ç»ˆæ”»å‡»åŠ› - è§’è‰²1æœ€ç»ˆé˜²å¾¡åŠ›
            const monsterToChar1Damage = Math.max(1, Math.floor(monsterFinalAttack - char1FinalDefense));
            
            // 2. è§’è‰²1å¯¹æ€ªç‰©åŸºç¡€ä¼¤å®³ = è§’è‰²1æœ€ç»ˆæ”»å‡»åŠ› - æ€ªç‰©é˜²å¾¡åŠ›
            const char1ToMonsterDamage = Math.max(1, Math.floor(char1FinalAttack - monsterDefense));
            
            // 3. è§’è‰²3/è§’è‰²4å¹³å‡åŸºç¡€ä¼¤å®³ = (è§’è‰²3æ”»å‡»åŠ› + è§’è‰²4æ”»å‡»åŠ›) / 2 - æ€ªç‰©é˜²å¾¡åŠ›
            const char34AvgAttack = (char3FinalAttack + char4FinalAttack) / 2;
            const char34AvgDamage = Math.max(1, Math.floor(char34AvgAttack - monsterDefense));
            
            // æ›´æ–°æ˜¾ç¤º
            const monsterToChar1El = document.getElementById(`stage-${stage}-monster-to-char1`);
            const char1ToMonsterEl = document.getElementById(`stage-${stage}-char1-to-monster`);
            const char34AvgEl = document.getElementById(`stage-${stage}-char34-avg`);
            
            if (monsterToChar1El) {
                monsterToChar1El.textContent = `${monsterFinalAttack.toFixed(0)} - ${char1FinalDefense.toFixed(0)} = ${monsterToChar1Damage}`;
            }
            if (char1ToMonsterEl) {
                char1ToMonsterEl.textContent = `${char1FinalAttack.toFixed(0)} - ${monsterDefense.toFixed(0)} = ${char1ToMonsterDamage}`;
            }
            if (char34AvgEl) {
                char34AvgEl.textContent = `${char34AvgAttack.toFixed(0)} - ${monsterDefense.toFixed(0)} = ${char34AvgDamage}`;
            }
        }

        // æŒ‘æˆ˜å…³å¡ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.challengeStage = function(stage) {
            const stageData = stageConfig[stage];
            if (!stageData || !stageData.monsterId) {
                if (!window.isChallengingAll) {
                    showMessage('è¯·å…ˆé€‰æ‹©æ€ªç‰©ID', 'error');
                }
                return false; // è¿”å›falseè¡¨ç¤ºè·³è¿‡
            }
            
            // ä»æ€ªç‰©è¡¨è·å–æ€ªç‰©å±æ€§
            const monster = monsterTable.find(m => m.id === stageData.monsterId);
            if (!monster) {
                if (!window.isChallengingAll) {
                    showMessage('æ€ªç‰©ä¸å­˜åœ¨', 'error');
                }
                return false; // è¿”å›falseè¡¨ç¤ºè·³è¿‡
            }
            
            // å°†æ€ªç‰©å±æ€§åº”ç”¨åˆ°æ€ªç‰©é…ç½®æ¨¡å—
            document.getElementById('monsterAttack').value = monster.baseAttack || 10;
            document.getElementById('monsterDefense').value = monster.baseDefense || 5;
            document.getElementById('monsterHp').value = monster.baseHp || 50;
            document.getElementById('monsterAtkSpeed').value = stageData.atkSpeed || 0.33;
            document.getElementById('monsterDamageCoeff').value = stageData.damageCoeff || 1;
            document.getElementById('monsterHpCoeff').value = stageData.hpCoeff || 0;
            
            // æ›´æ–°æ€ªç‰©é…ç½®
            updateMonsterConfig();
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœæ˜¾ç¤º
            const resultDiv = document.getElementById(`stage-${stage}-result`);
            const stageCard = document.getElementById(`stage-card-${stage}`);
            if (resultDiv) {
                resultDiv.textContent = 'æŒ‘æˆ˜ä¸­...';
                resultDiv.style.color = '#666';
            }
            if (stageCard) {
                stageCard.style.background = 'white';
                stageCard.style.borderColor = '#e0e0e0';
            }
            
            // ä¿å­˜å½“å‰å…³å¡å·ï¼Œç”¨äºæˆ˜æ–—ç»“æŸååˆ¤æ–­
            window.currentChallengeStage = stage;
            
            // æ‰§è¡Œå¿«é€Ÿæˆ˜æ–—
            quickBattle();
            
            return true; // è¿”å›trueè¡¨ç¤ºæˆåŠŸæ‰§è¡Œ
        };

        // ä¸€é”®æŒ‘æˆ˜æ‰€æœ‰å…³å¡ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.challengeAllStages = function() {
            // æ£€æŸ¥æ˜¯å¦æœ‰å·²é…ç½®çš„å…³å¡
            let hasConfiguredStage = false;
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage];
                if (stageData && stageData.monsterId) {
                    hasConfiguredStage = true;
                    break;
                }
            }
            
            if (!hasConfiguredStage) {
                showMessage('è¯·è‡³å°‘é…ç½®ä¸€ä¸ªå…³å¡çš„æ€ªç‰©ID', 'error');
                return;
            }
            
            // è®¾ç½®ä¸€é”®æŒ‘æˆ˜æ ‡å¿—
            window.isChallengingAll = true;
            
            // æ›´æ–°è¿›åº¦æ˜¾ç¤º
            const progressEl = document.getElementById('allStagesProgress');
            if (progressEl) {
                progressEl.textContent = 'å‡†å¤‡å¼€å§‹æŒ‘æˆ˜æ‰€æœ‰å…³å¡...';
                progressEl.style.color = '#666';
            }
            
            // ä¾æ¬¡æŒ‘æˆ˜æ‰€æœ‰å…³å¡ï¼ˆåŒæ­¥æ‰§è¡Œï¼Œå› ä¸ºquickBattleæ˜¯åŒæ­¥çš„ï¼‰
            let completedCount = 0;
            let skippedCount = 0;
            
            for (let stage = 1; stage <= 20; stage++) {
                const stageData = stageConfig[stage];
                
                // æ›´æ–°è¿›åº¦
                if (progressEl) {
                    progressEl.textContent = `æ­£åœ¨æŒ‘æˆ˜ç¬¬ ${stage} å…³... (${completedCount} å®Œæˆ, ${skippedCount} è·³è¿‡)`;
                }
                
                // å¦‚æœè¯¥å…³å¡æ²¡æœ‰é…ç½®æ€ªç‰©IDï¼Œè·³è¿‡
                if (!stageData || !stageData.monsterId) {
                    skippedCount++;
                    continue;
                }
                
                // æŒ‘æˆ˜è¯¥å…³å¡
                const success = challengeStage(stage);
                if (success) {
                    completedCount++;
                } else {
                    skippedCount++;
                }
            }
            
            // æ¸…ç©ºä¸€é”®æŒ‘æˆ˜æ ‡å¿—
            window.isChallengingAll = false;
            
            // æ›´æ–°æœ€ç»ˆè¿›åº¦
            if (progressEl) {
                progressEl.textContent = `å…¨éƒ¨å®Œæˆï¼å…±æŒ‘æˆ˜ ${completedCount} å…³ï¼Œè·³è¿‡ ${skippedCount} å…³`;
                progressEl.style.color = '#51cf66';
            }
            
            showMessage(`ä¸€é”®æŒ‘æˆ˜å®Œæˆï¼å…±æŒ‘æˆ˜ ${completedCount} å…³ï¼Œè·³è¿‡ ${skippedCount} å…³`, 'success');
        };

        // æ£€æŸ¥å…³å¡æŒ‘æˆ˜ç»“æœï¼ˆåœ¨æˆ˜æ–—ç»“æŸåè°ƒç”¨ï¼‰
        function checkStageResult() {
            if (window.currentChallengeStage === undefined) return;
            
            const stage = window.currentChallengeStage;
            const resultDiv = document.getElementById(`stage-${stage}-result`);
            const stageCard = document.getElementById(`stage-card-${stage}`);
            
            if (!resultDiv || !stageCard) return;
            
            // æŸ¥æ‰¾è§’è‰²1ï¼ˆIDä¸º1ï¼‰
            const char1 = battleState.characters.find(c => c.id === 1);
            let char1DeathTime = null;
            let deathTimeDisplay = '';
            let multiplierDisplay = '';
            
            // æ£€æŸ¥è§’è‰²1æ˜¯å¦"å‡ ä¹ä¸ä¼šæ­»"ï¼ˆè¶…è¿‡200ç§’ä»å­˜æ´»ï¼‰
            if (battleState.char1NeverDies) {
                // å¦‚æœè§’è‰²1"å‡ ä¹ä¸ä¼šæ­»"ï¼Œä½¿ç”¨200ç§’ä½œä¸ºæ­»äº¡æ—¶é—´ï¼ˆæˆ–å®é™…æˆ˜æ–—æ—¶é•¿ï¼Œå–è¾ƒå¤§å€¼ï¼‰
                char1DeathTime = Math.max(200, battleState.elapsedTime);
                deathTimeDisplay = `æ­»äº¡æ—¶é—´: å‡ ä¹ä¸ä¼šæ­»ï¼ˆ${formatTime(char1DeathTime)}ï¼‰`;
                const multiplier = (char1DeathTime / 50).toFixed(2);
                multiplierDisplay = `å€ç‡: ${multiplier}x`;
                resultDiv.innerHTML = `âœ“ å¯é€šå…³ï¼ˆè§’è‰²1ä¸ä¼šæ­»ï¼‰<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}ï¼Œ${multiplierDisplay}</span>`;
                resultDiv.style.color = '#51cf66';
                stageCard.style.background = '#e8f5e9';
                stageCard.style.borderColor = '#51cf66';
                // æ¸…ç©ºå½“å‰æŒ‘æˆ˜å…³å¡æ ‡è®°
                window.currentChallengeStage = undefined;
                return;
            }
            
            // å¦‚æœè§’è‰²1æ­»äº¡ï¼Œè·å–å…¶æ­»äº¡æ—¶é—´
            if (char1 && !char1.isAlive) {
                // ä½¿ç”¨è®°å½•çš„æ­»äº¡æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨firstCharacterDeathTimeï¼ˆå¦‚æœè§’è‰²1æ˜¯ç¬¬ä¸€ä¸ªæ­»äº¡çš„ï¼‰
                char1DeathTime = char1.deathTime || (char1.id === 1 && battleState.firstCharacterDeathTime);
            } else if (char1 && char1.isAlive) {
                // å¦‚æœè§’è‰²1å­˜æ´»ï¼Œä½¿ç”¨æˆ˜æ–—æ€»æ—¶é•¿
                char1DeathTime = battleState.elapsedTime;
            }
            
            // åˆ¤æ–­æ˜¯å¦é€šå…³ï¼šè§’è‰²1æ­»äº¡æ—¶é—´å¤§äº50ç§’ï¼Œæˆ–è€…è§’è‰²1æœªæ­»äº¡ï¼ˆå­˜æ´»è¶…è¿‡50ç§’ï¼‰
            // å¦‚æœè§’è‰²1æ­»äº¡ï¼Œæ£€æŸ¥æ­»äº¡æ—¶é—´æ˜¯å¦å¤§äº50ç§’
            const isPassed = char1DeathTime === null || char1DeathTime > 50;
            
            // æ ¼å¼åŒ–æ­»äº¡æ—¶é—´æ˜¾ç¤º
            if (char1DeathTime !== null) {
                deathTimeDisplay = `æ­»äº¡æ—¶é—´: ${formatTime(char1DeathTime)}`;
                const multiplier = (char1DeathTime / 50).toFixed(2);
                multiplierDisplay = `å€ç‡: ${multiplier}x`;
            } else {
                deathTimeDisplay = 'æ­»äº¡æ—¶é—´: æœªçŸ¥';
                multiplierDisplay = 'å€ç‡: -';
            }
            
            if (isPassed) {
                resultDiv.innerHTML = `âœ“ å¯é€šå…³<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}ï¼Œ${multiplierDisplay}</span>`;
                resultDiv.style.color = '#51cf66';
                stageCard.style.background = '#e8f5e9';
                stageCard.style.borderColor = '#51cf66';
            } else {
                resultDiv.innerHTML = `âœ— å±æ€§ä¸è¶³ï¼ŒæŒ‘æˆ˜å¤±è´¥<br><span style="font-size: 0.85em; color: #666;">${deathTimeDisplay}ï¼Œ${multiplierDisplay}</span>`;
                resultDiv.style.color = '#f44336';
                stageCard.style.background = '#ffebee';
                stageCard.style.borderColor = '#f44336';
            }
            
            // æ¸…ç©ºå½“å‰æŒ‘æˆ˜å…³å¡æ ‡è®°
            window.currentChallengeStage = undefined;
        }

        function initCharacters() {
            const grid = document.getElementById('charactersGrid');
            if (!grid) {
                console.error('æ‰¾ä¸åˆ°charactersGridå…ƒç´ ');
                return;
            }
            if (!characters || characters.length === 0) {
                console.error('charactersæ•°ç»„ä¸ºç©º');
                return;
            }
            grid.innerHTML = characters.map(char => {
                const heroQuality = getCharacterHeroQuality(char.id);
                const qualityBg = getQualityBgColor(heroQuality);
                return `
                <div class="character-card" data-char-id="${char.id}" style="background: ${qualityBg.bg}; border-color: ${qualityBg.border};">
                    <div class="character-header">
                        <div class="character-name">${char.name}</div>
                        <span class="character-job" style="font-size: 0.85em; color: #667eea; font-weight: 600; margin-left: 8px;">[${JOB_NAMES[char.job]}]</span>
                        <span class="character-status status-alive" id="status-${char.id}">å­˜æ´»</span>
                    </div>
                    <div class="input-group">
                        <label>é€‰æ‹©è‹±é›„</label>
                        <select class="char-hero-select" data-char="${char.id}" onchange="updateCharacterHero(${char.id}, this.value)" style="width: 100%; padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">è¯·é€‰æ‹©è‹±é›„</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>é€‰æ‹©ç­‰çº§</label>
                        <select class="char-hero-level-select" data-char="${char.id}" onchange="updateCharacterHeroLevel(${char.id}, this.value)" style="width: 100%; padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95em;">
                            <option value="">è¯·å…ˆé€‰æ‹©è‹±é›„</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>åŸºç¡€æ”»å‡»åŠ›</label>
                        <input type="number" class="char-attack" data-char="${char.id}" min="1" value="${char.baseAttack || char.attack}" onchange="updateCharacter(${char.id}, 'attack', this.value)" />
                    </div>
                    <div class="input-group">
                        <label>åŸºç¡€é˜²å¾¡åŠ›</label>
                        <input type="number" class="char-defense" data-char="${char.id}" min="0" value="${char.baseDefense || char.defense}" onchange="updateCharacter(${char.id}, 'defense', this.value)" />
                    </div>
                    <div class="input-group">
                        <label>åŸºç¡€è¡€é‡</label>
                        <input type="number" class="char-hp" data-char="${char.id}" min="1" value="${char.baseHp || char.hp}" onchange="updateCharacter(${char.id}, 'hp', this.value)" />
                    </div>
                    ${char.id === 1 ? `
                    <div class="input-group">
                        <label>å‡ä¼¤ç™¾åˆ†æ¯”ï¼ˆ%ï¼‰</label>
                        <input type="number" class="char-damageReduction" data-char="${char.id}" min="0" max="100" step="0.1" value="${char.damageReduction || 0}" onchange="updateCharacter(${char.id}, 'damageReduction', this.value)" />
                    </div>
                    ` : ''}
                    ${(char.id === 2 || char.id === 3 || char.id === 4) ? `
                    <div class="input-group">
                        <label>æŠ€èƒ½ä¼¤å®³ç³»æ•°ï¼ˆ%ï¼‰</label>
                        <input type="number" class="char-skillDamage" data-char="${char.id}" min="-1000" step="0.1" value="${char.skillDamage || 0}" onchange="updateCharacter(${char.id}, 'skillDamage', this.value)" />
                    </div>
                    ` : ''}
                    ${char.id === 5 ? `
                    <div class="input-group">
                        <label>å›è¡€ç³»æ•°</label>
                        <input type="number" class="char-heal" data-char="${char.id}" min="0" step="0.01" value="${char.healRate || 0}" onchange="updateCharacter(${char.id}, 'healRate', this.value)" />
                        <div style="font-size: 0.8em; color: #666; margin-top: 4px;">æœ€ç»ˆå›è¡€é€Ÿåº¦ = æœ€ç»ˆæ”»å‡»åŠ› Ã— å›è¡€ç³»æ•°</div>
                    </div>
                    ` : ''}
                    <div class="hp-bar" style="display: none;">
                        <div class="hp-fill" id="hp-bar-${char.id}" style="width: 100%;"></div>
                    </div>
                </div>
            `;
            }).join('');
            
            // æ›´æ–°æ‰€æœ‰è§’è‰²çš„è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
            updateAllCharacterHeroSelects();
        }

        // æ›´æ–°æ‰€æœ‰è§’è‰²çš„è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateAllCharacterHeroSelects() {
            characters.forEach(char => {
                updateCharacterHeroSelect(char.id);
            });
        }

        // æ›´æ–°å•ä¸ªè§’è‰²çš„è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateCharacterHeroSelect(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char) return;
            
            const heroSelect = document.querySelector(`.char-hero-select[data-char="${charId}"]`);
            if (!heroSelect) return;
            
            heroSelect.innerHTML = '<option value="">è¯·é€‰æ‹©è‹±é›„</option>';
            
            if (heroTable.length === 0) {
                heroSelect.innerHTML = '<option value="">è¯·å…ˆä¸Šä¼ è‹±é›„è¡¨</option>';
                return;
            }
            
            // ç­›é€‰ä¸è§’è‰²èŒä¸šç›¸åŒçš„è‹±é›„
            let jobHeroes = heroTable.filter(hero => {
                const heroJob = parseInt(hero.heroclass) || 0;
                return heroJob === char.job;
            });
            
            // è‹¥å‹¾é€‰è¯»å–ç»æµæ¨¡æ‹Ÿï¼šä»…ä¿ç•™ç»æµæ–¹æ¡ˆä¸­å·²æœ‰çš„è‹±é›„
            const eco = getMainConfigEconomySchemeData();
            if (useEconomySimulation && eco && Array.isArray(eco.playerHeroes)) {
                const allowedIds = new Set(eco.playerHeroes.map(h => String(h.heroId)));
                jobHeroes = jobHeroes.filter(hero => allowedIds.has(String(hero.id)));
                
                // é»˜è®¤çš„5ä¸ªè§’è‰²IDï¼ˆè§’è‰²1-5å¯¹åº”ï¼‰
                const defaultHeroIds = ['11001', '11002', '11003', '11101', '11102'];
                const defaultHeroId = defaultHeroIds[charId - 1];
                
                // å¦‚æœè§’è‰²é€‰æ‹©çš„è‹±é›„ä¸å­˜åœ¨äºç»æµæ–¹æ¡ˆä¸­ï¼Œè®¾ç½®ä¸ºé»˜è®¤è‹±é›„
                if (char.selectedHeroId && !allowedIds.has(String(char.selectedHeroId))) {
                    // æ£€æŸ¥é»˜è®¤è‹±é›„æ˜¯å¦å­˜åœ¨äºç»æµæ–¹æ¡ˆä¸­
                    if (defaultHeroId && allowedIds.has(defaultHeroId)) {
                        char.selectedHeroId = defaultHeroId;
                        char.selectedHeroLevel = 1; // è®¾ç½®ä¸º1çº§
                    } else {
                        char.selectedHeroId = null;
                        char.selectedHeroLevel = null;
                    }
                    const levelSel = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
                    if (levelSel) levelSel.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©è‹±é›„</option>';
                }
                
                // å¦‚æœè§’è‰²æ²¡æœ‰é€‰æ‹©è‹±é›„ï¼Œä¸”é»˜è®¤è‹±é›„å­˜åœ¨äºç»æµæ–¹æ¡ˆä¸­ï¼Œè‡ªåŠ¨è®¾ç½®ä¸ºé»˜è®¤è‹±é›„
                if (!char.selectedHeroId && defaultHeroId && allowedIds.has(defaultHeroId)) {
                    const defaultHero = heroTable.find(h => String(h.id) === defaultHeroId);
                    if (defaultHero) {
                        char.selectedHeroId = defaultHeroId;
                        char.selectedHeroLevel = 1; // è®¾ç½®ä¸º1çº§
                    }
                }
            }
            
            if (jobHeroes.length === 0) {
                heroSelect.innerHTML = '<option value="">æš‚æ— è¯¥èŒä¸šçš„è‹±é›„</option>';
                return;
            }
            
            // æŒ‰IDæ’åº
            const sortedHeroes = [...jobHeroes].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedHeroes.forEach(hero => {
                const option = document.createElement('option');
                option.value = hero.id;
                option.textContent = `${hero.id} - ${hero.namecn}${hero.quality ? ' [' + hero.quality + ']' : ''}`;
                
                if (char.selectedHeroId === hero.id) option.selected = true;
                heroSelect.appendChild(option);
            });
            
            if (char.selectedHeroId) updateCharacterHeroLevelSelect(charId);
        }

        // æ›´æ–°è§’è‰²çš„ç­‰çº§é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateCharacterHeroLevelSelect(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.selectedHeroId) return;
            
            const levelSelect = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
            if (!levelSelect) return;
            
            const hero = heroTable.find(h => h.id === char.selectedHeroId);
            if (!hero) {
                levelSelect.innerHTML = '<option value="">è‹±é›„ä¸å­˜åœ¨</option>';
                return;
            }
            
            levelSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ç­‰çº§</option>';
            
            let levels = hero.levels ? Object.keys(hero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
            
            // è‹¥å‹¾é€‰è¯»å–ç»æµæ¨¡æ‹Ÿï¼šç­‰çº§ä¸è¶…è¿‡ç»æµæ–¹æ¡ˆä¸­è¯¥è‹±é›„çš„ç­‰çº§
            const eco = getMainConfigEconomySchemeData();
            if (useEconomySimulation && eco && Array.isArray(eco.playerHeroes)) {
                const eh = eco.playerHeroes.find(h => String(h.heroId) === String(char.selectedHeroId));
                
                // å¦‚æœè‹±é›„ä¸å­˜åœ¨äºç»æµæ–¹æ¡ˆä¸­ï¼Œè®¾ç½®ä¸ºé»˜è®¤è‹±é›„ï¼Œç­‰çº§1çº§
                if (!eh) {
                    // é»˜è®¤çš„5ä¸ªè§’è‰²IDï¼ˆè§’è‰²1-5å¯¹åº”ï¼‰
                    const defaultHeroIds = ['11001', '11002', '11003', '11101', '11102'];
                    const defaultHeroId = defaultHeroIds[charId - 1];
                    
                    // æ£€æŸ¥é»˜è®¤è‹±é›„æ˜¯å¦å­˜åœ¨äºç»æµæ–¹æ¡ˆä¸­
                    if (defaultHeroId) {
                        const defaultEh = eco.playerHeroes.find(h => String(h.heroId) === defaultHeroId);
                        if (defaultEh) {
                            // è®¾ç½®ä¸ºé»˜è®¤è‹±é›„ï¼Œç­‰çº§1çº§
                            char.selectedHeroId = defaultHeroId;
                            char.selectedHeroLevel = 1;
                            // é‡æ–°è·å–è‹±é›„æ•°æ®å¹¶æ›´æ–°å±æ€§
                            const defaultHero = heroTable.find(h => String(h.id) === defaultHeroId);
                            if (defaultHero) {
                                // æ›´æ–°ç­‰çº§åˆ—è¡¨
                                levels = defaultHero.levels ? Object.keys(defaultHero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
                                const defaultMaxLevel = defaultEh.level || 1;
                                if (defaultMaxLevel > 0) levels = levels.filter(l => l <= defaultMaxLevel);
                                // æ›´æ–°è§’è‰²å±æ€§
                                updateCharacterHeroLevel(charId, 1);
                            }
                        } else {
                            char.selectedHeroLevel = null;
                        }
                    } else {
                        char.selectedHeroLevel = null;
                    }
                } else {
                    // è‹±é›„å­˜åœ¨ï¼Œæ£€æŸ¥ç­‰çº§æ˜¯å¦è¶…è¿‡
                    const maxLevel = eh.level || 1;
                    if (maxLevel > 0) levels = levels.filter(l => l <= maxLevel);
                    if (char.selectedHeroLevel != null && char.selectedHeroLevel > maxLevel) {
                        // ç­‰çº§è¶…è¿‡ï¼Œè®¾ç½®ä¸º1çº§
                        char.selectedHeroLevel = 1;
                        updateCharacterHeroLevel(charId, 1);
                    }
                }
            }
            
            if (levels.length === 0) {
                levelSelect.innerHTML = '<option value="">è¯¥è‹±é›„æš‚æ— ç­‰çº§æ•°æ®</option>';
                return;
            }
            
            levels.forEach(level => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `ç­‰çº§ ${level}`;
                if (char.selectedHeroLevel === level) option.selected = true;
                levelSelect.appendChild(option);
            });
        }

        // æ›´æ–°è§’è‰²é€‰æ‹©çš„è‹±é›„ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateCharacterHero = function(charId, heroId) {
            const char = characters.find(c => c.id === charId);
            if (!char) return;
            
            char.selectedHeroId = heroId || null;
            
            // æ›´æ–°ç­‰çº§é€‰æ‹©ä¸‹æ‹‰æ¡†
            updateCharacterHeroLevelSelect(charId);
            
            // å¦‚æœæ¸…ç©ºäº†è‹±é›„é€‰æ‹©ï¼Œä¹Ÿæ¸…ç©ºç­‰çº§é€‰æ‹©
            if (!heroId) {
                char.selectedHeroLevel = null;
                const levelSelect = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
                if (levelSelect) {
                    levelSelect.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©è‹±é›„</option>';
                }
            }
            
            // æ›´æ–°è§’è‰²å¡ç‰‡èƒŒæ™¯é¢œè‰²
            const charCard = document.querySelector(`.character-card[data-char-id="${charId}"]`);
            if (charCard) {
                const heroQuality = getCharacterHeroQuality(charId);
                const qualityBg = getQualityBgColor(heroQuality);
                charCard.style.background = qualityBg.bg;
                charCard.style.borderColor = qualityBg.border;
            }
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿èƒŒæ™¯é¢œè‰²
            updateFinalAttributesPanel();
        }

        // æ›´æ–°è§’è‰²é€‰æ‹©çš„è‹±é›„ç­‰çº§å¹¶è‡ªåŠ¨æ›´æ–°å±æ€§ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateCharacterHeroLevel = function(charId, level) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.selectedHeroId) return;
            
            const levelNum = parseInt(level);
            if (!levelNum) {
                char.selectedHeroLevel = null;
                return;
            }
            
            char.selectedHeroLevel = levelNum;
            
            // è·å–è‹±é›„æ•°æ®
            const hero = heroTable.find(h => h.id === char.selectedHeroId);
            if (!hero) return;
            
            // åªè¯»å–å½“å‰ç­‰çº§çš„å±æ€§ï¼ˆä¸ç´¯åŠ ä¹‹å‰ç­‰çº§ï¼‰
            const levelAttrs = hero.levels && hero.levels[levelNum] ? hero.levels[levelNum] : {};
            
            // è‡ªåŠ¨æ›´æ–°è§’è‰²çš„åŸºç¡€å±æ€§ï¼ˆåªä½¿ç”¨å½“å‰ç­‰çº§çš„å±æ€§å€¼ï¼‰
            // å¦‚æœå½“å‰ç­‰çº§æœ‰å±æ€§æ•°æ®ï¼Œä½¿ç”¨è¯¥ç­‰çº§çš„å±æ€§ï¼›å¦åˆ™ä¿æŒåŸå€¼
            if (levelAttrs.baseAttack !== undefined && levelAttrs.baseAttack !== null) {
                char.baseAttack = levelAttrs.baseAttack;
            }
            if (levelAttrs.baseDefense !== undefined && levelAttrs.baseDefense !== null) {
                char.baseDefense = levelAttrs.baseDefense;
            }
            if (levelAttrs.baseHp !== undefined && levelAttrs.baseHp !== null) {
                char.baseHp = levelAttrs.baseHp;
                char.maxHp = levelAttrs.baseHp;
            } else if (char.baseHp) {
                char.maxHp = char.baseHp;
            }
            
            // åº”ç”¨è£…å¤‡å±æ€§
            applyJobEquipmentStats(char);
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            const card = document.querySelector(`[data-char-id="${charId}"]`);
            if (card) {
                const attackInput = card.querySelector('.char-attack');
                const defenseInput = card.querySelector('.char-defense');
                const hpInput = card.querySelector('.char-hp');
                if (attackInput) attackInput.value = char.baseAttack;
                if (defenseInput) defenseInput.value = char.baseDefense;
                if (hpInput) hpInput.value = char.baseHp;
            }
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºè§’è‰²å±æ€§å·²æ”¹å˜ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }
        
        // ä¸€é”®ä¸Šé˜µåŠŸèƒ½ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.autoDeployHeroes = function() {
            if (heroTable.length === 0) {
                showMessage('è¯·å…ˆä¸Šä¼ è‹±é›„è¡¨', 'error');
                return;
            }
            
            // è·å–å¯ç”¨çš„è‹±é›„åˆ—è¡¨ï¼ˆå¦‚æœå‹¾é€‰äº†ç»æµæ¨¡æ‹Ÿï¼Œåªè·å–ç»æµæ–¹æ¡ˆä¸­çš„è‹±é›„ï¼‰
            const eco = getMainConfigEconomySchemeData();
            let availableHeroes = heroTable;
            
            if (useEconomySimulation && eco && Array.isArray(eco.playerHeroes)) {
                const allowedIds = new Set(eco.playerHeroes.map(h => String(h.heroId)));
                availableHeroes = heroTable.filter(hero => allowedIds.has(String(hero.id)));
            }
            
            if (availableHeroes.length === 0) {
                showMessage('æ²¡æœ‰å¯ä¸Šé˜µçš„è‹±é›„', 'error');
                return;
            }
            
            // æŒ‰èŒä¸šåˆ†ç»„è‹±é›„
            const heroesByJob = {
                [JOB_TYPES.TANK]: [],
                [JOB_TYPES.WARRIOR]: [],
                [JOB_TYPES.ARCHER]: [],
                [JOB_TYPES.SUPPORT]: []
            };
            
            // ä¸ºæ¯ä¸ªè‹±é›„è®¡ç®—æœ€é«˜ç­‰çº§å’Œå±æ€§
            availableHeroes.forEach(hero => {
                const heroJob = parseInt(hero.heroclass) || 0;
                if (!heroJob || !heroesByJob[heroJob]) return;
                
                // è·å–è‹±é›„çš„æ‰€æœ‰ç­‰çº§
                let levels = hero.levels ? Object.keys(hero.levels).map(l => parseInt(l)).sort((a, b) => a - b) : [];
                if (levels.length === 0) return;
                
                // å¦‚æœå‹¾é€‰äº†ç»æµæ¨¡æ‹Ÿï¼Œé™åˆ¶æœ€é«˜ç­‰çº§
                let maxLevel = levels[levels.length - 1];
                if (useEconomySimulation && eco && Array.isArray(eco.playerHeroes)) {
                    const eh = eco.playerHeroes.find(h => String(h.heroId) === String(hero.id));
                    if (eh) {
                        const ecoMaxLevel = eh.level || 1;
                        maxLevel = Math.min(maxLevel, ecoMaxLevel);
                        // è¿‡æ»¤ç­‰çº§åˆ—è¡¨
                        levels = levels.filter(l => l <= ecoMaxLevel);
                    }
                }
                
                if (levels.length === 0) return;
                
                // è·å–æœ€é«˜ç­‰çº§çš„å±æ€§
                const maxLevelAttrs = hero.levels[maxLevel] || {};
                const attack = maxLevelAttrs.baseAttack || 0;
                const defense = maxLevelAttrs.baseDefense || 0;
                const hp = maxLevelAttrs.baseHp || 0;
                
                // è®¡ç®—å±æ€§æ€»å’Œï¼ˆç”¨äºæ’åºï¼‰
                const totalPower = attack + defense + hp;
                
                heroesByJob[heroJob].push({
                    hero: hero,
                    maxLevel: maxLevel,
                    attack: attack,
                    defense: defense,
                    hp: hp,
                    totalPower: totalPower
                });
            });
            
            // æŒ‰å±æ€§æ€»å’Œé™åºæ’åº
            Object.keys(heroesByJob).forEach(job => {
                heroesByJob[job].sort((a, b) => b.totalPower - a.totalPower);
            });
            
            // åˆ†é…è‹±é›„åˆ°è§’è‰²
            const assignments = {};
            
            // è§’è‰²1ï¼šå¦å…‹ - é€‰å±æ€§æœ€é«˜çš„å¦å…‹
            if (heroesByJob[JOB_TYPES.TANK].length > 0) {
                const bestTank = heroesByJob[JOB_TYPES.TANK][0];
                assignments[1] = {
                    heroId: bestTank.hero.id,
                    level: bestTank.maxLevel
                };
            }
            
            // è§’è‰²2ï¼šæˆ˜å£« - é€‰å±æ€§æœ€é«˜çš„æˆ˜å£«
            if (heroesByJob[JOB_TYPES.WARRIOR].length > 0) {
                const bestWarrior = heroesByJob[JOB_TYPES.WARRIOR][0];
                assignments[2] = {
                    heroId: bestWarrior.hero.id,
                    level: bestWarrior.maxLevel
                };
            }
            
            // è§’è‰²3å’Œ4ï¼šå°„æ‰‹ - é€‰å±æ€§æœ€é«˜çš„2ä¸ªå°„æ‰‹ï¼ˆä¸èƒ½ä½¿ç”¨ç›¸åŒè‹±é›„ï¼‰
            const archers = heroesByJob[JOB_TYPES.ARCHER];
            if (archers.length > 0) {
                // è§’è‰²3ï¼šç¬¬ä¸€ä¸ªå°„æ‰‹
                assignments[3] = {
                    heroId: archers[0].hero.id,
                    level: archers[0].maxLevel
                };
                // è§’è‰²4ï¼šç¬¬äºŒä¸ªå°„æ‰‹ï¼ˆå¿…é¡»ä¸åŒï¼‰
                if (archers.length > 1) {
                    assignments[4] = {
                        heroId: archers[1].hero.id,
                        level: archers[1].maxLevel
                    };
                }
                // å¦‚æœåªæœ‰ä¸€ä¸ªå°„æ‰‹ï¼Œè§’è‰²4ä¸åˆ†é…ï¼ˆä¿æŒä¸ºç©ºï¼‰
            }
            
            // è§’è‰²5ï¼šè¾…åŠ© - é€‰å±æ€§æœ€é«˜çš„è¾…åŠ©
            if (heroesByJob[JOB_TYPES.SUPPORT].length > 0) {
                const bestSupport = heroesByJob[JOB_TYPES.SUPPORT][0];
                assignments[5] = {
                    heroId: bestSupport.hero.id,
                    level: bestSupport.maxLevel
                };
            }
            
            // åº”ç”¨åˆ†é…ç»“æœï¼ˆæŒ‰é¡ºåºå¤„ç†ï¼Œç¡®ä¿æ¯ä¸ªè§’è‰²çš„è‹±é›„å’Œç­‰çº§éƒ½æ­£ç¡®è®¾ç½®ï¼‰
            // å¯¹äºè§’è‰²3å’Œ4ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªå°„æ‰‹ï¼Œè§’è‰²4éœ€è¦æ¸…ç©º
            const allCharIds = [1, 2, 3, 4, 5];
            let processedCount = 0;
            const totalToProcess = allCharIds.length;
            
            if (Object.keys(assignments).length === 0) {
                showMessage('ä¸€é”®ä¸Šé˜µå¤±è´¥ï¼šæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è‹±é›„', 'error');
                return;
            }
            
            allCharIds.forEach((charId, index) => {
                const assignment = assignments[charId];
                const char = characters.find(c => c.id === charId);
                
                if (!char) {
                    processedCount++;
                    if (processedCount === totalToProcess) {
                        const successCount = Object.keys(assignments).length;
                        showMessage(`ä¸€é”®ä¸Šé˜µå®Œæˆï¼å·²ä¸º ${successCount} ä¸ªè§’è‰²åˆ†é…è‹±é›„`, 'success');
                    }
                    return;
                }
                
                if (assignment) {
                    // æœ‰åˆ†é…ï¼šè®¾ç½®è‹±é›„å’Œç­‰çº§
                    char.selectedHeroId = assignment.heroId;
                    char.selectedHeroLevel = assignment.level;
                    
                    // å…ˆæ›´æ–°è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†
                    updateCharacterHeroSelect(charId);
                    
                    // æ‰‹åŠ¨è®¾ç½®è‹±é›„ä¸‹æ‹‰æ¡†çš„å€¼
                    const heroSelect = document.querySelector(`.char-hero-select[data-char="${charId}"]`);
                    if (heroSelect) {
                        heroSelect.value = assignment.heroId;
                    }
                    
                    // è®¾ç½®ç­‰çº§ï¼ˆä½¿ç”¨å»¶è¿Ÿç¡®ä¿ä¸‹æ‹‰æ¡†å·²æ›´æ–°ï¼‰
                    setTimeout(() => {
                        // æ›´æ–°ç­‰çº§é€‰æ‹©ä¸‹æ‹‰æ¡†
                        updateCharacterHeroLevelSelect(charId);
                        
                        // æ‰‹åŠ¨è®¾ç½®ç­‰çº§ä¸‹æ‹‰æ¡†çš„å€¼
                        const levelSelect = document.querySelector(`.char-hero-level-select[data-char="${charId}"]`);
                        if (levelSelect) {
                            levelSelect.value = assignment.level;
                        }
                        
                        // è®¾ç½®ç­‰çº§å¹¶æ›´æ–°å±æ€§
                        updateCharacterHeroLevel(charId, assignment.level);
                        
                        processedCount++;
                        if (processedCount === totalToProcess) {
                            const successCount = Object.keys(assignments).length;
                            showMessage(`ä¸€é”®ä¸Šé˜µå®Œæˆï¼å·²ä¸º ${successCount} ä¸ªè§’è‰²åˆ†é…è‹±é›„`, 'success');
                        }
                    }, 200 * (index + 1)); // é€’å¢å»¶è¿Ÿï¼Œç¡®ä¿æ¯ä¸ªè§’è‰²æŒ‰é¡ºåºå¤„ç†
                } else {
                    // æ²¡æœ‰åˆ†é…ï¼šæ¸…ç©ºè‹±é›„å’Œç­‰çº§ï¼ˆç‰¹åˆ«æ˜¯è§’è‰²4ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªå°„æ‰‹æ—¶ï¼‰
                    char.selectedHeroId = null;
                    char.selectedHeroLevel = null;
                    updateCharacterHero(charId, '');
                    
                    processedCount++;
                    if (processedCount === totalToProcess) {
                        const successCount = Object.keys(assignments).length;
                        showMessage(`ä¸€é”®ä¸Šé˜µå®Œæˆï¼å·²ä¸º ${successCount} ä¸ªè§’è‰²åˆ†é…è‹±é›„`, 'success');
                    }
                }
            });
        };

        // æ›´æ–°è§’è‰²å±æ€§
        function updateCharacter(id, property, value) {
            const char = characters.find(c => c.id === id);
            if (char) {
                if (property === 'healRate' || property === 'damageReduction' || property === 'skillDamage') {
                    char[property] = parseFloat(value) || 0;
                    // å¦‚æœæ›´æ–°çš„æ˜¯è§’è‰²5çš„å›è¡€ç³»æ•°ï¼Œéœ€è¦é‡æ–°è®¡ç®—æœ€ç»ˆå›è¡€é€Ÿåº¦
                    if (property === 'healRate' && char.id === 5) {
                        applyJobEquipmentStats(char);
                    }
                } else {
                    const numValue = parseInt(value) || 1;
                    if (property === 'attack') {
                        char.baseAttack = numValue;
                        applyEquipmentStats(char);
                        // å¦‚æœæ›´æ–°çš„æ˜¯è§’è‰²5çš„æ”»å‡»åŠ›ï¼Œæœ€ç»ˆå›è¡€é€Ÿåº¦ä¼šåœ¨applyJobEquipmentStatsä¸­è‡ªåŠ¨æ›´æ–°
                    } else if (property === 'defense') {
                        char.baseDefense = numValue;
                        applyEquipmentStats(char);
                    } else if (property === 'hp') {
                        char.baseHp = numValue;
                        char.maxHp = numValue;
                        applyEquipmentStats(char);
                    } else {
                        char[property] = numValue;
                    }
                }
                // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
                updateFinalAttributesPanel();
                
                // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºè§’è‰²å±æ€§å·²æ”¹å˜ï¼‰
                for (let stage = 1; stage <= 20; stage++) {
                    updateStageDamageInfo(stage);
                }
            }
        }

        // æ›´æ–°è§’è‰²è£…å¤‡ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.updateCharacterEquipment = function(charId, equipmentId) {
            const char = characters.find(c => c.id === charId);
            if (char) {
                char.equipmentId = equipmentId || null;
                applyEquipmentStats(char);
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                updateCharacterDisplay(char);
            }
        }

        // åº”ç”¨è£…å¤‡å±æ€§åŠ æˆï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼Œç°åœ¨ä½¿ç”¨applyJobEquipmentStatsï¼‰
        function applyEquipmentStats(char) {
            applyJobEquipmentStats(char);
        }

        // æ›´æ–°è§’è‰²æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºåŸºç¡€å±æ€§ï¼Œä¸æ˜¯æœ€ç»ˆå±æ€§ï¼‰
        function updateCharacterDisplay(char) {
            const card = document.querySelector(`[data-char-id="${char.id}"]`);
            if (card) {
                const attackInput = card.querySelector('.char-attack');
                const defenseInput = card.querySelector('.char-defense');
                const hpInput = card.querySelector('.char-hp');
                // æ˜¾ç¤ºåŸºç¡€å±æ€§ï¼Œä¸æ˜¯æœ€ç»ˆå±æ€§
                if (attackInput) attackInput.value = char.baseAttack || char.attack;
                if (defenseInput) defenseInput.value = char.baseDefense || char.defense;
                if (hpInput) hpInput.value = char.baseHp || char.hp;
            }
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
        }

        // æ›´æ–°æ€ªç‰©é…ç½®
        function updateMonsterConfig() {
            monsterConfig.spawnRate = parseFloat(document.getElementById('spawnRate').value) || 1;
            monsterConfig.attack = parseInt(document.getElementById('monsterAttack').value) || 10;
            monsterConfig.defense = parseInt(document.getElementById('monsterDefense').value) || 5;
            monsterConfig.hp = parseInt(document.getElementById('monsterHp').value) || 50;
            monsterConfig.atkSpeed = parseFloat(document.getElementById('monsterAtkSpeed').value) || 1;
            monsterConfig.damageCoeff = parseFloat(document.getElementById('monsterDamageCoeff').value) || 1;
            monsterConfig.hpCoeff = parseFloat(document.getElementById('monsterHpCoeff').value) || 0;
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯ï¼ˆå› ä¸ºæ€ªç‰©é…ç½®å·²æ”¹å˜ï¼‰
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
        }

        // é‡ç½®é…ç½®
        function resetConfig() {
            characters.forEach((char, i) => {
                // é‡ç½®åŸºç¡€å±æ€§
                char.baseAttack = 20;
                char.baseDefense = 10;
                char.baseHp = 100;
                char.healRate = i === 4 ? 0.2 : 0; // è§’è‰²5é»˜è®¤å›è¡€ç³»æ•°0.2ï¼ˆå¦‚æœæœ€ç»ˆæ”»å‡»åŠ›100ï¼Œåˆ™å›è¡€é€Ÿåº¦20/ç§’ï¼‰
                char.damageReduction = i === 0 ? 15 : 0; // è§’è‰²1å‡ä¼¤ç™¾åˆ†æ¯”ï¼Œé»˜è®¤15
                char.skillDamage = (i === 1 || i === 2 || i === 3) ? 0 : 0; // è§’è‰²2ã€3ã€4æŠ€èƒ½ä¼¤å®³ç³»æ•°
                char.isAlive = true;
                
                // åº”ç”¨è£…å¤‡å±æ€§åï¼Œæœ€ç»ˆå±æ€§ä¼šè¢«è®¡ç®—
                applyJobEquipmentStats(char);
            });
            
            document.getElementById('spawnRate').value = 1;
            document.getElementById('monsterAttack').value = 10;
            document.getElementById('monsterDefense').value = 5;
            document.getElementById('monsterHp').value = 50;
            document.getElementById('monsterAtkSpeed').value = 1;
            document.getElementById('monsterDamageCoeff').value = 1;
            document.getElementById('monsterHpCoeff').value = 0;

            initCharacters();
            hideMessage();
        }

        // åœæ­¢æˆ˜æ–—
        function stopBattle() {
            if (!battleState.isRunning) {
                return;
            }

            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'å¼€å§‹æˆ˜æ–—';
            document.getElementById('stopBtn').style.display = 'none';

            let deathInfo = '';
            if (battleState.firstCharacterDeathTime !== null) {
                deathInfo = `ï¼Œé¦–ä¸ªè§’è‰²æ­»äº¡æ—¶é—´: ${formatTime(battleState.firstCharacterDeathTime)}`;
                saveFirstDeathTimeToScheme(battleState.firstCharacterDeathTime);
            }

            addLog(`<span style="color: #ffc107; font-weight: bold;">æˆ˜æ–—å·²æ‰‹åŠ¨åœæ­¢ï¼</span>`);
            addLog(`æ­£å¸¸æ¨¡å¼ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${battleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${battleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(battleState.elapsedTime)}${deathInfo}`);
            addLog(`æ— æµªè´¹æ¨¡å¼ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${noWasteBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${noWasteBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(noWasteBattleState.elapsedTime)}`);
            
            // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡æ˜¾ç¤º
            updateBattleStatsAfterEnd();
        }

        // å¼€å§‹æˆ˜æ–—
        function startBattle() {
            if (battleState.isRunning) {
                return;
            }

            // æ›´æ–°æ€ªç‰©é…ç½®
            updateMonsterConfig();
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„å¹³å°å±æ€§é…ç½®å¹¶æ›´æ–°
            if (typeof ensurePlatformConfigFromSource === 'function') ensurePlatformConfigFromSource();
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è½¦è¾†å±æ€§é…ç½®å¹¶æ›´æ–°
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è§’è‰²åŸºç¡€å±æ€§ï¼ˆå¦‚æœç”¨æˆ·æ‰‹åŠ¨ä¿®æ”¹äº†ï¼‰
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§ï¼ˆç¡®ä¿åŒ…å«æœ€æ–°çš„è£…å¤‡ã€å¹³å°ã€è½¦è¾†åŠ æˆï¼‰
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // é‡ç½®æˆ˜æ–—çŠ¶æ€ï¼ˆæ­£å¸¸æ¨¡å¼ï¼‰
            battleState = {
                isRunning: true,
                startTime: Date.now(),
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: 0,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0 // ç¡®ä¿æˆ˜æ–—çŠ¶æ€ä¸­åŒ…å«æœ€ç»ˆå›è¡€é€Ÿåº¦
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null, // ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´
                char1NeverDies: false // æ ‡è®°è§’è‰²1æ˜¯å¦"å‡ ä¹ä¸ä¼šæ­»"ï¼ˆè¶…è¿‡200ç§’ä»å­˜æ´»ï¼‰
            };
            
            // é‡ç½®æ— æµªè´¹æ¨¡å¼æˆ˜æ–—çŠ¶æ€
            noWasteBattleState = {
                isRunning: true,
                startTime: Date.now(),
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: 0,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null,
                overflowDamage: 0 // æº¢å‡ºä¼¤å®³
            };

            // æ˜¾ç¤ºæˆ˜æ–—åŒºåŸŸ
            document.getElementById('battleArea').classList.add('show');
            document.getElementById('battleLog').innerHTML = '';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'æˆ˜æ–—ä¸­...';
            document.getElementById('stopBtn').style.display = 'block';

            // æ˜¾ç¤ºè§’è‰²HPæ¡
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                const hpBar = card.querySelector('.hp-bar');
                if (hpBar) hpBar.style.display = 'block';
            });

            // è®°å½•å¼€å§‹
            addLog(`æˆ˜æ–—å¼€å§‹ï¼æ€ªç‰©åˆ·æ–°é€Ÿåº¦: ${monsterConfig.spawnRate}ä¸ª/ç§’`);

            // å¼€å§‹æˆ˜æ–—å¾ªç¯
            battleLoop();
        }

        // å¿«é€Ÿæˆ˜æ–—ï¼ˆç›´æ¥æ˜¾ç¤ºç»“æœï¼Œä¸æ˜¾ç¤ºåŠ¨ç”»ï¼‰
        window.quickBattle = function() {
            if (battleState.isRunning) {
                return;
            }

            // æ›´æ–°æ€ªç‰©é…ç½®
            updateMonsterConfig();
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„å¹³å°å±æ€§é…ç½®å¹¶æ›´æ–°
            if (typeof ensurePlatformConfigFromSource === 'function') ensurePlatformConfigFromSource();
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è½¦è¾†å±æ€§é…ç½®å¹¶æ›´æ–°
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è§’è‰²åŸºç¡€å±æ€§
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // é‡ç½®æˆ˜æ–—çŠ¶æ€ï¼ˆæ­£å¸¸æ¨¡å¼ï¼‰
            battleState = {
                isRunning: true,
                startTime: 0,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: -1000, // åˆå§‹åŒ–ä¸ºè´Ÿæ•°ï¼Œç¡®ä¿ç¬¬ä¸€æ¬¡å¯ä»¥æ”»å‡»
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0,
                    deathTime: null // è®°å½•æ¯ä¸ªè§’è‰²çš„æ­»äº¡æ—¶é—´
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                char1NeverDies: false, // æ ‡è®°è§’è‰²1æ˜¯å¦"å‡ ä¹ä¸ä¼šæ­»"ï¼ˆè¶…è¿‡200ç§’ä»å­˜æ´»ï¼‰
                firstCharacterDeathTime: null // ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´
            };
            
            // é‡ç½®æ— æµªè´¹æ¨¡å¼æˆ˜æ–—çŠ¶æ€
            noWasteBattleState = {
                isRunning: true,
                startTime: 0,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    hp: char.maxHp,
                    isAlive: true,
                    lastAttackTime: -1000,
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0
                })),
                monsters: [],
                totalMonstersSpawned: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                firstCharacterDeathTime: null,
                overflowDamage: 0
            };

            // æ˜¾ç¤ºæˆ˜æ–—åŒºåŸŸ
            document.getElementById('battleArea').classList.add('show');
            document.getElementById('battleLog').innerHTML = '';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('quickResultBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'è®¡ç®—ä¸­...';

            // æ˜¾ç¤ºè§’è‰²HPæ¡
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                const hpBar = card.querySelector('.hp-bar');
                if (hpBar) hpBar.style.display = 'block';
            });

            // è®°å½•å¼€å§‹
            addLog(`å¿«é€Ÿæˆ˜æ–—å¼€å§‹ï¼æ€ªç‰©åˆ·æ–°é€Ÿåº¦: ${monsterConfig.spawnRate}ä¸ª/ç§’`);

            // è®¾ç½®å¿«é€Ÿæˆ˜æ–—æ¨¡å¼æ ‡å¿—ï¼ˆç”¨äºå‡å°‘æ—¥å¿—è¾“å‡ºï¼‰
            const isQuickBattle = true;
            
            // å¿«é€Ÿæˆ˜æ–—å¾ªç¯ï¼ˆä½¿ç”¨æ—¶é—´æ­¥è¿›ï¼Œä¸ç­‰å¾…åŠ¨ç”»ï¼‰
            const timeStep = 0.01; // æ¯æ¬¡æ­¥è¿›0.01ç§’
            const maxTime = 600; // æœ€å¤§æˆ˜æ–—æ—¶é—´600ç§’ï¼ˆ10åˆ†é’Ÿï¼‰
            let lastSummaryTime = 0; // ä¸Šæ¬¡è¾“å‡ºæ‘˜è¦çš„æ—¶é—´
            
            while (battleState.isRunning && battleState.elapsedTime < maxTime) {
                // æ›´æ–°ç»è¿‡æ—¶é—´
                battleState.elapsedTime += timeStep;
                noWasteBattleState.elapsedTime = battleState.elapsedTime;
                
                const currentTime = battleState.elapsedTime * 1000; // è½¬æ¢ä¸ºæ¯«ç§’

                // åˆ·æ–°æ€ªç‰©ï¼ˆä¸¤ç§æ¨¡å¼åŒæ—¶åˆ·æ–°ï¼Œå¿«é€Ÿæ¨¡å¼ä¸‹ä¸è¾“å‡ºæ—¥å¿—ï¼‰
                if (currentTime >= battleState.nextSpawnTime) {
                    // å¿«é€Ÿæ¨¡å¼ä¸‹ä¸è¾“å‡ºæ€ªç‰©å‡ºç°æ—¥å¿—
                    const oldLogLength = document.getElementById('battleLog').children.length;
                    spawnMonster();
                    spawnMonsterNoWaste();
                    // ç§»é™¤åˆšæ‰æ·»åŠ çš„æ—¥å¿—ï¼ˆå¦‚æœæœ‰ï¼‰
                    const log = document.getElementById('battleLog');
                    while (log.children.length > oldLogLength) {
                        log.removeChild(log.lastChild);
                    }
                    const spawnInterval = 1000 / monsterConfig.spawnRate;
                    battleState.nextSpawnTime = currentTime + spawnInterval;
                    noWasteBattleState.nextSpawnTime = battleState.nextSpawnTime;
                }

                // è§’è‰²æ”»å‡»ï¼ˆæ­£å¸¸æ¨¡å¼ï¼Œå¿«é€Ÿæ¨¡å¼ä¸‹ä¸è¾“å‡ºè¯¦ç»†æ—¥å¿—ï¼‰
                battleState.characters.forEach(char => {
                    if (char.isAlive && battleState.monsters.length > 0) {
                        const timeSinceLastAttack = battleState.elapsedTime - (char.lastAttackTime / 1000);
                        const attackInterval = 1 / char.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval) {
                            // å¿«é€Ÿæ¨¡å¼ä¸‹ï¼Œä¸è¾“å‡ºæ¯æ¬¡æ”»å‡»çš„è¯¦ç»†æ—¥å¿—
                            const oldLogLength = document.getElementById('battleLog').children.length;
                            characterAttack(char);
                            // ç§»é™¤è¯¦ç»†æ”»å‡»æ—¥å¿—ï¼Œåªä¿ç•™æ€ªç‰©æ­»äº¡ç­‰é‡è¦äº‹ä»¶
                            const log = document.getElementById('battleLog');
                            while (log.children.length > oldLogLength) {
                                const lastEntry = log.lastChild;
                                if (lastEntry && !lastEntry.innerHTML.includes('è¢«å‡»è´¥') && !lastEntry.innerHTML.includes('é˜µäº¡')) {
                                    log.removeChild(lastEntry);
                                } else {
                                    break;
                                }
                            }
                            char.lastAttackTime = currentTime;
                        }
                    }
                });
                
                // è§’è‰²æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼Œä¸è¾“å‡ºæ—¥å¿—ï¼‰
                noWasteBattleState.characters.forEach(char => {
                    if (char.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (char.lastAttackTime / 1000);
                        const attackInterval = 1 / char.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval) {
                            characterAttackNoWaste(char);
                            char.lastAttackTime = currentTime;
                        }
                    }
                });

                // è§’è‰²å›è¡€ï¼ˆæ­£å¸¸æ¨¡å¼ï¼Œå¿«é€Ÿæ¨¡å¼ä¸‹ä¸è¾“å‡ºæ—¥å¿—ï¼‰
                battleState.characters.forEach(char => {
                    if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                        const timeSinceLastHeal = battleState.elapsedTime - ((char.lastHealTime || 0) / 1000);
                        if (timeSinceLastHeal >= 1.0) {
                            const aliveChars = battleState.characters.filter(c => c.isAlive);
                            if (aliveChars.length > 0) {
                                const targetChar = aliveChars.reduce((min, c) => {
                                    const minRatio = min.hp / min.maxHp;
                                    const cRatio = c.hp / c.maxHp;
                                    return cRatio < minRatio ? c : min;
                                });

                                if (targetChar.hp < targetChar.maxHp) {
                                    const healAmount = char.finalHealRate;
                                    targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                }
                            }
                            char.lastHealTime = currentTime;
                        }
                    }
                });
                
                // è§’è‰²å›è¡€ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
                noWasteBattleState.characters.forEach(char => {
                    if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                        const timeSinceLastHeal = battleState.elapsedTime - ((char.lastHealTime || 0) / 1000);
                        if (timeSinceLastHeal >= 1.0) {
                            const aliveChars = noWasteBattleState.characters.filter(c => c.isAlive);
                            if (aliveChars.length > 0) {
                                const targetChar = aliveChars.reduce((min, c) => {
                                    const minRatio = min.hp / min.maxHp;
                                    const cRatio = c.hp / c.maxHp;
                                    return cRatio < minRatio ? c : min;
                                });

                                if (targetChar.hp < targetChar.maxHp) {
                                    const healAmount = char.finalHealRate;
                                    targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                }
                            }
                            char.lastHealTime = currentTime;
                        }
                    }
                });

                // æ€ªç‰©æ”»å‡»ï¼ˆæ­£å¸¸æ¨¡å¼ï¼Œå¿«é€Ÿæ¨¡å¼ä¸‹ä¸è¾“å‡ºè¯¦ç»†æ—¥å¿—ï¼‰
                battleState.monsters.forEach(monster => {
                    if (monster.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (monster.lastAttackTime / 1000);
                        const attackInterval = 1 / monster.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval && battleState.characters.some(c => c.isAlive)) {
                            // å¿«é€Ÿæ¨¡å¼ä¸‹ï¼Œä¸è¾“å‡ºæ¯æ¬¡æ”»å‡»çš„è¯¦ç»†æ—¥å¿—
                            const oldLogLength = document.getElementById('battleLog').children.length;
                            monsterAttack(monster);
                            // ç§»é™¤è¯¦ç»†æ”»å‡»æ—¥å¿—ï¼Œåªä¿ç•™è§’è‰²æ­»äº¡ç­‰é‡è¦äº‹ä»¶
                            const log = document.getElementById('battleLog');
                            while (log.children.length > oldLogLength) {
                                const lastEntry = log.lastChild;
                                if (lastEntry && !lastEntry.innerHTML.includes('é˜µäº¡') && !lastEntry.innerHTML.includes('è¢«å‡»è´¥')) {
                                    log.removeChild(lastEntry);
                                } else {
                                    break;
                                }
                            }
                            monster.lastAttackTime = currentTime;
                        }
                    }
                });

                // æ€ªç‰©æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
                noWasteBattleState.monsters.forEach(monster => {
                    if (monster.isAlive) {
                        const timeSinceLastAttack = battleState.elapsedTime - (monster.lastAttackTime / 1000);
                        const attackInterval = 1 / monster.atkSpeed;

                        if (timeSinceLastAttack >= attackInterval && noWasteBattleState.characters.some(c => c.isAlive)) {
                            monsterAttackNoWaste(monster);
                            monster.lastAttackTime = currentTime;
                        }
                    }
                });

                // æ¸…ç†æ­»äº¡æ€ªç‰©
                battleState.monsters = battleState.monsters.filter(monster => monster.isAlive);
                noWasteBattleState.monsters = noWasteBattleState.monsters.filter(monster => monster.isAlive);

                // æ¯5ç§’è¾“å‡ºä¸€æ¬¡è¿›åº¦æ‘˜è¦ï¼ˆå¯é€‰ï¼‰
                if (battleState.elapsedTime - lastSummaryTime >= 5.0) {
                    const aliveCount = battleState.characters.filter(c => c.isAlive).length;
                    const monsterCount = battleState.monsters.filter(m => m.isAlive).length;
                    addLog(`[${formatTime(battleState.elapsedTime)}] æˆ˜æ–—è¿›è¡Œä¸­ï¼šå­˜æ´»è§’è‰² ${aliveCount}/5ï¼Œå½“å‰æ€ªç‰© ${monsterCount}ï¼Œå·²å‡»è´¥ ${battleState.totalMonstersKilled} åª`);
                    lastSummaryTime = battleState.elapsedTime;
                }

                // æ£€æŸ¥200ç§’é™åˆ¶ï¼šå¦‚æœè¶…è¿‡200ç§’ä¸”è§’è‰²1ä»å­˜æ´»ï¼Œç»“æŸæˆ˜æ–—å¹¶æ ‡è®°ä¸º"å‡ ä¹ä¸ä¼šæ­»"
                const char1 = battleState.characters.find(c => c.id === 1);
                if (battleState.elapsedTime >= 200 && char1 && char1.isAlive) {
                    battleState.char1NeverDies = true;
                    // è®¾ç½®è§’è‰²1çš„æ­»äº¡æ—¶é—´ä¸ºç‰¹æ®Šæ ‡è®°ï¼ˆç”¨äºå…³å¡åˆ¤æ–­ï¼‰
                    char1.deathTime = 'never';
                    battleState.isRunning = false;
                    noWasteBattleState.isRunning = false;
                    addLog(`<span style="color: #51cf66; font-weight: bold;">æˆ˜æ–—æ—¶é—´è¶…è¿‡200ç§’ï¼Œè§’è‰²1ä»å­˜æ´»ï¼Œåˆ¤å®šä¸º"å‡ ä¹ä¸ä¼šæ­»"</span>`);
                    break;
                }

                // æ£€æŸ¥æˆ˜æ–—ç»“æŸ
                const allCharactersDead = !battleState.characters.some(c => c.isAlive);
                if (allCharactersDead) {
                    battleState.isRunning = false;
                    noWasteBattleState.isRunning = false;
                    break;
                }
            }

            // æˆ˜æ–—ç»“æŸ
            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            
            // æ›´æ–°æ˜¾ç¤º
            updateBattleDisplay();
            
            // ç»“æŸæˆ˜æ–—
            const win = battleState.characters.some(c => c.isAlive);
            endBattle(win);
            
            // æ£€æŸ¥å…³å¡æŒ‘æˆ˜ç»“æœ
            checkStageResult();
            
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            document.getElementById('startBtn').disabled = false;
            document.getElementById('quickResultBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'é‡æ–°å¼€å§‹æˆ˜æ–—';
        };

        // æˆ˜æ–—å¾ªç¯
        function battleLoop() {
            if (!battleState.isRunning) {
                return;
            }

            const now = Date.now();
            battleState.elapsedTime = (now - battleState.startTime) / 1000;
            noWasteBattleState.elapsedTime = battleState.elapsedTime;

            // åˆ·æ–°æ€ªç‰©ï¼ˆä¸¤ç§æ¨¡å¼åŒæ—¶åˆ·æ–°ï¼‰
            if (now >= battleState.nextSpawnTime) {
                spawnMonster();
                spawnMonsterNoWaste();
                const spawnInterval = 1000 / monsterConfig.spawnRate;
                battleState.nextSpawnTime = now + spawnInterval;
                noWasteBattleState.nextSpawnTime = battleState.nextSpawnTime;
            }

            // è§’è‰²æ”»å‡»ï¼ˆæ­£å¸¸æ¨¡å¼ï¼‰
            battleState.characters.forEach(char => {
                if (char.isAlive && battleState.monsters.length > 0) {
                    const timeSinceLastAttack = (now - char.lastAttackTime) / 1000;
                    const attackInterval = 1 / char.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval) {
                        characterAttack(char);
                        char.lastAttackTime = now;
                    }
                }
            });
            
            // è§’è‰²æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
            noWasteBattleState.characters.forEach((char, index) => {
                if (char.isAlive) {
                    const timeSinceLastAttack = (now - char.lastAttackTime) / 1000;
                    const attackInterval = 1 / char.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval) {
                        characterAttackNoWaste(char);
                        char.lastAttackTime = now;
                    }
                }
            });

            // è§’è‰²å›è¡€ï¼ˆè§’è‰²5ä¸ºè¡€é‡æ¯”ä¾‹æœ€å°‘çš„è§’è‰²æ¢å¤ï¼Œæ­£å¸¸æ¨¡å¼ï¼‰
            battleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || battleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) { // æ¯ç§’å›è¡€ä¸€æ¬¡
                        // æ‰¾åˆ°è¡€é‡æ¯”ä¾‹æœ€å°‘çš„å­˜æ´»è§’è‰²
                        const aliveChars = battleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            // å¦‚æœç›®æ ‡è¡€é‡ä¸æ˜¯æ»¡çš„ï¼Œè¿›è¡Œæ²»ç–—
                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate; // ä½¿ç”¨æœ€ç»ˆå›è¡€é€Ÿåº¦
                                const oldHp = targetChar.hp;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                const actualHeal = targetChar.hp - oldHp;
                                
                                if (actualHeal > 0) {
                                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-heal">${char.name}</span> ä¸º ${targetChar.name} æ¢å¤ ${actualHeal.toFixed(1)} ç‚¹ç”Ÿå‘½å€¼`);
                                    showDamageNumber(`panel-char-${targetChar.id}`, `+${actualHeal.toFixed(1)}`, true);
                                }
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });
            
            // è§’è‰²å›è¡€ï¼ˆè§’è‰²5ä¸ºè¡€é‡æ¯”ä¾‹æœ€å°‘çš„è§’è‰²æ¢å¤ï¼Œæ— æµªè´¹æ¨¡å¼ï¼‰
            noWasteBattleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || noWasteBattleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) { // æ¯ç§’å›è¡€ä¸€æ¬¡
                        // æ‰¾åˆ°è¡€é‡æ¯”ä¾‹æœ€å°‘çš„å­˜æ´»è§’è‰²
                        const aliveChars = noWasteBattleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            // å¦‚æœç›®æ ‡è¡€é‡ä¸æ˜¯æ»¡çš„ï¼Œè¿›è¡Œæ²»ç–—
                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate; // ä½¿ç”¨æœ€ç»ˆå›è¡€é€Ÿåº¦
                                const oldHp = targetChar.hp;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });

            // æ€ªç‰©æ”»å‡»ï¼ˆæ­£å¸¸æ¨¡å¼ï¼‰
            battleState.monsters.forEach(monster => {
                if (monster.isAlive) {
                    const timeSinceLastAttack = (now - monster.lastAttackTime) / 1000;
                    const attackInterval = 1 / monster.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval && battleState.characters.some(c => c.isAlive)) {
                        monsterAttack(monster);
                        monster.lastAttackTime = now;
                    }
                }
            });

            // æ€ªç‰©æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
            noWasteBattleState.monsters.forEach(monster => {
                if (monster.isAlive) {
                    const timeSinceLastAttack = (now - monster.lastAttackTime) / 1000;
                    const attackInterval = 1 / monster.atkSpeed;

                    if (timeSinceLastAttack >= attackInterval && noWasteBattleState.characters.some(c => c.isAlive)) {
                        monsterAttackNoWaste(monster);
                        monster.lastAttackTime = now;
                    }
                }
            });

            // æ¸…ç†æ­»äº¡æ€ªç‰©
            battleState.monsters = battleState.monsters.filter(monster => monster.isAlive);
            noWasteBattleState.monsters = noWasteBattleState.monsters.filter(monster => monster.isAlive);

            // æ›´æ–°æ˜¾ç¤º
            updateBattleDisplay();

            // æ£€æŸ¥200ç§’é™åˆ¶ï¼šå¦‚æœè¶…è¿‡200ç§’ä¸”è§’è‰²1ä»å­˜æ´»ï¼Œç»“æŸæˆ˜æ–—å¹¶æ ‡è®°ä¸º"å‡ ä¹ä¸ä¼šæ­»"
            const char1 = battleState.characters.find(c => c.id === 1);
            if (battleState.elapsedTime >= 200 && char1 && char1.isAlive) {
                battleState.char1NeverDies = true;
                // è®¾ç½®è§’è‰²1çš„æ­»äº¡æ—¶é—´ä¸ºç‰¹æ®Šæ ‡è®°ï¼ˆç”¨äºå…³å¡åˆ¤æ–­ï¼‰
                char1.deathTime = 'never';
                addLog(`<span style="color: #51cf66; font-weight: bold;">æˆ˜æ–—æ—¶é—´è¶…è¿‡200ç§’ï¼Œè§’è‰²1ä»å­˜æ´»ï¼Œåˆ¤å®šä¸º"å‡ ä¹ä¸ä¼šæ­»"</span>`);
                endBattle(true); // è§’è‰²1å­˜æ´»ï¼Œåˆ¤å®šä¸ºèƒœåˆ©
                return;
            }

            // æ£€æŸ¥æˆ˜æ–—ç»“æŸ
            const allCharactersDead = !battleState.characters.some(c => c.isAlive);
            if (allCharactersDead) {
                endBattle(false);
                return;
            }

            // ç»§ç»­å¾ªç¯
            requestAnimationFrame(battleLoop);
        }

        // åˆ·æ–°æ€ªç‰©ï¼ˆæ­£å¸¸æ¨¡å¼ï¼‰
        function spawnMonster() {
            battleState.monsterIdCounter++;
            // åº”ç”¨è¡€é‡ç³»æ•°ï¼šè¿›å…¥æˆ˜æ–—æ—¶çš„è¡€é‡ = åŸºç¡€è¡€é‡ Ã— (1 + è¡€é‡ç³»æ•°)
            const actualHp = Math.floor(monsterConfig.hp * (1 + (monsterConfig.hpCoeff || 0)));
            const monster = {
                id: battleState.monsterIdCounter,
                attack: monsterConfig.attack,
                defense: monsterConfig.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: monsterConfig.atkSpeed,
                isAlive: true,
                lastAttackTime: 0
            };
            battleState.monsters.push(monster);
            battleState.totalMonstersSpawned++;
            addLog(`[${formatTime(battleState.elapsedTime)}] æ€ªç‰© #${monster.id} å‡ºç°ï¼`);
        }

        // åˆ·æ–°æ€ªç‰©ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
        function spawnMonsterNoWaste() {
            noWasteBattleState.monsterIdCounter++;
            // åº”ç”¨è¡€é‡ç³»æ•°ï¼šè¿›å…¥æˆ˜æ–—æ—¶çš„è¡€é‡ = åŸºç¡€è¡€é‡ Ã— (1 + è¡€é‡ç³»æ•°)
            const actualHp = Math.floor(monsterConfig.hp * (1 + (monsterConfig.hpCoeff || 0)));
            const monster = {
                id: noWasteBattleState.monsterIdCounter,
                attack: monsterConfig.attack,
                defense: monsterConfig.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: monsterConfig.atkSpeed,
                isAlive: true,
                lastAttackTime: 0
            };
            noWasteBattleState.monsters.push(monster);
            noWasteBattleState.totalMonstersSpawned++;
        }

        // è§’è‰²æ”»å‡»
        function characterAttack(character) {
            if (battleState.monsters.length === 0) return;

            // æ”»å‡»ç¬¬ä¸€ä¸ªå­˜æ´»çš„æ€ªç‰©
            const target = battleState.monsters.find(m => m.isAlive);
            if (!target) return;

            // åŸºç¡€ä¼¤å®³è®¡ç®—
            let baseDamage = Math.max(1, character.attack - target.defense);
            
            // è§’è‰²2ã€3ã€4çš„æŠ€èƒ½ä¼¤å®³åŠ æˆ
            let finalDamage = baseDamage;
            const skillPct = parseFloat(character.skillDamage) || 0;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && skillPct !== 0) {
                const skillBonus = baseDamage * (skillPct / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            target.hp -= finalDamage;
            battleState.totalDamageDealt += finalDamage;

            let damageText = finalDamage === baseDamage 
                ? `${finalDamage}`
                : `${finalDamage}ï¼ˆåŸºç¡€${baseDamage} + æŠ€èƒ½${(finalDamage - baseDamage).toFixed(1)}ï¼‰`;
            
            addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-damage">${character.name}</span> æ”»å‡» æ€ªç‰© #${target.id}ï¼Œé€ æˆ ${damageText} ç‚¹ä¼¤å®³`);

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                battleState.totalMonstersKilled++;
                addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">æ€ªç‰© #${target.id} è¢«å‡»è´¥ï¼</span>`);
            }
        }

        // è§’è‰²æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼Œå‰©ä½™ä¼¤å®³ä¼ é€’åˆ°ä¸‹ä¸€åªæ€ªç‰©ï¼‰
        function characterAttackNoWaste(character) {
            // åŸºç¡€ä¼¤å®³è®¡ç®—ï¼ˆä½¿ç”¨æ€ªç‰©é…ç½®çš„é˜²å¾¡åŠ›ï¼‰
            let baseDamage = Math.max(1, character.attack - monsterConfig.defense);
            
            // è§’è‰²2ã€3ã€4çš„æŠ€èƒ½ä¼¤å®³åŠ æˆ
            let finalDamage = baseDamage;
            const skillPct = parseFloat(character.skillDamage) || 0;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && skillPct !== 0) {
                const skillBonus = baseDamage * (skillPct / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            // åŠ ä¸Šæº¢å‡ºä¼¤å®³
            finalDamage += noWasteBattleState.overflowDamage;
            noWasteBattleState.overflowDamage = 0;
            
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå­˜æ´»çš„æ€ªç‰©
            let target = noWasteBattleState.monsters.find(m => m.isAlive);
            
            // å¦‚æœæ²¡æœ‰å­˜æ´»çš„æ€ªç‰©ï¼Œå°†ä¼¤å®³ä¿å­˜ä¸ºæº¢å‡ºä¼¤å®³ï¼Œç­‰å¾…ä¸‹ä¸€ä¸ªæ€ªç‰©å‡ºç°
            if (!target) {
                noWasteBattleState.overflowDamage = finalDamage;
                return;
            }
            
            const targetHpBefore = target.hp;
            target.hp -= finalDamage;
            noWasteBattleState.totalDamageDealt += finalDamage;

            // å¦‚æœæ€ªç‰©è¢«å‡»è´¥ï¼Œè®¡ç®—æº¢å‡ºä¼¤å®³
            if (target.hp <= 0) {
                const overflow = Math.abs(target.hp); // æº¢å‡ºçš„ä¼¤å®³
                noWasteBattleState.overflowDamage = overflow;
                target.hp = 0;
                target.isAlive = false;
                noWasteBattleState.totalMonstersKilled++;
            }
        }

        // æ€ªç‰©æ”»å‡»ï¼ˆä¼˜å…ˆæ”»å‡»è§’è‰²1ï¼ŒæŒ‰1~5é¡ºåºï¼‰
        function monsterAttack(monster) {
            // æŒ‰é¡ºåºæ‰¾å­˜æ´»çš„è§’è‰²ï¼ˆè§’è‰²1åˆ°è§’è‰²5ï¼‰
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = battleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // åŸºç¡€ä¼¤å®³è®¡ç®—
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // è§’è‰²1çš„å‡ä¼¤ç™¾åˆ†æ¯”
            let damageAfterReduction = baseDamage;
            if (target.id === 1 && target.damageReduction > 0) {
                const reduction = baseDamage * (target.damageReduction / 100);
                damageAfterReduction = baseDamage - reduction;
                damageAfterReduction = Math.max(1, Math.floor(damageAfterReduction));
            }
            
            // åº”ç”¨æ€ªç‰©æ”»å‡»ç³»æ•°
            let finalDamage = damageAfterReduction * (monsterConfig.damageCoeff || 1);
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            battleState.totalDamageTaken += finalDamage;

            let damageText = '';
            if (finalDamage === baseDamage && monsterConfig.damageCoeff === 1) {
                damageText = `${finalDamage}`;
            } else {
                const parts = [];
                if (baseDamage !== damageAfterReduction) {
                    parts.push(`åŸºç¡€${baseDamage} - å‡ä¼¤${(baseDamage - damageAfterReduction).toFixed(1)}`);
                } else {
                    parts.push(`åŸºç¡€${baseDamage}`);
                }
                if (monsterConfig.damageCoeff !== 1) {
                    parts.push(`Ã— ç³»æ•°${monsterConfig.damageCoeff.toFixed(2)}`);
                }
                damageText = `${finalDamage}ï¼ˆ${parts.join('ï¼Œ')}ï¼‰`;
            }
            
            addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-damage">æ€ªç‰© #${monster.id}</span> æ”»å‡» ${target.name}ï¼Œé€ æˆ ${damageText} ç‚¹ä¼¤å®³`);
            showDamageNumber(`panel-char-${target.id}`, `-${finalDamage}`, false);

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = battleState.elapsedTime; // è®°å½•è¯¥è§’è‰²çš„æ­»äº¡æ—¶é—´
                updateCharacterStatus(target.id, false);
                
                // è®°å½•ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´
                if (battleState.firstCharacterDeathTime === null) {
                    battleState.firstCharacterDeathTime = battleState.elapsedTime;
                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">${target.name} é˜µäº¡ï¼[é¦–ä¸ªé˜µäº¡è§’è‰²]</span>`);
                } else {
                    addLog(`[${formatTime(battleState.elapsedTime)}] <span class="log-death">${target.name} é˜µäº¡ï¼</span>`);
                }
            }
        }

        // æ€ªç‰©æ”»å‡»ï¼ˆæ— æµªè´¹æ¨¡å¼ï¼‰
        function monsterAttackNoWaste(monster) {
            // æŒ‰é¡ºåºæ‰¾å­˜æ´»çš„è§’è‰²ï¼ˆè§’è‰²1åˆ°è§’è‰²5ï¼‰
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = noWasteBattleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // åŸºç¡€ä¼¤å®³è®¡ç®—
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // è§’è‰²1çš„å‡ä¼¤ç™¾åˆ†æ¯”
            let damageAfterReduction = baseDamage;
            if (target.id === 1 && target.damageReduction > 0) {
                const reduction = baseDamage * (target.damageReduction / 100);
                damageAfterReduction = baseDamage - reduction;
                damageAfterReduction = Math.max(1, Math.floor(damageAfterReduction));
            }
            
            // åº”ç”¨æ€ªç‰©æ”»å‡»ç³»æ•°
            let finalDamage = damageAfterReduction * (monsterConfig.damageCoeff || 1);
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            noWasteBattleState.totalDamageTaken += finalDamage;

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = noWasteBattleState.elapsedTime; // è®°å½•è¯¥è§’è‰²çš„æ­»äº¡æ—¶é—´
                
                // è®°å½•ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´
                if (noWasteBattleState.firstCharacterDeathTime === null) {
                    noWasteBattleState.firstCharacterDeathTime = noWasteBattleState.elapsedTime;
                }
            }
        }

        // æ›´æ–°æˆ˜æ–—æ˜¾ç¤º
        function updateBattleDisplay() {
            // æ›´æ–°è§’è‰²HPæ¡ï¼ˆé…ç½®åŒºåŸŸï¼‰
            battleState.characters.forEach(char => {
                const hpPercent = (char.hp / char.maxHp) * 100;
                const hpBar = document.getElementById(`hp-bar-${char.id}`);
                if (hpBar) {
                    hpBar.style.width = `${hpPercent}%`;
                }
            });

            // æ›´æ–°è§’è‰²é¢æ¿
            updateCharactersPanel();

            // æ›´æ–°ç»Ÿè®¡ï¼ˆåŒæ—¶æ˜¾ç¤ºæ­£å¸¸æ¨¡å¼å’Œæ— æµªè´¹æ¨¡å¼ï¼‰
            const stats = `
                <div class="stat-card" style="grid-column: 1 / -1; background: #f0f0f0; padding: 10px; margin-bottom: 10px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">æ­£å¸¸æ¨¡å¼ï¼ˆä¼¤å®³ä¸æº¢å‡ºï¼‰</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æˆ˜æ–—æ—¶é•¿</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${formatTime(battleState.elapsedTime)}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å­˜æ´»è§’è‰²</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.characters.filter(c => c.isAlive).length}/5</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å½“å‰æ€ªç‰©æ•°</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.monsters.filter(m => m.isAlive).length}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å·²å‡»è´¥æ€ªç‰©</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${battleState.totalMonstersKilled}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æ€»ä¼¤å®³è¾“å‡º</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #f44336;">${battleState.totalDamageDealt}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æ‰¿å—ä¼¤å®³</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #ff9800;">${battleState.totalDamageTaken}</div>
                        </div>
                    </div>
                </div>
                <div class="stat-card" style="grid-column: 1 / -1; background: #e8f5e9; padding: 10px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">æ— æµªè´¹æ¨¡å¼ï¼ˆå‰©ä½™ä¼¤å®³ä¼ é€’ï¼‰</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æˆ˜æ–—æ—¶é•¿</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${formatTime(noWasteBattleState.elapsedTime)}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å­˜æ´»è§’è‰²</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.characters.filter(c => c.isAlive).length}/5</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å½“å‰æ€ªç‰©æ•°</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.monsters.filter(m => m.isAlive).length}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">å·²å‡»è´¥æ€ªç‰©</div>
                            <div style="font-size: 1.1em; font-weight: 600;">${noWasteBattleState.totalMonstersKilled}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æ€»ä¼¤å®³è¾“å‡º</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #f44336;">${noWasteBattleState.totalDamageDealt}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85em; color: #666;">æ‰¿å—ä¼¤å®³</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #ff9800;">${noWasteBattleState.totalDamageTaken}</div>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('battleStats').innerHTML = stats;
        }

        // æ›´æ–°è§’è‰²é¢æ¿
        function updateCharactersPanel() {
            const panel = document.getElementById('charactersPanel');
            panel.innerHTML = battleState.characters.map(char => {
                const hpPercent = (char.hp / char.maxHp) * 100;
                const statusClass = char.isAlive ? 'alive' : 'dead';
                const jobName = JOB_NAMES[char.job] || 'æœªçŸ¥';
                return `
                    <div class="char-panel-item ${statusClass}" id="panel-char-${char.id}">
                        <div class="char-panel-name">${char.name} <span style="font-size: 0.85em; color: #667eea;">[${jobName}]</span></div>
                        <div class="char-panel-hp">${char.hp.toFixed(0)} / ${char.maxHp} (${hpPercent.toFixed(0)}%)</div>
                        <div class="char-panel-hp-bar">
                            <div class="char-panel-hp-fill" style="width: ${hpPercent}%;"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // æ˜¾ç¤ºä¼¤å®³æ•°å­—åŠ¨ç”»
        // æ˜¾ç¤ºä¼¤å®³æ•°å­—åŠ¨ç”»ï¼ˆå…¼å®¹ä¸¤ç§è°ƒç”¨æ–¹å¼ï¼šelementIdå­—ç¬¦ä¸² æˆ– elementå¯¹è±¡ï¼‰
        function showDamageNumber(elementOrId, damageOrText, isHeal = false) {
            let element = null;
            let damageText = '';
            
            // åˆ¤æ–­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦ä¸²IDè¿˜æ˜¯DOMå…ƒç´ 
            if (typeof elementOrId === 'string') {
                // æ—§ç‰ˆæœ¬è°ƒç”¨ï¼šshowDamageNumber(elementId, text, isHeal)
                element = document.getElementById(elementOrId);
                damageText = damageOrText; // ç¬¬äºŒä¸ªå‚æ•°ç›´æ¥æ˜¯æ–‡æœ¬
            } else if (elementOrId && typeof elementOrId.getBoundingClientRect === 'function') {
                // æ–°ç‰ˆæœ¬è°ƒç”¨ï¼šshowDamageNumber(element, damage, isHeal)
                element = elementOrId;
                const damage = typeof damageOrText === 'number' ? damageOrText : parseFloat(damageOrText) || 0;
                damageText = isHeal ? `+${damage.toFixed(0)}` : `-${damage.toFixed(0)}`;
            } else {
                return; // æ— æ•ˆå‚æ•°
            }
            
            if (!element) return;

            // æ£€æŸ¥æ˜¯å¦æœ‰æ³¢æ¬¡æˆ˜æ–—åœºæ™¯ï¼ˆä¼˜å…ˆï¼‰
            let battleScene = null;
            let isInWaveBattle = false;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æ³¢æ¬¡æˆ˜æ–—ä¸­è¿›è¡Œ
            if (typeof waveBattleState !== 'undefined' && waveBattleState && waveBattleState.isRunning) {
                battleScene = document.getElementById('waveBattleScene');
                if (battleScene) {
                    // æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨æ³¢æ¬¡æˆ˜æ–—åŒºåŸŸå†…
                    const waveBattleArea = document.getElementById('waveBattleArea');
                    if (waveBattleArea && (waveBattleArea.contains(element) || element.closest('#waveBattleArea'))) {
                        isInWaveBattle = true;
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ³¢æ¬¡æˆ˜æ–—åœºæ™¯ï¼Œæ£€æŸ¥æ™®é€šæˆ˜æ–—åœºæ™¯
            if (!battleScene || !isInWaveBattle) {
                const normalBattleScene = document.getElementById('battleScene');
                if (normalBattleScene && normalBattleScene.contains(element)) {
                    battleScene = normalBattleScene;
                    isInWaveBattle = false;
                }
            }
            
            if (battleScene && (isInWaveBattle || battleScene.contains(element))) {
                // æˆ˜æ–—åœºæ™¯æ¨¡å¼ï¼šåœ¨æˆ˜æ–—åœºæ™¯ä¸­æ˜¾ç¤º
                const rect = element.getBoundingClientRect();
                const sceneRect = battleScene.getBoundingClientRect();
                const x = rect.left - sceneRect.left + rect.width / 2;
                const y = rect.top - sceneRect.top;
                
                const damageEl = document.createElement('div');
                damageEl.className = isHeal ? 'heal-number' : 'damage-number';
                damageEl.textContent = damageText;
                damageEl.style.left = x + 'px';
                damageEl.style.top = y + 'px';
                damageEl.style.position = 'absolute';
                damageEl.style.zIndex = '1000';
                damageEl.style.pointerEvents = 'none';
                
                battleScene.appendChild(damageEl);
                
                setTimeout(() => {
                    if (damageEl.parentNode) {
                        damageEl.parentNode.removeChild(damageEl);
                    }
                }, 1000);
            } else {
                // æ™®é€šæ¨¡å¼ï¼šåœ¨å…ƒç´ å†…éƒ¨æ˜¾ç¤º
                const damageEl = document.createElement('div');
                damageEl.className = isHeal ? 'heal-number' : 'damage-number';
                damageEl.textContent = damageText;
                element.appendChild(damageEl);

                setTimeout(() => {
                    if (damageEl.parentNode) {
                        damageEl.parentNode.removeChild(damageEl);
                    }
                }, 1000);
            }
        }

        // æ›´æ–°è§’è‰²çŠ¶æ€æ˜¾ç¤º
        function updateCharacterStatus(charId, isAlive) {
            const statusEl = document.getElementById(`status-${charId}`);
            if (statusEl) {
                statusEl.textContent = isAlive ? 'å­˜æ´»' : 'é˜µäº¡';
                statusEl.className = `character-status ${isAlive ? 'status-alive' : 'status-dead'}`;
            }
        }

        // ç»“æŸæˆ˜æ–—
        function endBattle(win) {
            battleState.isRunning = false;
            noWasteBattleState.isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'é‡æ–°å¼€å§‹æˆ˜æ–—';
            document.getElementById('stopBtn').style.display = 'none';

            if (win) {
                addLog(`<span style="color: #51cf66; font-weight: bold;">æˆ˜æ–—èƒœåˆ©ï¼</span>`);
            } else {
                addLog(`<span style="color: #ff6b6b; font-weight: bold;">æˆ˜æ–—å¤±è´¥ï¼æ‰€æœ‰è§’è‰²é˜µäº¡ã€‚</span>`);
            }

            // æ˜¾ç¤ºç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´
            let deathInfo = '';
            if (battleState.char1NeverDies) {
                // å¦‚æœè§’è‰²1"å‡ ä¹ä¸ä¼šæ­»"ï¼Œæ˜¾ç¤ºç‰¹æ®Šä¿¡æ¯
                deathInfo = `ï¼Œè§’è‰²1æ­»äº¡æ—¶é—´: å‡ ä¹ä¸ä¼šæ­»ï¼ˆè¶…è¿‡200ç§’ä»å­˜æ´»ï¼‰`;
            } else if (battleState.firstCharacterDeathTime !== null) {
                deathInfo = `ï¼Œé¦–ä¸ªè§’è‰²æ­»äº¡æ—¶é—´: ${formatTime(battleState.firstCharacterDeathTime)}`;
                
                // ä¿å­˜ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´åˆ°å½“å‰æ–¹æ¡ˆ
                saveFirstDeathTimeToScheme(battleState.firstCharacterDeathTime);
            }

            addLog(`æˆ˜æ–—ç»“æŸã€‚æ­£å¸¸æ¨¡å¼ï¼šå‡»è´¥æ€ªç‰© ${battleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${battleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(battleState.elapsedTime)}${deathInfo}`);
            addLog(`æ— æµªè´¹æ¨¡å¼ï¼šå‡»è´¥æ€ªç‰© ${noWasteBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${noWasteBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(noWasteBattleState.elapsedTime)}`);

            // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡æ˜¾ç¤º
            updateBattleStatsAfterEnd();
            
            // æ£€æŸ¥å…³å¡æŒ‘æˆ˜ç»“æœ
            checkStageResult();
        }

        // ä¿å­˜ç¬¬ä¸€ä¸ªè§’è‰²æ­»äº¡æ—¶é—´åˆ°å½“å‰æ–¹æ¡ˆ
        function saveFirstDeathTimeToScheme(deathTime) {
            if (!currentSchemeId) {
                return; // å¦‚æœæ²¡æœ‰å½“å‰æ–¹æ¡ˆï¼Œä¸ä¿å­˜
            }

            try {
                const schemes = loadSchemes();
                const schemeIndex = schemes.findIndex(s => s.id === currentSchemeId);
                
                if (schemeIndex >= 0) {
                    schemes[schemeIndex].lastDeathTime = {
                        time: deathTime,
                        timestamp: new Date().toISOString(),
                        date: new Date().toLocaleString('zh-CN')
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));
                }
            } catch (error) {
                console.error('ä¿å­˜æ­»äº¡æ—¶é—´åˆ°æ–¹æ¡ˆå¤±è´¥:', error);
            }
        }

        // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡ï¼ˆæˆ˜æ–—ç»“æŸåï¼‰
        function updateBattleStatsAfterEnd() {
            const stats = document.getElementById('battleStats');
            if (!stats) return;

            let deathTimeDisplay = '';
            if (battleState.firstCharacterDeathTime !== null) {
                deathTimeDisplay = `
                    <div class="stat-card" style="border: 2px solid #ff6b6b;">
                        <div class="stat-label">é¦–ä¸ªè§’è‰²æ­»äº¡æ—¶é—´</div>
                        <div class="stat-value" style="color: #ff6b6b;">${formatTime(battleState.firstCharacterDeathTime)}</div>
                    </div>
                `;
            }

            const currentStats = stats.innerHTML;
            if (deathTimeDisplay && !currentStats.includes('é¦–ä¸ªè§’è‰²æ­»äº¡æ—¶é—´')) {
                stats.innerHTML = currentStats + deathTimeDisplay;
            }
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(message) {
            // ä¼˜å…ˆä½¿ç”¨æ³¢æ¬¡æˆ˜æ–—æ—¥å¿—ï¼ˆå¦‚æœæ³¢æ¬¡æˆ˜æ–—æ­£åœ¨è¿›è¡Œï¼‰ï¼Œå¦åˆ™ä½¿ç”¨æ™®é€šæˆ˜æ–—æ—¥å¿—
            let log = null;
            if (waveBattleState.isRunning) {
                log = document.getElementById('waveBattleLog');
            }
            if (!log) {
                log = document.getElementById('battleLog');
            }
            if (!log) return;
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // å¼€å§‹æ³¢æ¬¡æˆ˜æ–—ï¼ˆå¯è§†åŒ–æ¨¡æ‹Ÿï¼‰
        window.startWaveBattle = function() {
            if (waveBattleState.isRunning) {
                return;
            }

            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„25æ³¢æ€ªç‰©æ•°æ®é…ç½®ï¼ˆç¡®ä¿æ¯æ¬¡æˆ˜æ–—éƒ½ä½¿ç”¨æœ€æ–°çš„ç•Œé¢é…ç½®ï¼‰
            for (let wave = 1; wave <= 25; wave++) {
                const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                
                if (monsterSelect && attackInput && defenseInput && hpInput && 
                    atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                    spawnRateInput && durationInput) {
                    battleWaveData[wave] = {
                        monsterId: monsterSelect.value || '',
                        attack: parseFloat(attackInput.value) || 10,
                        defense: parseFloat(defenseInput.value) || 5,
                        hp: parseFloat(hpInput.value) || 50,
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                        spawnRate: parseFloat(spawnRateInput.value) || 1,
                        duration: parseFloat(durationInput.value) || 10,
                        coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                    };
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰é…ç½®çš„æ³¢æ¬¡
            let hasWaveConfig = false;
            for (let wave = 1; wave <= 25; wave++) {
                if (battleWaveData[wave] && (battleWaveData[wave].monsterId || battleWaveData[wave].attack > 0)) {
                    hasWaveConfig = true;
                    break;
                }
            }

            if (!hasWaveConfig) {
                showMessage('è¯·å…ˆé…ç½®è‡³å°‘ä¸€æ³¢æ€ªç‰©æ•°æ®', 'error');
                return;
            }

            // è¯»å–æ€ªç‰©æ”»å‡»å»¶è¿Ÿé…ç½®ï¼ˆç§’ï¼‰
            const delayInput = document.getElementById('monsterAttackDelayInput');
            if (delayInput) {
                const val = parseFloat(delayInput.value);
                monsterAttackDelay = isNaN(val) || val < 0 ? 0 : val;
            } else {
                monsterAttackDelay = 3; // å®‰å…¨å…œåº•
            }

            // è¯»å–æ€ªç‰©ä¸å¯è¢«æ”»å‡»æ—¶é—´é…ç½®ï¼ˆç§’ï¼‰
            const invincibleInput = document.getElementById('monsterInvincibleTimeInput');
            if (invincibleInput) {
                const val = parseFloat(invincibleInput.value);
                monsterInvincibleTime = isNaN(val) || val < 0 ? 1 : val;
            } else {
                monsterInvincibleTime = 1; // é»˜è®¤1ç§’
            }

            // è¯»å–è§’è‰²æ”»å‡»é¢‘ç‡ï¼ˆç§’/æ¬¡ï¼‰å’Œä¼¤å®³å€ç‡é…ç½®
            const atkIntervalInput = document.getElementById('characterAttackIntervalInput');
            if (atkIntervalInput) {
                const val = parseFloat(atkIntervalInput.value);
                characterAttackInterval = isNaN(val) || val <= 0 ? 0.1 : val;
            } else {
                characterAttackInterval = 0.1;
            }

            const dmgScaleInput = document.getElementById('characterDamageScaleInput');
            if (dmgScaleInput) {
                const val = parseFloat(dmgScaleInput.value);
                characterDamageScale = isNaN(val) || val <= 0 ? 0.1 : val;
            } else {
                characterDamageScale = 0.1;
            }

            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„å¹³å°å±æ€§é…ç½®å¹¶æ›´æ–°
            if (typeof ensurePlatformConfigFromSource === 'function') ensurePlatformConfigFromSource();
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff')?.value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff')?.value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff')?.value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è½¦è¾†å±æ€§é…ç½®å¹¶æ›´æ–°
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack')?.value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense')?.value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp')?.value) || 0;
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§ï¼ˆç¡®ä¿åŒ…å«æœ€æ–°çš„è£…å¤‡ã€å¹³å°ã€è½¦è¾†åŠ æˆï¼‰
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });

            // é‡ç½®é“¶å¸å’Œå‡çº§ä¿¡æ¯
            waveBattleCoins = 0;
            weaponLevel = 0;
            skillLevel = 0;
            
            // ä»ç•Œé¢è¯»å–æ®ç‚¹å¥–åŠ±é…ç½®
            for (let i = 1; i <= 5; i++) {
                const rewardInput = document.getElementById(`stronghold${i}Reward`);
                strongholdRewards[i] = rewardInput ? (parseInt(rewardInput.value) || 0) : 0;
            }
            
            // é‡ç½®æ³¢æ¬¡æˆ˜æ–—çŠ¶æ€
            // æ³¨æ„ï¼šchar.attack æ­¤æ—¶å·²ç»åŒ…å«äº†è£…å¤‡ã€å¹³å°ã€è½¦è¾†åŠ æˆçš„æœ€ç»ˆæ”»å‡»åŠ›
            // baseAttack åº”è¯¥ä½¿ç”¨ char.baseAttackï¼ˆåŸºç¡€æ”»å‡»åŠ›ï¼‰ï¼Œè€Œä¸æ˜¯ char.attackï¼ˆæœ€ç»ˆæ”»å‡»åŠ›ï¼‰
            const battleStartTime = Date.now(); // è®°å½•æˆ˜æ–—å¼€å§‹æ—¶é—´
            waveBattleState = {
                isRunning: true,
                startTime: battleStartTime,
                elapsedTime: 0,
                characters: characters.map(char => ({
                    ...char,
                    // ä¿å­˜çœŸæ­£çš„è§’è‰²åŸºç¡€å±æ€§ï¼Œä¸åŒ…å«è£…å¤‡åŠ æˆï¼ˆbaseAttack/baseDefense/baseHpï¼‰
                    // char.attack/char.defense/char.maxHp æ˜¯æœ€ç»ˆå±æ€§ï¼ˆåŒ…å«è£…å¤‡ã€å¹³å°ã€è½¦è¾†åŠ æˆï¼‰
                    // è¿™äº›æœ€ç»ˆå±æ€§ä¼šç”¨äºæˆ˜æ–—è®¡ç®—ï¼Œä½†éœ€è¦ä¿å­˜åŸºç¡€å±æ€§ä»¥ä¾¿æ­£ç¡®åˆå§‹åŒ–
                    baseAttack: char.baseAttack || 20, // ä¿å­˜åŸºç¡€æ”»å‡»åŠ›ï¼ˆä¸åŒ…å«è£…å¤‡åŠ æˆï¼‰
                    baseDefense: char.baseDefense || 10, // ä¿å­˜åŸºç¡€é˜²å¾¡åŠ›
                    baseHp: char.baseHp || 100, // ä¿å­˜åŸºç¡€è¡€é‡
                    // æˆ˜æ–—ä½¿ç”¨çš„æœ€ç»ˆå±æ€§ï¼ˆåŒ…å«æ‰€æœ‰åŠ æˆï¼‰
                    attack: char.attack || char.baseAttack || 20, // æœ€ç»ˆæ”»å‡»åŠ›
                    defense: char.defense || char.baseDefense || 10, // æœ€ç»ˆé˜²å¾¡åŠ›
                    maxHp: char.maxHp || char.baseHp || 100, // æœ€ç»ˆæœ€å¤§è¡€é‡
                    hp: char.maxHp || char.baseHp || 100, // å½“å‰è¡€é‡ = æœ€å¤§è¡€é‡
                    isAlive: true,
                    lastAttackTime: battleStartTime, // åˆå§‹åŒ–ä¸ºæˆ˜æ–—å¼€å§‹æ—¶é—´ï¼Œç¡®ä¿ç¬¬ä¸€æ¬¡æ”»å‡»å¯ä»¥ç«‹å³è¿›è¡Œ
                    lastHealTime: null,
                    finalHealRate: char.finalHealRate || 0,
                    deathTime: null,
                    // ä¿ç•™ç•Œé¢é…ç½®çš„æŠ€èƒ½ä¼¤å®³ç³»æ•°ï¼ˆ%ï¼‰ï¼šè§’è‰²2/3/4ä¼šåœ¨ä¼¤å®³å…¬å¼ä¸­ä½¿ç”¨
                    skillDamage: parseFloat(char.skillDamage) || 0
                })),
                monsters: [],
                currentWave: 0,
                currentStronghold: 0,
                strongholdCompleted: {},
                waveStartTime: 0,
                waveSpawnedCount: 0,
                waveTotalCount: 0,
                nextSpawnTime: 0,
                monsterIdCounter: 0,
                totalMonstersKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                spawnAccumulator: 0, // æ€ªç‰©ç”Ÿæˆç´¯è®¡å€¼ï¼ˆç”¨äºå°æ•°ç”Ÿæˆç‡ï¼‰
                lastSpawnCheckTime: Date.now() // ä¸Šæ¬¡æ£€æŸ¥ç”Ÿæˆçš„æ—¶é—´
            };

            // æ˜¾ç¤ºæˆ˜æ–—åŒºåŸŸï¼ˆåœ¨tab-battleé¡µç­¾å†…ï¼‰
            const waveBattleArea = document.getElementById('waveBattleArea');
            if (waveBattleArea) {
                waveBattleArea.style.display = 'block';
            }
            
            // æ¸…ç©ºæˆ˜æ–—æ—¥å¿—
            const log = document.getElementById('battleLog');
            if (log) log.innerHTML = '';

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const startBtn = document.getElementById('startWaveBattleBtn');
            const stopBtn = document.getElementById('stopWaveBattleBtn');
            if (startBtn) startBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            // æ˜¾ç¤ºæ³¢æ¬¡ä¿¡æ¯
            const info = document.getElementById('waveBattleInfo');
            if (info) info.style.display = 'block';

            // æ˜¾ç¤ºæˆ˜æ–—UIé¢æ¿ï¼ˆä»…æ³¢æ¬¡æˆ˜æ–—ï¼‰
            const uiPanel = document.getElementById('waveBattleUIPanel');
            if (uiPanel) {
                uiPanel.style.display = 'block';
            }

            // å¼€å§‹ç¬¬ä¸€æ³¢ï¼ˆè¿™ä¼šåœ¨å†…éƒ¨è°ƒç”¨ updateBattleSceneï¼‰
            startNextWave();
            
            // åˆå§‹åŒ–å¯è§†åŒ–åœºæ™¯ï¼ˆåœ¨å¼€å§‹ç¬¬ä¸€æ³¢åç«‹å³è°ƒç”¨ï¼‰
            updateBattleScene();
            
            // æ›´æ–°é“¶å¸å’Œå‡çº§æŒ‰é’®æ˜¾ç¤ºï¼ˆç¡®ä¿åœ¨æ˜¾ç¤ºUIé¢æ¿åæ›´æ–°ï¼‰
            updateCoinsDisplay();
            updateUpgradeButtons();
            
            // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡æ˜¾ç¤º
            updateWaveBattleDisplay();
            
            // æ»šåŠ¨åˆ°æˆ˜æ–—åŒºåŸŸ
            if (waveBattleArea) {
                setTimeout(() => {
                    waveBattleArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }

            // å¼€å§‹æˆ˜æ–—å¾ªç¯
            waveBattleLoop();
        };

        // åœæ­¢æ³¢æ¬¡æˆ˜æ–—
        window.stopWaveBattle = function() {
            if (!waveBattleState.isRunning) {
                return;
            }

            waveBattleState.isRunning = false;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const startBtn = document.getElementById('startWaveBattleBtn');
            const stopBtn = document.getElementById('stopWaveBattleBtn');
            if (startBtn) startBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';

            const status = document.getElementById('waveBattleStatus');
            if (status) status.textContent = 'æ¨¡æ‹Ÿå·²åœæ­¢';

            addLog(`<span style="color: #ffc107; font-weight: bold;">æ³¢æ¬¡æˆ˜æ–—å·²æ‰‹åŠ¨åœæ­¢ï¼</span>`);
            addLog(`æ€»ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${waveBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${waveBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(waveBattleState.elapsedTime)}`);
        };

        // å¼€å§‹ä¸‹ä¸€æ³¢
        // æ£€æŸ¥å½“å‰æ®ç‚¹çš„æ‰€æœ‰æ€ªç‰©æ˜¯å¦éƒ½å·²æ­»äº¡
        function isCurrentStrongholdCleared() {
            if (waveBattleState.currentStronghold <= 0 || waveBattleState.currentStronghold > 5) {
                return false;
            }
            
            const waveRange = getStrongholdWaveRange(waveBattleState.currentStronghold);
            
            // é¦–å…ˆæ£€æŸ¥åœºæ™¯å†…æ˜¯å¦æœ‰è¯¥æ®ç‚¹çš„å­˜æ´»æ€ªç‰©
            const aliveMonsters = waveBattleState.monsters.filter(m => 
                m.isAlive && 
                m.wave >= waveRange.start && 
                m.wave <= waveRange.end
            );
            
            // å¦‚æœåœºæ™¯å†…è¿˜æœ‰å­˜æ´»æ€ªç‰©ï¼Œæ®ç‚¹æœªå®Œæˆ
            if (aliveMonsters.length > 0) {
                return false;
            }
            
            // åœºæ™¯å†…æ²¡æœ‰å­˜æ´»æ€ªç‰©åï¼Œè¿˜éœ€è¦æ£€æŸ¥æ®ç‚¹çš„æœ€åä¸€ä¸ªæ³¢æ¬¡æ˜¯å¦å·²ç»å®Œæˆ
            // å¦‚æœæ®ç‚¹çš„æœ€åä¸€ä¸ªæ³¢æ¬¡ï¼ˆwaveRange.endï¼‰å·²ç»å®Œæˆï¼Œä¸”åœºæ™¯å†…æ²¡æœ‰å­˜æ´»æ€ªç‰©ï¼Œ
            // è¯´æ˜æ®ç‚¹çš„æ‰€æœ‰æ³¢æ¬¡éƒ½å·²å®Œæˆï¼ˆå› ä¸ºåªæœ‰åœ¨å‰ä¸€ä¸ªæ³¢æ¬¡å®Œæˆåæ‰ä¼šå¼€å§‹ä¸‹ä¸€ä¸ªæ³¢æ¬¡ï¼‰
            const lastWave = waveRange.end;
            const lastWaveData = battleWaveData[lastWave];
            
            // å¦‚æœæœ€åä¸€ä¸ªæ³¢æ¬¡æ²¡æœ‰é…ç½®ï¼Œæˆ–è€…å½“å‰æ³¢æ¬¡å·²ç»è¶…è¿‡äº†æœ€åä¸€ä¸ªæ³¢æ¬¡ï¼Œè¯´æ˜æ®ç‚¹å·²å®Œæˆ
            if (!lastWaveData || (!lastWaveData.monsterId && lastWaveData.attack <= 0)) {
                // æœ€åä¸€ä¸ªæ³¢æ¬¡æ²¡æœ‰é…ç½®ï¼Œåªè¦åœºæ™¯å†…æ²¡æœ‰å­˜æ´»æ€ªç‰©å°±ç®—å®Œæˆ
                return true;
            }
            
            // å¦‚æœå½“å‰æ³¢æ¬¡è¿˜æœªå¼€å§‹æ®ç‚¹çš„æœ€åä¸€ä¸ªæ³¢æ¬¡ï¼Œæ®ç‚¹æœªå®Œæˆ
            if (waveBattleState.currentWave < lastWave) {
                return false;
            }
            
            // å¦‚æœå½“å‰æ³¢æ¬¡æ­£å¥½æ˜¯æ®ç‚¹çš„æœ€åä¸€ä¸ªæ³¢æ¬¡ï¼Œæ£€æŸ¥è¯¥æ³¢æ¬¡æ˜¯å¦å·²ç»å®Œæˆ
            if (waveBattleState.currentWave === lastWave) {
                const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                const waveFinished = waveElapsedTime >= lastWaveData.duration || 
                                   waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount;
                if (!waveFinished) {
                    return false; // æœ€åä¸€ä¸ªæ³¢æ¬¡è¿˜æœªå®Œæˆï¼Œæ®ç‚¹æœªå®Œæˆ
                }
            }
            
            // æ‰€æœ‰æ¡ä»¶éƒ½æ»¡è¶³ï¼šåœºæ™¯å†…æ²¡æœ‰å­˜æ´»æ€ªç‰©ï¼Œä¸”æ®ç‚¹çš„æœ€åä¸€ä¸ªæ³¢æ¬¡å·²å®Œæˆ
            return true;
        }
        
        // æ£€æŸ¥å¹¶å‘æ”¾æ®ç‚¹å®Œæˆå¥–åŠ±ï¼ˆç«‹å³å‘æ”¾ï¼Œä¸ç­‰å¾…ä¸‹ä¸€æ³¢ï¼‰
        function checkAndGrantStrongholdReward() {
            if (waveBattleState.currentStronghold <= 0 || waveBattleState.currentStronghold > 5) {
                return;
            }
            
            // æ£€æŸ¥å½“å‰æ®ç‚¹æ˜¯å¦å·²å®Œæˆä¸”è¿˜æœªå‘æ”¾å¥–åŠ±
            if (isCurrentStrongholdCleared() && !waveBattleState.strongholdCompleted[waveBattleState.currentStronghold]) {
                const reward = strongholdRewards[waveBattleState.currentStronghold] || 0;
                if (reward > 0) {
                    waveBattleCoins += reward;
                    updateCoinsDisplay();
                    addLog(`<span style="color: #ffd43b; font-weight: bold;">æ®ç‚¹ ${waveBattleState.currentStronghold} å®Œæˆï¼è·å¾— ${reward} é“¶å¸å¥–åŠ±ï¼</span>`);
                }
                waveBattleState.strongholdCompleted[waveBattleState.currentStronghold] = true;
            }
        }
        
        function startNextWave() {
            // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªæœ‰é…ç½®çš„æ³¢æ¬¡
            while (waveBattleState.currentWave < 25) {
                waveBattleState.currentWave++;
                
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData && (waveData.monsterId || waveData.attack > 0)) {
                    // æ‰¾åˆ°æœ‰é…ç½®çš„æ³¢æ¬¡ï¼Œæ£€æŸ¥æ˜¯å¦å±äºæ–°çš„æ®ç‚¹
                    const newStronghold = getStrongholdForWave(waveBattleState.currentWave);
                    if (newStronghold > waveBattleState.currentStronghold) {
                        // è¿›å…¥æ–°æ®ç‚¹ï¼Œéœ€è¦ç­‰å¾…ä¸Šä¸€ä¸ªæ®ç‚¹æ‰€æœ‰æ€ªç‰©æ­»äº¡
                        // åŒæ®ç‚¹ä¸åŒæ³¢æ¬¡ä¸éœ€è¦ç­‰å¾…ï¼Œåªæœ‰è·¨æ®ç‚¹æ‰éœ€è¦ç­‰å¾…
                        if (waveBattleState.currentStronghold > 0 && !isCurrentStrongholdCleared()) {
                            // ä¸Šä¸€ä¸ªæ®ç‚¹è¿˜æœ‰æ€ªç‰©å­˜æ´»ï¼Œä¸èƒ½å¼€å§‹æ–°æ®ç‚¹
                            waveBattleState.currentWave--; // å›é€€
                            return;
                        }
                        // ä¸Šä¸€ä¸ªæ®ç‚¹å·²å®Œæˆï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥ç»™äºˆæ®ç‚¹å¥–åŠ±ï¼ˆå¦‚æœåœ¨æ€ªç‰©æ­»äº¡æ—¶æœªå‘æ”¾ï¼Œè¿™é‡Œä½œä¸ºå¤‡ç”¨ï¼‰
                        if (waveBattleState.currentStronghold > 0) {
                            checkAndGrantStrongholdReward();
                        }
                        waveBattleState.currentStronghold = newStronghold;
                    }
                    // æ‰¾åˆ°æœ‰é…ç½®çš„æ³¢æ¬¡ï¼Œå¼€å§‹è¿™ä¸€æ³¢ï¼ˆåŒæ®ç‚¹å†…ç›´æ¥å¼€å§‹ï¼Œä¸éœ€è¦ç­‰å¾…ï¼‰
                    break;
                }
            }
            
            if (waveBattleState.currentWave > 25) {
                // æ‰€æœ‰æ³¢æ¬¡å®Œæˆ
                waveBattleState.isRunning = false;
                addLog(`<span style="color: #51cf66; font-weight: bold;">æ‰€æœ‰25æ³¢æ€ªç‰©å·²å®Œæˆï¼</span>`);
                addLog(`æ€»ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${waveBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${waveBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(waveBattleState.elapsedTime)}`);
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const startBtn = document.getElementById('startWaveBattleBtn');
                const stopBtn = document.getElementById('stopWaveBattleBtn');
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                
                const status = document.getElementById('waveBattleStatus');
                if (status) status.textContent = 'æ‰€æœ‰æ³¢æ¬¡å·²å®Œæˆ';
                
                return;
            }

            const waveData = battleWaveData[waveBattleState.currentWave];

            waveBattleState.waveStartTime = waveBattleState.elapsedTime;
            waveBattleState.waveSpawnedCount = 0;
            // è®¡ç®—æ€»æ€ªç‰©æ•°ï¼ˆä½¿ç”¨ç´¯è®¡æœºåˆ¶ï¼Œæ‰€ä»¥å¯ä»¥æ˜¯å°æ•°ç´¯è®¡åˆ°æ•´æ•°ï¼‰
            waveBattleState.waveTotalCount = Math.floor(waveData.spawnRate * waveData.duration);
            waveBattleState.nextSpawnTime = Date.now();
            waveBattleState.spawnAccumulator = 0; // é‡ç½®ç´¯è®¡å€¼
            waveBattleState.lastSpawnCheckTime = Date.now(); // é‡ç½®æ£€æŸ¥æ—¶é—´

            // æ›´æ–°æ˜¾ç¤º
            updateWaveBattleInfo();
            
            // æ›´æ–°å¯è§†åŒ–åœºæ™¯ï¼ˆæ˜¾ç¤ºå½“å‰æ³¢æ¬¡ï¼‰
            updateBattleScene();

            addLog(`<span style="color: #667eea; font-weight: bold;">========== ç¬¬ ${waveBattleState.currentWave} æ³¢å¼€å§‹ ==========</span>`);
            addLog(`æ€ªç‰©å±æ€§ï¼šæ”»å‡» ${waveData.attack}ï¼Œé˜²å¾¡ ${waveData.defense}ï¼Œç”Ÿå‘½ ${waveData.hp}ï¼Œæ”»é€Ÿ ${waveData.atkSpeed}ï¼Œä¼¤å®³ç³»æ•° ${waveData.damageCoeff}ï¼Œç”Ÿå‘½å€¼å€ç‡ ${waveData.hpCoeff}`);
            addLog(`åˆ·æ–°é€Ÿåº¦ï¼š${waveData.spawnRate} åª/ç§’ï¼ŒæŒç»­æ—¶é—´ï¼š${waveData.duration} ç§’ï¼Œæ€»æ€ªç‰©æ•°ï¼š${waveBattleState.waveTotalCount}`);
        }

        // ç”Ÿæˆæ³¢æ¬¡æ€ªç‰©
        // æ³¨æ„ï¼šä¸ºäº†æ”¯æŒ"åŒä¸€æ—¶åˆ»æ‰¹é‡å‡ºæ€ª"ï¼ˆé¿å…é€åªåˆ·æ–°å¯¼è‡´æ˜æ˜¾å…ˆåé¡ºåºï¼‰ï¼Œè¿™é‡Œä¸å†è´Ÿè´£åˆ·æ–°åœºæ™¯/UIï¼Œè°ƒç”¨æ–¹æ‰¹é‡ç”Ÿæˆåç»Ÿä¸€åˆ·æ–°ã€‚
        function spawnWaveMonster(spawnTimeSec) {
            if (waveBattleState.currentWave <= 0 || waveBattleState.currentWave > 25) {
                return;
            }

            const waveData = battleWaveData[waveBattleState.currentWave];
            if (!waveData) {
                return;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»å‡ºå®Œå½“å‰æ³¢æ¬¡çš„æ‰€æœ‰æ€ªç‰©
            if (waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                return;
            }

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æŒç»­æ—¶é—´
            const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
            if (waveElapsedTime >= waveData.duration) {
                return;
            }

            waveBattleState.monsterIdCounter++;
            
            // åº”ç”¨ç”Ÿå‘½å€¼å€ç‡
            const actualHp = Math.floor(waveData.hp * waveData.hpCoeff);
            
            const monster = {
                id: waveBattleState.monsterIdCounter,
                wave: waveBattleState.currentWave,
                attack: waveData.attack,
                defense: waveData.defense,
                hp: actualHp,
                maxHp: actualHp,
                atkSpeed: waveData.atkSpeed,
                damageCoeff: waveData.damageCoeff,
                coinReward: waveData.coinReward || 0, // å‡»æ€è·å¾—çš„é“¶å¸
                spawnTimeSec: (typeof spawnTimeSec === 'number' && isFinite(spawnTimeSec)) ? spawnTimeSec : Math.floor(waveBattleState.elapsedTime),
                spawnGameTime: waveBattleState.elapsedTime, // ç²¾ç¡®è®°å½•ç”Ÿæˆæ—¶çš„æˆ˜æ–—æ—¶é—´ï¼ˆç§’ï¼‰
                isAlive: true,
                lastAttackTime: 0
            };

            waveBattleState.monsters.push(monster);
            waveBattleState.waveSpawnedCount++;

            addLog(`[${formatTime(waveBattleState.elapsedTime)}] ç¬¬${waveBattleState.currentWave}æ³¢ æ€ªç‰© #${monster.id} å‡ºç°ï¼`);

            // ç´¯è®¡å€¼å·²ä½¿ç”¨ï¼Œä¸éœ€è¦è®¾ç½®ä¸‹æ¬¡å‡ºæ€ªæ—¶é—´ï¼ˆç”±ç´¯è®¡æœºåˆ¶æ§åˆ¶ï¼‰
        }

        // æ³¢æ¬¡æˆ˜æ–—å¾ªç¯
        function waveBattleLoop() {
            if (!waveBattleState.isRunning) {
                return;
            }

            const now = Date.now();
            waveBattleState.elapsedTime = (now - waveBattleState.startTime) / 1000;

            // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹ä¸‹ä¸€æ³¢
            // éœ€æ±‚ï¼šå½“å‰æ³¢æ€ªç‰©åˆ·å®Œåï¼Œéœ€è¦ç­‰å¾…å½“å‰æ®ç‚¹æ‰€æœ‰æ€ªç‰©æ­»äº¡æ‰èƒ½å¼€å§‹ä¸‹ä¸€ä¸ªæ®ç‚¹
            // ä¸ºé¿å…å› æµ®ç‚¹è¯¯å·®å¯¼è‡´"åˆ·æ€ªæ•°æœªå®Œå…¨è¾¾åˆ°ç†è®ºæ€»æ•°è€Œå¡æ­»"ï¼Œè¿™é‡Œä½¿ç”¨"æŒç»­æ—¶é—´åˆ° æˆ– åˆ·æ€ªæ•°è¾¾åˆ°æ€»æ•°"ä»»ä¸€æ¡ä»¶å³å¯æ¨è¿›ä¸‹ä¸€æ³¢
            if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData) {
                    const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                    
                    // å¦‚æœå½“å‰æ³¢æ¬¡æŒç»­æ—¶é—´å·²åˆ°ï¼Œæˆ–æ€ªç‰©å·²æŒ‰é…ç½®åˆ·å®Œï¼Œåˆ™å°è¯•å¼€å§‹ä¸‹ä¸€æ³¢
                    // æ³¨æ„ï¼šstartNextWaveå†…éƒ¨ä¼šæ£€æŸ¥æ®ç‚¹æ˜¯å¦å®Œæˆ
                    if (waveElapsedTime >= waveData.duration ||
                        waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                        const oldWave = waveBattleState.currentWave;
                        startNextWave();
                        // å¦‚æœæˆåŠŸå¼€å§‹ä¸‹ä¸€æ³¢ï¼Œè®°å½•æ—¥å¿—
                        if (waveBattleState.currentWave > oldWave) {
                            addLog(`<span style="color: #51cf66;">ç¬¬ ${oldWave} æ³¢å®Œæˆï¼å¼€å§‹ä¸‹ä¸€æ³¢...</span>`);
                        }
                    }
                }
            }

            // ç”Ÿæˆæ€ªç‰©ï¼ˆä½¿ç”¨ç´¯è®¡æœºåˆ¶æ”¯æŒå°æ•°ç”Ÿæˆç‡ï¼›åŒä¸€å¸§å†…æ‰¹é‡å‡ºæ€ªåç»Ÿä¸€åˆ·æ–°ï¼Œé¿å…æ˜æ˜¾å…ˆåé¡ºåºï¼‰
            if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                const waveData = battleWaveData[waveBattleState.currentWave];
                if (waveData) {
                    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æŒç»­æ—¶é—´ï¼ˆé˜²æ­¢åœ¨æ³¢æ¬¡ç»“æŸåç»§ç»­ç”Ÿæˆï¼‰
                    const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                    if (waveElapsedTime >= waveData.duration) {
                        // æ³¢æ¬¡æŒç»­æ—¶é—´å·²åˆ°ï¼Œä¸å†ç”Ÿæˆæ–°æ€ªç‰©
                        // ç‰¹åˆ«å¤„ç†ï¼šå¦‚æœæ˜¯æœ€åä¸€æ³¢ï¼ˆç¬¬25æ³¢ï¼‰ï¼Œæ¸…é›¶ç´¯è®¡å€¼ï¼Œå®Œå…¨åœæ­¢ç”Ÿæˆ
                        if (waveBattleState.currentWave === 25) {
                            waveBattleState.spawnAccumulator = 0; // æ¸…é›¶ç´¯è®¡å€¼ï¼Œé˜²æ­¢ç»§ç»­ç”Ÿæˆ
                        }
                        waveBattleState.lastSpawnCheckTime = now; // æ›´æ–°æ—¶é—´ï¼Œé¿å…ç´¯è®¡å€¼å¼‚å¸¸å¢é•¿
                    } else {
                        // è®¡ç®—è‡ªä¸Šæ¬¡æ£€æŸ¥ä»¥æ¥çš„æ—¶é—´å·®ï¼ˆç§’ï¼‰
                        let deltaTime = (now - waveBattleState.lastSpawnCheckTime) / 1000;
                        
                        // ä¿æŠ¤æªæ–½ï¼šé™åˆ¶deltaTimeçš„æœ€å¤§å€¼ï¼Œé¿å…å› å¾ªç¯æš‚åœå¯¼è‡´å¤§é‡æ€ªç‰©ç”Ÿæˆ
                        // æœ€å¤§å…è®¸1ç§’çš„æ—¶é—´å·®ï¼ˆæ­£å¸¸æƒ…å†µä¸‹æ¯å¸§é—´éš”å¾ˆçŸ­ï¼‰
                        if (deltaTime > 1.0) {
                            console.warn(`æ£€æµ‹åˆ°å¼‚å¸¸å¤§çš„æ—¶é—´å·®: ${deltaTime.toFixed(2)}ç§’ï¼Œå·²é™åˆ¶ä¸º1ç§’`);
                            deltaTime = 1.0;
                        }
                        
                        // ç¡®ä¿lastSpawnCheckTimeä¸ä¸ºnull
                        if (!waveBattleState.lastSpawnCheckTime) {
                            waveBattleState.lastSpawnCheckTime = now;
                            deltaTime = 0;
                        }
                        
                        waveBattleState.lastSpawnCheckTime = now;
                        
                        // ç´¯è®¡æ€ªç‰©æ•°é‡ï¼ˆæ¯ç§’spawnRateåªï¼‰
                        waveBattleState.spawnAccumulator += waveData.spawnRate * deltaTime;
                        
                        // å½“ç´¯è®¡å€¼>=1æ—¶ï¼Œç”Ÿæˆæ€ªç‰©ï¼ˆä½†ä¸è¶…è¿‡å½“å‰æ³¢æ¬¡åº”è¯¥ç”Ÿæˆçš„æ€»æ•°ï¼Œä¸”ä¸è¶…è¿‡æŒç»­æ—¶é—´ï¼‰
                        let spawnedThisTick = 0;
                        const spawnTimeSec = Math.floor(waveBattleState.elapsedTime);
                        // é‡æ–°è®¡ç®—waveElapsedTimeï¼Œç¡®ä¿åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­ä¹Ÿæ£€æŸ¥æŒç»­æ—¶é—´
                        const currentWaveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                        while (waveBattleState.spawnAccumulator >= 1.0 && 
                               waveBattleState.waveSpawnedCount < waveBattleState.waveTotalCount &&
                               currentWaveElapsedTime < waveData.duration) {
                            spawnWaveMonster(spawnTimeSec);
                            waveBattleState.spawnAccumulator -= 1.0; // å‡å»1åª
                            spawnedThisTick++;
                            
                            // é¢å¤–ä¿æŠ¤ï¼šå¦‚æœå·²ç»è¾¾åˆ°æ€»æ•°ï¼Œæ¸…é›¶ç´¯è®¡å€¼ï¼Œé¿å…ç»§ç»­ç”Ÿæˆ
                            if (waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount) {
                                waveBattleState.spawnAccumulator = 0;
                                break;
                            }
                            
                            // é¢å¤–ä¿æŠ¤ï¼šå¦‚æœæŒç»­æ—¶é—´å·²åˆ°ï¼ˆç‰¹åˆ«æ˜¯æœ€åä¸€æ³¢ï¼‰ï¼Œæ¸…é›¶ç´¯è®¡å€¼å¹¶åœæ­¢ç”Ÿæˆ
                            const checkWaveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                            if (checkWaveElapsedTime >= waveData.duration) {
                                waveBattleState.spawnAccumulator = 0;
                                break;
                            }
                        }

                        // æœ¬å¸§å¦‚æœç”Ÿæˆäº†æ€ªç‰©ï¼Œç»Ÿä¸€åˆ·æ–°ä¸€æ¬¡ï¼Œç¡®ä¿åŒæ—¶å‡ºç°
                        if (spawnedThisTick > 0) {
                            updateWaveBattleInfo();
                            updateBattleScene();
                        }
                    }
                }
            }

            // è§’è‰²æ”»å‡»ï¼ˆæŒ‰æ—¶é—´è¡¥é½ï¼šé¿å…å¸§ç‡ä¸‹é™å¯¼è‡´â€œæ”»é€Ÿå˜æ…¢â€ï¼‰
            const maxAttacksPerFrame = 10; // å•å¸§æœ€å¤šè¡¥é½æ¬¡æ•°ï¼Œé˜²æ­¢å¡é¡¿æ—¶çˆ†å‘å¾ªç¯
            waveBattleState.characters.forEach(char => {
                if (!char.isAlive || waveBattleState.monsters.length === 0) return;

                // ä½¿ç”¨å…¨å±€é…ç½®çš„è§’è‰²æ”»å‡»é¢‘ç‡ï¼ˆç§’/æ¬¡ï¼‰ï¼Œé»˜è®¤0.1ç§’1æ¬¡
                const attackIntervalSec = (typeof characterAttackInterval === 'number' && characterAttackInterval > 0)
                    ? characterAttackInterval
                    : (1 / (char.atkSpeed || 1));

                const intervalMs = attackIntervalSec * 1000;
                if (!isFinite(intervalMs) || intervalMs <= 0) return;

                let elapsedMs = now - (char.lastAttackTime || waveBattleState.startTime);
                if (elapsedMs < intervalMs) return;

                const shouldAttacks = Math.min(maxAttacksPerFrame, Math.floor(elapsedMs / intervalMs));
                for (let i = 0; i < shouldAttacks; i++) {
                    if (!char.isAlive || waveBattleState.monsters.length === 0) break;
                    characterAttackWave(char);
                    char.lastAttackTime = (char.lastAttackTime || now) + intervalMs;
                }

                // å…œåº•ï¼šä¿è¯lastAttackTimeä¸ä¼šè·‘åˆ°æœªæ¥å¤ªå¤šï¼ˆæ¯”å¦‚elapsedMså¾ˆå°ä½†lastAttackTimeä¸ºç©ºï¼‰
                if (char.lastAttackTime > now) {
                    char.lastAttackTime = now;
                }
            });

            // è§’è‰²å›è¡€ï¼ˆè§’è‰²5ï¼‰
            waveBattleState.characters.forEach(char => {
                if (char.isAlive && char.id === 5 && char.finalHealRate > 0) {
                    const timeSinceLastHeal = (now - (char.lastHealTime || waveBattleState.startTime)) / 1000;
                    if (timeSinceLastHeal >= 1.0) {
                        const aliveChars = waveBattleState.characters.filter(c => c.isAlive);
                        if (aliveChars.length > 0) {
                            const targetChar = aliveChars.reduce((min, c) => {
                                const minRatio = min.hp / min.maxHp;
                                const cRatio = c.hp / c.maxHp;
                                return cRatio < minRatio ? c : min;
                            });

                            if (targetChar.hp < targetChar.maxHp) {
                                const healAmount = char.finalHealRate;
                                targetChar.hp = Math.min(targetChar.maxHp, targetChar.hp + healAmount);
                                addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-heal">${char.name}</span> ä¸º <span class="log-heal">${targetChar.name}</span> æ¢å¤ ${healAmount.toFixed(2)} ç‚¹ç”Ÿå‘½å€¼`);
                                
                                // æ˜¾ç¤ºå›è¡€åŠ¨ç”»å’Œæ•°å­—
                                const targetSprite = document.getElementById(`char-sprite-${targetChar.id}`);
                                if (targetSprite) {
                                    // æ˜¾ç¤ºå›è¡€æ•°å­—
                                    showDamageNumber(targetSprite, healAmount, true);
                                }
                            }
                        }
                        char.lastHealTime = now;
                    }
                }
            });

            // æ€ªç‰©æ”»å‡»ï¼ˆåŒæ ·æŒ‰æ—¶é—´è¡¥é½ï¼‰
            const maxMonsterAttacksPerFrame = 10;
            const anyCharAlive = waveBattleState.characters.some(c => c.isAlive);
            if (anyCharAlive) {
                waveBattleState.monsters.forEach(monster => {
                    if (!monster.isAlive) return;

                    const atkSpeed = monster.atkSpeed || 0;
                    if (atkSpeed <= 0) return;
                    const intervalMs = (1 / atkSpeed) * 1000;
                    if (!isFinite(intervalMs) || intervalMs <= 0) return;

                    let elapsedMs = now - (monster.lastAttackTime || waveBattleState.startTime);
                    if (elapsedMs < intervalMs) return;

                    const shouldAttacks = Math.min(maxMonsterAttacksPerFrame, Math.floor(elapsedMs / intervalMs));
                    for (let i = 0; i < shouldAttacks; i++) {
                        if (!monster.isAlive) break;
                        if (!waveBattleState.characters.some(c => c.isAlive)) break;
                        monsterAttackWave(monster);
                        monster.lastAttackTime = (monster.lastAttackTime || now) + intervalMs;
                    }

                    if (monster.lastAttackTime > now) {
                        monster.lastAttackTime = now;
                    }
                });
            }

            // æ¸…ç†æ­»äº¡æ€ªç‰©
            waveBattleState.monsters = waveBattleState.monsters.filter(monster => monster.isAlive);

            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶ï¼šæ®ç‚¹5ï¼ˆç¬¬21-25æ³¢ï¼‰æ‰€æœ‰æ€ªç‰©éƒ½å·²å‡»æ€
            // åªæœ‰å½“æ®ç‚¹5çš„æ‰€æœ‰æ³¢æ¬¡ï¼ˆ21-25æ³¢ï¼‰çš„æ‰€æœ‰æ€ªç‰©éƒ½è¢«å‡»æ€åï¼Œæ‰ç®—æ®ç‚¹5èƒœåˆ©
            // æ£€æŸ¥æ¡ä»¶ï¼š
            // 1. æ‰€æœ‰25æ³¢éƒ½å·²å®Œæˆï¼ˆcurrentWave > 25ï¼Œæˆ–currentWave === 25ä¸”ç¬¬25æ³¢å·²å‡ºå®Œï¼‰
            // 2. å½“å‰æ®ç‚¹æ˜¯æ®ç‚¹5ï¼Œä¸”æ®ç‚¹5çš„æ‰€æœ‰æ€ªç‰©éƒ½å·²æ­»äº¡
            if (waveBattleState.currentStronghold === 5) {
                let all25WavesFinished = false;
                
                // æ£€æŸ¥æ‰€æœ‰25æ³¢æ˜¯å¦éƒ½å·²å®Œæˆ
                if (waveBattleState.currentWave > 25) {
                    all25WavesFinished = true;
                } else if (waveBattleState.currentWave === 25) {
                    const waveData = battleWaveData[25];
                    if (waveData) {
                        const waveElapsedTime = waveBattleState.elapsedTime - waveBattleState.waveStartTime;
                        // æ£€æŸ¥ç¬¬25æ³¢æ˜¯å¦å·²ç»å‡ºå®Œæ‰€æœ‰æ€ªç‰©ï¼ˆæŒç»­æ—¶é—´å·²åˆ° æˆ– æ€ªç‰©å·²æŒ‰é…ç½®åˆ·å®Œï¼‰
                        all25WavesFinished = waveElapsedTime >= waveData.duration || 
                                             waveBattleState.waveSpawnedCount >= waveBattleState.waveTotalCount;
                    }
                }
                
                // æ£€æŸ¥æ®ç‚¹5çš„æ‰€æœ‰æ³¢æ¬¡ï¼ˆ21-25æ³¢ï¼‰çš„æ‰€æœ‰æ€ªç‰©æ˜¯å¦éƒ½å·²æ­»äº¡
                if (all25WavesFinished && isCurrentStrongholdCleared()) {
                    // åˆ¤å®šèƒœåˆ©ï¼šæ®ç‚¹5èƒœåˆ©
                    waveBattleState.isRunning = false;
                    
                    // å‘æ”¾æ®ç‚¹5çš„å¥–åŠ±ï¼ˆå¦‚æœè¿˜æœªå‘æ”¾ï¼‰
                    checkAndGrantStrongholdReward();
                    
                    addLog(`<span style="color: #51cf66; font-weight: bold;">ğŸ† èƒœåˆ©ï¼æ®ç‚¹5å®Œæˆï¼æ‰€æœ‰ç¬¬21-25æ³¢æ€ªç‰©éƒ½å·²æ¸…é™¤ï¼</span>`);
                    addLog(`<span style="color: #51cf66; font-weight: bold;">æ‰€æœ‰25æ³¢æ€ªç‰©å·²å®Œæˆï¼</span>`);
                    addLog(`æ€»ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${waveBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${waveBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(waveBattleState.elapsedTime)}`);
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    const startBtn = document.getElementById('startWaveBattleBtn');
                    const stopBtn = document.getElementById('stopWaveBattleBtn');
                    if (startBtn) startBtn.style.display = 'inline-block';
                    if (stopBtn) stopBtn.style.display = 'none';
                    
                    const status = document.getElementById('waveBattleStatus');
                    if (status) status.textContent = 'æˆ˜æ–—ç»“æŸï¼šèƒœåˆ©ï¼';
                    
                    updateWaveBattleDisplay();
                    return;
                }
            }

            // æ£€æŸ¥æˆ˜æ–—ç»“æŸï¼ˆæ‰€æœ‰è§’è‰²æ­»äº¡ï¼‰
            const allCharactersDead = !waveBattleState.characters.some(c => c.isAlive);
            if (allCharactersDead) {
                waveBattleState.isRunning = false;
                addLog(`<span style="color: #f44336; font-weight: bold;">æ‰€æœ‰è§’è‰²é˜µäº¡ï¼æˆ˜æ–—ç»“æŸ</span>`);
                addLog(`æ€»ç»Ÿè®¡ï¼šå‡»è´¥æ€ªç‰© ${waveBattleState.totalMonstersKilled}ï¼Œä¼¤å®³è¾“å‡º ${waveBattleState.totalDamageDealt}ï¼Œæˆ˜æ–—æ—¶é•¿ ${formatTime(waveBattleState.elapsedTime)}`);
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const startBtn = document.getElementById('startWaveBattleBtn');
                const stopBtn = document.getElementById('stopWaveBattleBtn');
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                
                const status = document.getElementById('waveBattleStatus');
                if (status) status.textContent = 'æˆ˜æ–—ç»“æŸï¼šæ‰€æœ‰è§’è‰²é˜µäº¡';
                
                updateWaveBattleDisplay();
                return;
            }

            // æ›´æ–°æ˜¾ç¤º
            updateWaveBattleDisplay();
            updateWaveBattleInfo();

            // ç»§ç»­å¾ªç¯
            requestAnimationFrame(waveBattleLoop);
        }

        // è§’è‰²æ”»å‡»ï¼ˆæ³¢æ¬¡æˆ˜æ–—ï¼‰
        function characterAttackWave(character) {
            if (waveBattleState.monsters.length === 0) return;

            // æ”»å‡»ç¬¬ä¸€ä¸ªå­˜æ´»çš„æ€ªç‰©ï¼ˆä¸”å·²ç»è¿‡äº†ä¸å¯è¢«æ”»å‡»æ—¶é—´ï¼‰
            const target = waveBattleState.monsters.find(m => {
                if (!m.isAlive) return false;
                // æ£€æŸ¥æ€ªç‰©æ˜¯å¦å·²ç»è¿‡äº†ä¸å¯è¢«æ”»å‡»çš„æ—¶é—´æ®µ
                if (m.spawnGameTime !== undefined) {
                    const timeSinceSpawn = waveBattleState.elapsedTime - m.spawnGameTime;
                    return timeSinceSpawn >= monsterInvincibleTime;
                }
                return true; // å¦‚æœæ²¡æœ‰ç”Ÿæˆæ—¶é—´è®°å½•ï¼Œå…è®¸æ”»å‡»ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
            });
            if (!target) return;

            // åŸºç¡€ä¼¤å®³è®¡ç®—
            let baseDamage = Math.max(1, character.attack - target.defense);
            
            // åº”ç”¨æ­¦å™¨ä¼¤å®³ç³»æ•°
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const weaponDamageCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            baseDamage = baseDamage * weaponDamageCoeff;
            
            // è§’è‰²2ã€3ã€4çš„æŠ€èƒ½ä¼¤å®³åŠ æˆ
            let finalDamage = baseDamage;
            const skillPct = parseFloat(character.skillDamage) || 0;
            if ((character.id === 2 || character.id === 3 || character.id === 4) && skillPct !== 0) {
                const skillBonus = baseDamage * (skillPct / 100);
                finalDamage = baseDamage + skillBonus;
                finalDamage = Math.max(1, Math.floor(finalDamage));
            }
            
            // åº”ç”¨æŠ€èƒ½å‡çº§ä¼¤å®³ç³»æ•°ï¼ˆæ‰€æœ‰è§’è‰²çš„æœ€ç»ˆä¼¤å®³ä¹˜ä»¥æŠ€èƒ½å‡çº§ä¼¤å®³ç³»æ•°ï¼‰
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const skillDamageCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
            finalDamage = finalDamage * skillDamageCoeff;

            // åº”ç”¨ç»Ÿä¸€çš„è§’è‰²æ”»å‡»ä¼¤å®³å€ç‡ï¼ˆä¾‹å¦‚0.1å€ä¼¤å®³ï¼‰
            const dmgScale = (typeof characterDamageScale === 'number' && characterDamageScale > 0) ? characterDamageScale : 1.0;
            finalDamage = finalDamage * dmgScale;
            finalDamage = Math.max(1, Math.floor(finalDamage));
            
            target.hp -= finalDamage;
            waveBattleState.totalDamageDealt += finalDamage;

            let damageText = finalDamage === baseDamage 
                ? `${finalDamage}`
                : `${finalDamage}ï¼ˆåŸºç¡€${baseDamage.toFixed(1)} + æŠ€èƒ½${(finalDamage - baseDamage).toFixed(1)}ï¼‰`;
            
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-damage">${character.name}</span> æ”»å‡» ç¬¬${target.wave}æ³¢æ€ªç‰© #${target.id}ï¼Œé€ æˆ ${damageText} ç‚¹ä¼¤å®³`);

            // æ˜¾ç¤ºæ”»å‡»åŠ¨ç”»
            const charSprite = document.getElementById(`char-sprite-${character.id}`);
            if (charSprite) {
                charSprite.classList.remove('attacking');
                void charSprite.offsetWidth; // è§¦å‘é‡æ’
                charSprite.classList.add('attacking');
                setTimeout(() => {
                    charSprite.classList.remove('attacking');
                }, 500);
            }

            // æ˜¾ç¤ºå—å‡»åŠ¨ç”»å’Œä¼¤å®³æ•°å­—
            const monsterSprite = document.getElementById(`monster-sprite-${target.id}`);
            if (monsterSprite) {
                monsterSprite.classList.remove('hit');
                void monsterSprite.offsetWidth;
                monsterSprite.classList.add('hit');
                setTimeout(() => {
                    monsterSprite.classList.remove('hit');
                }, 300);
                
                // æ˜¾ç¤ºä¼¤å®³æ•°å­—
                showDamageNumber(monsterSprite, finalDamage, false);
            }

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                waveBattleState.totalMonstersKilled++;
                
                // è·å¾—é“¶å¸
                const coinReward = target.coinReward || 0;
                if (coinReward > 0) {
                    waveBattleCoins += coinReward;
                    updateCoinsDisplay();
                    addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-kill">ç¬¬${target.wave}æ³¢æ€ªç‰© #${target.id} è¢«å‡»è´¥ï¼è·å¾— ${coinReward} é“¶å¸</span>`);
                } else {
                    addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-kill">ç¬¬${target.wave}æ³¢æ€ªç‰© #${target.id} è¢«å‡»è´¥ï¼</span>`);
                }
                
                // æ€ªç‰©æ­»äº¡åŠ¨ç”»
                if (monsterSprite) {
                    monsterSprite.classList.add('dead');
                }
                
                // æ£€æŸ¥æ®ç‚¹æ˜¯å¦å®Œæˆï¼Œå¦‚æœå®Œæˆåˆ™ç«‹å³å‘æ”¾æ®ç‚¹å¥–åŠ±
                checkAndGrantStrongholdReward();
            }
        }

        // æ›´æ–°é“¶å¸æ˜¾ç¤º
        function updateCoinsDisplay() {
            // åªæ›´æ–°æ³¢æ¬¡æˆ˜æ–—çš„é“¶å¸æ˜¾ç¤º
            const waveCoinsDisplay = document.getElementById('waveCoinsDisplay');
            if (waveCoinsDisplay) {
                waveCoinsDisplay.textContent = waveBattleCoins;
            }
            updateUpgradeButtons();
        }

        // æ›´æ–°å‡çº§æŒ‰é’®çŠ¶æ€
        function updateUpgradeButtons() {
            // åªä½¿ç”¨æ³¢æ¬¡æˆ˜æ–—çš„æŒ‰é’®
            const weaponBtn = document.getElementById('waveUpgradeWeaponBtn');
            const skillBtn = document.getElementById('waveUpgradeSkillBtn');
            const weaponInfo = document.getElementById('waveWeaponUpgradeInfo');
            const skillInfo = document.getElementById('waveSkillUpgradeInfo');
            
            // æ­¦å™¨å‡çº§ï¼ˆä»å½“å‰ç­‰çº§å‡çº§åˆ°ä¸‹ä¸€çº§ï¼Œè¯»å–å½“å‰ç­‰çº§å¯¹åº”çš„ä»·æ ¼ï¼‰
            const nextWeaponLevel = weaponLevel + 1;
            const weaponCost = weaponCostTable.find(w => w.level === weaponLevel);
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const nextWeaponData = weaponCostTable.find(w => w.level === nextWeaponLevel);
            
            if (weaponBtn && weaponInfo) {
                if (weaponCost) {
                    const canUpgrade = waveBattleCoins >= weaponCost.cost;
                    weaponBtn.disabled = !canUpgrade;
                    
                    // è·å–å½“å‰å’Œä¸‹ä¸€çº§çš„ä¼¤å®³ç³»æ•°
                    const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
                    const nextCoeff = (nextWeaponData && nextWeaponData.damageCoeff !== undefined) ? parseFloat(nextWeaponData.damageCoeff) : currentCoeff;
                    const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
                    
                    weaponInfo.textContent = `Lv.${weaponLevel} (ç³»æ•°${currentCoeff.toFixed(2)}) â†’ Lv.${nextWeaponLevel} (${weaponCost.cost}é“¶å¸, +${((upgradeRatio - 1) * 100).toFixed(1)}%)`;
                    // æ ¹æ®æ˜¯å¦å¯ä»¥å‡çº§è®¾ç½®é¢œè‰²ï¼ˆæŒ‰é’®ä¸»æ–‡å­—ï¼‰
                    if (canUpgrade) {
                        weaponBtn.style.color = '#90ee90'; // æµ…ç»¿è‰²ï¼Œæ›´æ¸…æ™°
                        weaponInfo.style.color = '#90ee90'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…ç»¿è‰²
                    } else {
                        weaponBtn.style.color = '#ffcccc'; // æµ…çº¢è‰²ï¼Œæ›´æ¸…æ™°
                        weaponInfo.style.color = '#ffcccc'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…çº¢è‰²
                    }
                } else {
                    weaponBtn.disabled = true;
                    const currentCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
                    weaponInfo.textContent = `Lv.${weaponLevel} (ç³»æ•°${currentCoeff.toFixed(2)}, å·²æ»¡çº§)`;
                    weaponBtn.style.color = '#ffcccc'; // æµ…çº¢è‰²ï¼ˆå·²æ»¡çº§ï¼‰ï¼Œæ›´æ¸…æ™°
                    weaponInfo.style.color = '#ffcccc'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…çº¢è‰²
                }
            }
            
            // æŠ€èƒ½å‡çº§ï¼ˆä»å½“å‰ç­‰çº§å‡çº§åˆ°ä¸‹ä¸€çº§ï¼Œè¯»å–å½“å‰ç­‰çº§å¯¹åº”çš„ä»·æ ¼ï¼‰
            const nextSkillLevel = skillLevel + 1;
            const skillCost = skillCostTable.find(s => s.level === skillLevel);
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const nextSkillData = skillCostTable.find(s => s.level === nextSkillLevel);
            
            if (skillBtn && skillInfo) {
                if (skillCost) {
                    const canUpgrade = waveBattleCoins >= skillCost.cost;
                    skillBtn.disabled = !canUpgrade;
                    
                    // è·å–å½“å‰å’Œä¸‹ä¸€çº§çš„ä¼¤å®³ç³»æ•°
                    const currentCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
                    const nextCoeff = (nextSkillData && nextSkillData.damageCoeff !== undefined) ? parseFloat(nextSkillData.damageCoeff) : currentCoeff;
                    const upgradeRatio = currentCoeff > 0 ? nextCoeff / currentCoeff : 1.0;
                    
                    skillInfo.textContent = `Lv.${skillLevel} (ç³»æ•°${currentCoeff.toFixed(2)}) â†’ Lv.${nextSkillLevel} (${skillCost.cost}é“¶å¸, +${((upgradeRatio - 1) * 100).toFixed(1)}%)`;
                    // æ ¹æ®æ˜¯å¦å¯ä»¥å‡çº§è®¾ç½®é¢œè‰²ï¼ˆæŒ‰é’®ä¸»æ–‡å­—ï¼‰
                    if (canUpgrade) {
                        skillBtn.style.color = '#90ee90'; // æµ…ç»¿è‰²ï¼Œæ›´æ¸…æ™°
                        skillInfo.style.color = '#90ee90'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…ç»¿è‰²
                    } else {
                        skillBtn.style.color = '#ffcccc'; // æµ…çº¢è‰²ï¼Œæ›´æ¸…æ™°
                        skillInfo.style.color = '#ffcccc'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…çº¢è‰²
                    }
                } else {
                    skillBtn.disabled = true;
                    const currentCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
                    skillInfo.textContent = `Lv.${skillLevel} (ç³»æ•°${currentCoeff.toFixed(2)}, å·²æ»¡çº§)`;
                    skillBtn.style.color = '#ffcccc'; // æµ…çº¢è‰²ï¼ˆå·²æ»¡çº§ï¼‰ï¼Œæ›´æ¸…æ™°
                    skillInfo.style.color = '#ffcccc'; // ä¿¡æ¯æ–‡å­—ä¹Ÿç”¨æµ…çº¢è‰²
                }
            }
        }

        // æ­¦å™¨å‡çº§
        window.upgradeWeapon = function() {
            // è¯»å–å½“å‰ç­‰çº§å¯¹åº”çš„ä»·æ ¼ï¼ˆ0çº§å‡çº§åˆ°1çº§ï¼Œè¯»å–level=0çš„ä»·æ ¼ï¼‰
            const weaponCost = weaponCostTable.find(w => w.level === weaponLevel);
            
            if (!weaponCost) {
                showMessage('æ­¦å™¨å·²è¾¾åˆ°æœ€é«˜ç­‰çº§', 'error');
                return;
            }
            
            if (waveBattleCoins < weaponCost.cost) {
                showMessage(`é“¶å¸ä¸è¶³ï¼éœ€è¦ ${weaponCost.cost} é“¶å¸ï¼Œå½“å‰åªæœ‰ ${waveBattleCoins} é“¶å¸`, 'error');
                return;
            }
            
            waveBattleCoins -= weaponCost.cost;
            weaponLevel = weaponLevel + 1;
            
            // è·å–å½“å‰ç­‰çº§çš„ä¼¤å®³ç³»æ•°
            const currentWeaponData = weaponCostTable.find(w => w.level === weaponLevel);
            const damageCoeff = (currentWeaponData && currentWeaponData.damageCoeff !== undefined) ? parseFloat(currentWeaponData.damageCoeff) : 1.0;
            
            updateCoinsDisplay();
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #667eea; font-weight: bold;">æ­¦å™¨å‡çº§åˆ° Lv.${weaponLevel}ï¼æ¶ˆè€— ${weaponCost.cost} é“¶å¸ï¼Œä¼¤å®³ç³»æ•° ${damageCoeff.toFixed(2)}</span>`);
        };

        // æŠ€èƒ½å‡çº§
        window.upgradeSkill = function() {
            // è¯»å–å½“å‰ç­‰çº§å¯¹åº”çš„ä»·æ ¼ï¼ˆ0çº§å‡çº§åˆ°1çº§ï¼Œè¯»å–level=0çš„ä»·æ ¼ï¼‰
            const skillCost = skillCostTable.find(s => s.level === skillLevel);
            
            if (!skillCost) {
                showMessage('æŠ€èƒ½å·²è¾¾åˆ°æœ€é«˜ç­‰çº§', 'error');
                return;
            }
            
            if (waveBattleCoins < skillCost.cost) {
                showMessage(`é“¶å¸ä¸è¶³ï¼éœ€è¦ ${skillCost.cost} é“¶å¸ï¼Œå½“å‰åªæœ‰ ${waveBattleCoins} é“¶å¸`, 'error');
                return;
            }
            
            waveBattleCoins -= skillCost.cost;
            skillLevel = skillLevel + 1;
            
            // è·å–å½“å‰ç­‰çº§çš„ä¼¤å®³ç³»æ•°
            const currentSkillData = skillCostTable.find(s => s.level === skillLevel);
            const damageCoeff = (currentSkillData && currentSkillData.damageCoeff !== undefined) ? parseFloat(currentSkillData.damageCoeff) : 1.0;
            
            updateCoinsDisplay();
            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #f093fb; font-weight: bold;">æŠ€èƒ½å‡çº§åˆ° Lv.${skillLevel}ï¼æ¶ˆè€— ${skillCost.cost} é“¶å¸ï¼Œä¼¤å®³ç³»æ•° ${damageCoeff.toFixed(2)}</span>`);
        };

        // æ€ªç‰©æ”»å‡»ï¼ˆæ³¢æ¬¡æˆ˜æ–—ï¼‰
        function monsterAttackWave(monster) {
            // æ€ªç‰©ç”Ÿæˆåå‰ monsterAttackDelay ç§’ä¸æ”»å‡»
            const delay = typeof monsterAttackDelay === 'number' ? monsterAttackDelay : 0;
            if (delay > 0) {
                const spawnTime = (typeof monster.spawnGameTime === 'number' ? monster.spawnGameTime : waveBattleState.elapsedTime);
                const aliveTime = waveBattleState.elapsedTime - spawnTime;
                if (aliveTime < delay) {
                    return;
                }
            }

            // ä¼˜å…ˆæ”»å‡»è§’è‰²1ï¼ŒæŒ‰1~5é¡ºåºä¾æ¬¡æ”»å‡»
            let target = null;
            for (let i = 1; i <= 5; i++) {
                const char = waveBattleState.characters.find(c => c.id === i && c.isAlive);
                if (char) {
                    target = char;
                    break;
                }
            }

            if (!target) return;

            // åŸºç¡€ä¼¤å®³è®¡ç®—
            let baseDamage = Math.max(1, monster.attack - target.defense);
            
            // åº”ç”¨ä¼¤å®³ç³»æ•°
            let finalDamage = Math.floor(baseDamage * monster.damageCoeff);
            finalDamage = Math.max(1, finalDamage);

            // è§’è‰²1çš„å‡ä¼¤
            if (target.id === 1 && target.damageReduction > 0) {
                finalDamage = Math.floor(finalDamage * (1 - target.damageReduction / 100));
                finalDamage = Math.max(1, finalDamage);
            }

            target.hp -= finalDamage;
            waveBattleState.totalDamageTaken += finalDamage;

            addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span class="log-damage-taken">ç¬¬${monster.wave}æ³¢æ€ªç‰© #${monster.id}</span> æ”»å‡» <span class="log-damage-taken">${target.name}</span>ï¼Œé€ æˆ ${finalDamage} ç‚¹ä¼¤å®³`);

            // æ˜¾ç¤ºæ€ªç‰©æ”»å‡»åŠ¨ç”»
            const monsterSprite = document.getElementById(`monster-sprite-${monster.id}`);
            if (monsterSprite) {
                monsterSprite.classList.remove('attacking');
                void monsterSprite.offsetWidth; // è§¦å‘é‡æ’
                monsterSprite.classList.add('attacking');
                setTimeout(() => {
                    monsterSprite.classList.remove('attacking');
                }, 500);
            }

            // æ˜¾ç¤ºè§’è‰²å—å‡»åŠ¨ç”»å’Œä¼¤å®³æ•°å­—
            const charSprite = document.getElementById(`char-sprite-${target.id}`);
            if (charSprite) {
                charSprite.classList.remove('hit');
                void charSprite.offsetWidth;
                charSprite.classList.add('hit');
                setTimeout(() => {
                    charSprite.classList.remove('hit');
                }, 300);
                
                // æ˜¾ç¤ºä¼¤å®³æ•°å­—
                showDamageNumber(charSprite, finalDamage, false);
            }

            if (target.hp <= 0) {
                target.hp = 0;
                target.isAlive = false;
                target.deathTime = waveBattleState.elapsedTime;
                addLog(`[${formatTime(waveBattleState.elapsedTime)}] <span style="color: #f44336; font-weight: bold;">${target.name} é˜µäº¡ï¼</span>`);
                
                // è§’è‰²æ­»äº¡åŠ¨ç”»
                if (charSprite) {
                    charSprite.classList.add('dead');
                }
            }
        }

        // è·å–è§’è‰²å¤´åƒemoji
        function getCharacterEmoji(jobId) {
            const jobEmojis = {
                1: 'ğŸ›¡ï¸', // å¦å…‹
                2: 'âš”ï¸', // æˆ˜å£«
                3: 'ğŸ¹', // å°„æ‰‹
                4: 'ğŸ’š'  // è¾…åŠ©
            };
            return jobEmojis[jobId] || 'ğŸ‘¤';
        }

        // è·å–æ€ªç‰©å¤´åƒemojiï¼ˆæ ¹æ®æ€ªç‰©IDå›ºå®šï¼‰
        function getMonsterEmoji(monsterId) {
            const monsterEmojis = ['ğŸ‘¹', 'ğŸ‘º', 'ğŸ‘½', 'ğŸ¤–', 'ğŸ‘¾', 'ğŸƒ', 'ğŸ¦¹', 'ğŸ¦´', 'ğŸ§Ÿ', 'ğŸ‘»', 'ğŸ’€', 'ğŸ§›'];
            const index = (monsterId - 1) % monsterEmojis.length;
            return monsterEmojis[index];
        }

        // æ›´æ–°æ³¢æ¬¡æˆ˜æ–—æ˜¾ç¤º
        function updateWaveBattleDisplay() {
            // æ›´æ–°å¯è§†åŒ–æˆ˜æ–—åœºæ™¯
            updateBattleScene();
            
            // æ›´æ–°è§’è‰²é¢æ¿ï¼ˆä½¿ç”¨waveCharactersPanelï¼‰
            const panel = document.getElementById('waveCharactersPanel');
            if (panel && waveBattleState.characters && waveBattleState.characters.length > 0) {
                panel.innerHTML = waveBattleState.characters.map(char => {
                    const hpPercent = char.maxHp > 0 ? (char.hp / char.maxHp * 100) : 0;
                    return `
                        <div class="char-panel-item ${char.isAlive ? '' : 'dead'}" data-char-id="${char.id}">
                            <div style="font-weight: 600; margin-bottom: 5px;">${char.name} [${JOB_NAMES[char.job]}]</div>
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">HP: ${char.hp.toFixed(0)} / ${char.maxHp.toFixed(0)} (${hpPercent.toFixed(1)}%)</div>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: ${hpPercent}%; background: ${char.isAlive ? '#51cf66' : '#f44336'};"></div>
                            </div>
                            <div style="font-size: 0.8em; color: #999; margin-top: 5px;">${char.isAlive ? 'å­˜æ´»' : 'é˜µäº¡'}</div>
                        </div>
                    `;
                }).join('');
            }

            // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡ï¼ˆä½¿ç”¨waveBattleStatsï¼‰
            const stats = document.getElementById('waveBattleStats');
            if (stats) {
                const aliveCount = waveBattleState.characters.filter(c => c.isAlive).length;
                const monsterCount = waveBattleState.monsters.filter(m => m.isAlive).length;
                stats.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">æˆ˜æ–—æ—¶é•¿</div>
                        <div class="stat-value">${formatTime(waveBattleState.elapsedTime)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">å­˜æ´»è§’è‰²</div>
                        <div class="stat-value">${aliveCount} / 5</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">å½“å‰æ€ªç‰©</div>
                        <div class="stat-value">${monsterCount}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">å‡»è´¥æ€ªç‰©</div>
                        <div class="stat-value">${waveBattleState.totalMonstersKilled}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">ä¼¤å®³è¾“å‡º</div>
                        <div class="stat-value">${waveBattleState.totalDamageDealt}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">å—åˆ°ä¼¤å®³</div>
                        <div class="stat-value">${waveBattleState.totalDamageTaken}</div>
                    </div>
                `;
            }
        }

        // æ›´æ–°å¯è§†åŒ–æˆ˜æ–—åœºæ™¯
        function updateBattleScene() {
            // æ›´æ–°æ³¢æ¬¡æŒ‡ç¤ºå™¨
            const waveIndicator = document.getElementById('waveIndicator');
            if (waveIndicator) {
                if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                    const stronghold = getStrongholdForWave(waveBattleState.currentWave);
                    waveIndicator.textContent = `æ®ç‚¹ ${stronghold} - ç¬¬ ${waveBattleState.currentWave} æ³¢`;
                    waveIndicator.style.display = 'block';
                } else {
                    waveIndicator.style.display = 'none';
                }
            }

            // æ›´æ–°è§’è‰²ä¾§ï¼ˆä½¿ç”¨waveCharactersSideï¼‰
            const charactersSide = document.getElementById('waveCharactersSide');
            if (charactersSide && waveBattleState.characters && waveBattleState.characters.length > 0) {
                charactersSide.innerHTML = waveBattleState.characters.map(char => {
                    const hpPercent = char.maxHp > 0 ? (char.hp / char.maxHp * 100) : 0;
                    const jobClass = char.job === 1 ? 'tank' : char.job === 2 ? 'warrior' : char.job === 3 ? 'archer' : 'support';
                    const emoji = getCharacterEmoji(char.job);
                    
                    return `
                        <div class="character-sprite ${char.isAlive ? '' : 'dead'}" 
                             id="char-sprite-${char.id}" 
                             data-char-id="${char.id}"
                             style="opacity: ${char.isAlive ? 1 : 0.5};">
                            <div class="character-avatar ${jobClass}">${emoji}</div>
                            <div class="character-info">
                                <div class="character-name">${char.name} [${JOB_NAMES[char.job]}]</div>
                                <div style="font-size: 0.85em; color: #666;">
                                    HP: ${char.hp.toFixed(0)} / ${char.maxHp.toFixed(0)}
                                </div>
                                <div class="character-hp-bar">
                                    <div class="character-hp-fill ${hpPercent < 30 ? 'low' : ''}" style="width: ${hpPercent}%;"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } else if (charactersSide && (!waveBattleState.characters || waveBattleState.characters.length === 0)) {
                charactersSide.innerHTML = '<div style="color: rgba(255,255,255,0.7); font-size: 1.2em; text-align: center; width: 100%; padding: 20px;">ç­‰å¾…è§’è‰²åˆå§‹åŒ–...</div>';
            }

            // æ›´æ–°æ€ªç‰©ä¾§ï¼ˆä½¿ç”¨waveMonstersSideï¼‰
            const monstersSide = document.getElementById('waveMonstersSide');
            if (monstersSide) {
                // åªæ˜¾ç¤ºå­˜æ´»çš„æ€ªç‰©
                const aliveMonsters = waveBattleState.monsters.filter(m => m.isAlive);
                if (aliveMonsters.length === 0) {
                    monstersSide.innerHTML = '<div style="color: rgba(255,255,255,0.7); font-size: 1.2em; text-align: center; width: 100%; padding: 20px;">æš‚æ— æ€ªç‰©</div>';
                } else {
                    monstersSide.innerHTML = aliveMonsters.map(monster => {
                        const hpNow = Math.max(0, Number(monster.hp) || 0);
                        const hpMax = Math.max(0, Number(monster.maxHp) || 0);
                        const hpPercent = hpMax > 0 ? Math.max(0, Math.min(100, (hpNow / hpMax * 100))) : 0;
                        const emoji = getMonsterEmoji(monster.id);
                        const spawnTag = (monster.spawnTimeSec !== undefined && monster.spawnTimeSec !== null) ? `${monster.spawnTimeSec}s` : '';
                        
                        // è®¡ç®—å¯æ”»å‡»å€’è®¡æ—¶
                        const delay = typeof monsterAttackDelay === 'number' ? monsterAttackDelay : 3;
                        let countdownHtml = '';
                        if (delay > 0 && monster.spawnGameTime !== undefined) {
                            const aliveTime = waveBattleState.elapsedTime - monster.spawnGameTime;
                            const remainingTime = Math.max(0, delay - aliveTime);
                            if (remainingTime > 0) {
                                const countdownText = remainingTime >= 1 ? remainingTime.toFixed(0) : remainingTime.toFixed(1);
                                countdownHtml = `<div class="monster-attack-countdown">${countdownText}s</div>`;
                            } else {
                                countdownHtml = `<div class="monster-attack-countdown ready">å¯æ”»å‡»</div>`;
                            }
                        }
                        
                        return `
                            <div class="monster-sprite ${monster.isAlive ? '' : 'dead'}" 
                                 id="monster-sprite-${monster.id}" 
                                 data-monster-id="${monster.id}">
                                ${spawnTag ? `<div class="monster-spawn-time-tag">${spawnTag}</div>` : ''}
                                ${countdownHtml}
                                <div class="monster-avatar">${emoji}</div>
                                <div class="monster-hp-bar">
                                    <div class="monster-hp-fill" style="width: ${hpPercent}%;"></div>
                                </div>
                                <div class="monster-hp-text">${hpNow.toFixed(0)} / ${hpMax.toFixed(0)}</div>
                                <div class="monster-id">#${monster.id}</div>
                                <div style="font-size: 0.7em; color: #666; margin-top: 2px;">W${monster.wave}</div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }

        // æ›´æ–°æ³¢æ¬¡ä¿¡æ¯æ˜¾ç¤º
        function updateWaveBattleInfo() {
            const currentWaveEl = document.getElementById('currentWaveNumber');
            const spawnedEl = document.getElementById('currentWaveSpawned');
            const totalEl = document.getElementById('currentWaveTotal');
            const aliveEl = document.getElementById('currentWaveAlive');

            if (currentWaveEl) {
                currentWaveEl.textContent = waveBattleState.currentWave > 0 ? waveBattleState.currentWave : '-';
            }
            if (spawnedEl) {
                spawnedEl.textContent = waveBattleState.waveSpawnedCount;
            }
            if (totalEl) {
                totalEl.textContent = waveBattleState.waveTotalCount;
            }
            if (aliveEl) {
                const aliveCount = waveBattleState.monsters.filter(m => m.wave === waveBattleState.currentWave && m.isAlive).length;
                aliveEl.textContent = aliveCount;
            }

            // æ›´æ–°æ®ç‚¹æ˜¾ç¤º
            const currentStrongholdEl = document.getElementById('currentStrongholdNumber');
            if (currentStrongholdEl) {
                currentStrongholdEl.textContent = waveBattleState.currentStronghold > 0 ? waveBattleState.currentStronghold : '-';
            }
            
            const status = document.getElementById('waveBattleStatus');
            if (status && waveBattleState.isRunning) {
                if (waveBattleState.currentWave > 0 && waveBattleState.currentWave <= 25) {
                    const stronghold = getStrongholdForWave(waveBattleState.currentWave);
                    status.textContent = `è¿›è¡Œä¸­ï¼šæ®ç‚¹ ${stronghold} - ç¬¬ ${waveBattleState.currentWave} æ³¢`;
                } else {
                    status.textContent = 'è¿›è¡Œä¸­';
                }
            }
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        // è·å–å“è´¨é¢œè‰²ï¼ˆç”¨äºæ–‡æœ¬æ˜¾ç¤ºï¼‰
        function getQualityTextColor(quality) {
            const qualityColors = {
                1: '#666',      // ç™½è‰²
                2: '#2b8a3e',   // ç»¿è‰²
                3: '#1864ab',   // è“è‰²
                4: '#5f3dc4',   // ç´«è‰²
                5: '#d9480f',   // æ©™è‰²
                6: '#c92a2a'    // çº¢è‰²
            };
            return qualityColors[quality] || qualityColors[1];
        }

        // è·å–å“è´¨èƒŒæ™¯é¢œè‰²ï¼ˆç”¨äºèƒŒæ™¯æ˜¾ç¤ºï¼‰
        function getQualityBgColor(quality) {
            const qualityColors = {
                1: { bg: '#f5f5f5', border: '#d0d0d0' },      // ç™½è‰²
                2: { bg: '#f0f9f4', border: '#51cf66' },       // ç»¿è‰²
                3: { bg: '#e7f5ff', border: '#339af0' },       // è“è‰²
                4: { bg: '#f3f0ff', border: '#845ef7' },       // ç´«è‰²
                5: { bg: '#fff4e6', border: '#ff922b' },       // æ©™è‰²
                6: { bg: '#ffe3e3', border: '#ff6b6b' }        // çº¢è‰²
            };
            return qualityColors[quality] || qualityColors[1];
        }

        // è·å–è§’è‰²è‹±é›„å“è´¨
        function getCharacterHeroQuality(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.selectedHeroId) return 1; // é»˜è®¤ç™½è‰²å“è´¨
            
            const hero = heroTable.find(h => String(h.id) === String(char.selectedHeroId));
            if (!hero) return 1;
            
            return parseInt(hero.quality) || 1;
        }

        // è·å–è£…å¤‡å“è´¨
        function getEquipmentQuality(equipmentId) {
            if (!equipmentId) return 1;
            const equipment = equipmentTable.find(eq => String(eq.id) === String(equipmentId));
            if (!equipment) return 1;
            return parseInt(equipment.quality) || 1;
        }

        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.innerHTML = text;
            msg.className = `message show ${type}`;
            setTimeout(() => {
                hideMessage();
            }, 3000);
        }

        // éšè—æ¶ˆæ¯
        function hideMessage() {
            document.getElementById('message').classList.remove('show');
        }

        // æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½
        window.switchTab = function(tabName) {
            // éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeçŠ¶æ€
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µ
            const targetTab = document.getElementById(`tab-${tabName}`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            
            // æ¿€æ´»å¯¹åº”çš„æŒ‰é’®
            const targetButton = document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }
            
            // å¦‚æœæ˜¯ä¸»é…ç½®æ ‡ç­¾é¡µï¼Œéœ€è¦å°†ä¸»é…ç½®å†…å®¹ç§»åˆ°æ ‡ç­¾é¡µå†…
            if (tabName === 'main') {
                const mainContent = document.getElementById('main-content');
                const mainTab = document.getElementById('tab-main');
                if (mainContent && mainTab && !mainTab.contains(mainContent)) {
                    mainTab.appendChild(mainContent);
                }
            }
            
            // å¦‚æœæ˜¯ç©å®¶ç»æµæ¨¡æ‹Ÿæ ‡ç­¾é¡µï¼Œåˆå§‹åŒ–æ•°æ®
            if (tabName === 'economy') {
                initEconomyTab();
            }
        };

        // ========== ç©å®¶ç»æµæ¨¡æ‹Ÿ ==========
        
        // ç©å®¶èµ„æºæ•°æ®
        let playerResources = {
            stamina: 100,              // æ¯æ—¥ä½“åŠ›ï¼ˆä¸‹ä¸€å¤©å¢åŠ ï¼‰
            currentStamina: 100,       // å½“å‰ä½“åŠ›
            gold: 0,                   // å½“å‰é‡‘å¸
            diamond: 0,                // å½“å‰é’»çŸ³
            currentDay: 1,             // å½“å‰å¤©æ•°ï¼Œé»˜è®¤ 1
            dailyGold: 0,              // æ¯æ—¥é‡‘å¸ï¼ˆä¸‹ä¸€å¤©å¢åŠ ï¼‰
            dailyDiamond: 0,           // æ¯æ—¥é’»çŸ³ï¼ˆä¸‹ä¸€å¤©å¢åŠ ï¼‰
            dailyRecruitTickets: 0     // æ¯æ—¥æ‹›å‹Ÿåˆ¸ï¼ˆä¸‹ä¸€å¤©å¢åŠ ï¼‰
        };
        
        // ç©å®¶ç©æ³•åˆ—è¡¨
        let gameplayList = [
            { id: 1, name: 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜', staminaCost: 10, mainDungeonConfig: { qualityWeights: { 1: 60, 2: 30, 3: 10 }, qualities: [1, 2, 3], goldDrop: { enabled: true, minGold: 40, maxGold: 60 } } }
        ];
        
        // èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨
        let resourceConsumptionGameplayList = [
            { id: 1, name: 'æ‹›å‹Ÿè§’è‰²', itemName: '', type: 'recruit' } // itemNameä¼šåœ¨ä½¿ç”¨æ—¶åŠ¨æ€è·å–
        ];
        
        // æ›´æ–°èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨ä¸­çš„itemName
        function updateResourceGameplayItemNames() {
            resourceConsumptionGameplayList.forEach(gameplay => {
                if (gameplay.type === 'recruit') {
                    gameplay.itemName = getRecruitTicketName();
                }
            });
        }
        
        // ç©å®¶è´¦å·ä¿¡æ¯
        let playerAccount = {
            level: 1,
            exp: 0,
            expRequired: 100
        };
        
        // èƒŒåŒ…ç‰©å“
        let bagItems = [];
        
        // ç©å®¶æ‹¥æœ‰çš„è‹±é›„åˆ—è¡¨ [{heroId: '11001', level: 1, copies: 0}, ...]
        let playerHeroes = [
            { heroId: '11001', level: 1, copies: 0 },
            { heroId: '11002', level: 1, copies: 0 },
            { heroId: '11003', level: 1, copies: 0 },
            { heroId: '11101', level: 1, copies: 0 },
            { heroId: '11102', level: 1, copies: 0 }
        ];
        
        // è‹±é›„å‡çº§é…ç½®ï¼š1~30çº§éœ€è¦çš„æœ¬ä½“æ•°é‡ [0, 1, 2, 3, 5, 7, 7, 9, 9, 12, 12, 12, 15, 15, 20, 20, 30, 30, 30, 40, 40, 40, 60, 60, 80, 80, 100, 100, 100, 120]
        let heroUpgradeConfig = [0, 1, 2, 3, 5, 7, 7, 9, 9, 12, 12, 12, 15, 15, 20, 20, 30, 30, 30, 40, 40, 40, 60, 60, 80, 80, 100, 100, 100, 120];
        const HERO_UPGRADE_CONFIG_STORAGE_KEY = 'battleSimulatorHeroUpgradeConfig';
        
        // ç»æµæ–¹æ¡ˆç®¡ç†
        const ECONOMY_SCHEMES_STORAGE_KEY = 'battleSimulatorEconomySchemes';
        const MAX_ECONOMY_SCHEMES = 10;
        let currentEconomySchemeId = null;
        
        // ç©å®¶æ‹¥æœ‰çš„è£…å¤‡IDåˆ—è¡¨
        let playerEquipment = [];
        
        // ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜ä¸Šæ¬¡è·å¾—çš„èµ„æº
        let lastMainDungeonGains = {
            exp: 0,
            levelUp: false,
            equipment: [],
            resources: [], // [{resourceId, name, count}, ...]
            gold: 0 // é‡‘å¸æ‰è½
        };
        
        // åˆå§‹åŒ–ç©å®¶ç»æµæ¨¡æ‹Ÿæ ‡ç­¾é¡µ
        function initEconomyTab() {
            loadPlayerEconomyData();
            // åŠ è½½å·²ä¿å­˜çš„è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨ï¼ˆå¦‚æœè¿˜æ²¡åŠ è½½ï¼‰
            if (!equipSlotLevelTable || equipSlotLevelTable.length === 0) {
                loadSavedEquipSlotLevelTable();
            }
            updateEconomySchemeSelect();
            renderGameplayList();
            updateResourceGameplayItemNames();
            renderResourceGameplayList();
            renderBagItems();
            updateHeroSelects();
            renderPlayerHeroes();
            updateEquipmentSelect();
            renderPlayerOwnedEquipment();
            renderHeroUpgradeConfig();
            updateResourceSelect();
            updateResourceLabels();
        }
        
        // è‹±é›„å‡çº§é…ç½®æ•°å€¼åŒºåŸŸå±•å¼€/æ”¶èµ·
        let heroUpgradeConfigValuesExpanded = false;
        
        window.toggleHeroUpgradeConfigValues = function() {
            heroUpgradeConfigValuesExpanded = !heroUpgradeConfigValuesExpanded;
            const area = document.getElementById('heroUpgradeConfigValuesArea');
            const btn = document.getElementById('heroUpgradeConfigToggleBtn');
            if (area) area.style.display = heroUpgradeConfigValuesExpanded ? 'block' : 'none';
            if (btn) btn.textContent = heroUpgradeConfigValuesExpanded ? 'æ”¶èµ·æ•°å€¼' : 'å±•å¼€æ•°å€¼';
        };
        
        // æ¸²æŸ“è‹±é›„å‡çº§é…ç½®UI
        function renderHeroUpgradeConfig() {
            const gridEl = document.getElementById('heroUpgradeConfigGrid');
            if (!gridEl) return;
            
            gridEl.innerHTML = Array.from({ length: 30 }, (_, i) => {
                const level = i + 1;
                const copies = heroUpgradeConfig[i] || 0;
                return `
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <label style="font-size: 0.85em; color: #666; font-weight: 600;">${level}çº§</label>
                        <input type="number" id="heroUpgradeLevel${level}" value="${copies}" min="0" 
                            onchange="updateHeroUpgradeConfig(${level}, this.value)" 
                            style="padding: 6px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em; width: 100%;" />
                    </div>
                `;
            }).join('');
        }
        
        // åŠ è½½ç©å®¶ç»æµæ•°æ®
        function loadPlayerEconomyData() {
            try {
                const saved = localStorage.getItem('playerEconomyData');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.resources) {
                        Object.assign(playerResources, data.resources);
                        if (playerResources.currentDay == null) playerResources.currentDay = 1;
                        if (playerResources.dailyGold == null) playerResources.dailyGold = 0;
                        if (playerResources.dailyDiamond == null) playerResources.dailyDiamond = 0;
                        if (playerResources.dailyRecruitTickets == null) playerResources.dailyRecruitTickets = 0;
                    }
                    if (data.gameplayList) {
                        gameplayList = data.gameplayList;
                        // ç¡®ä¿ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜æœ‰å“è´¨æƒé‡é…ç½®å’Œé‡‘å¸æ‰è½é…ç½®
                        const mainDungeon = gameplayList.find(g => g.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜');
                        if (mainDungeon) {
                            if (!mainDungeon.mainDungeonConfig) {
                                mainDungeon.mainDungeonConfig = { qualityWeights: { 1: 60, 2: 30, 3: 10 }, qualities: [1, 2, 3] };
                            }
                            // ç¡®ä¿æœ‰é‡‘å¸æ‰è½é…ç½®ï¼ˆé»˜è®¤å¯ç”¨ï¼Œ40-60é‡‘å¸ï¼‰
                            if (!mainDungeon.mainDungeonConfig.goldDrop) {
                                mainDungeon.mainDungeonConfig.goldDrop = { enabled: true, minGold: 40, maxGold: 60 };
                            }
                        }
                    }
                    if (data.account) Object.assign(playerAccount, data.account);
                    if (data.bagItems) {
                        bagItems = data.bagItems;
                        cleanupCoreResourcesFromBag(); // æ¸…ç†æ ¸å¿ƒèµ„æº
                    }
                    if (data.playerHeroes && data.playerHeroes.length > 0) {
                        playerHeroes = data.playerHeroes;
                    }
                    if (data.playerEquipment) {
                        // ç¡®ä¿æ‰€æœ‰è£…å¤‡IDéƒ½æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œé¿å…ç±»å‹ä¸åŒ¹é…
                        playerEquipment = data.playerEquipment.map(id => String(id));
                    }
                    if (data.resourceConsumptionGameplayList) {
                        resourceConsumptionGameplayList = data.resourceConsumptionGameplayList;
                    }
                    if (data.recruitBoxLevel != null) recruitBoxLevel = data.recruitBoxLevel;
                    if (data.recruitCount != null) recruitCount = data.recruitCount;
                    if (data.equipSlotLevels) {
                        equipSlotLevels = data.equipSlotLevels;
                        // ç¡®ä¿ç»“æ„å®Œæ•´
                        for (let jobId = 1; jobId <= 4; jobId++) {
                            if (!equipSlotLevels[jobId]) equipSlotLevels[jobId] = {};
                            const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                            typeNames.forEach(typeName => {
                                if (equipSlotLevels[jobId][typeName] == null) equipSlotLevels[jobId][typeName] = 0;
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('åŠ è½½ç©å®¶ç»æµæ•°æ®å¤±è´¥:', error);
            }
            
            // å¦‚æœç©å®¶è‹±é›„åˆ—è¡¨ä¸ºç©ºï¼Œè®¾ç½®é»˜è®¤è‹±é›„
            if (playerHeroes.length === 0) {
                playerHeroes = [
                    { heroId: '11001', level: 1, copies: 0 },
                    { heroId: '11002', level: 1, copies: 0 },
                    { heroId: '11003', level: 1, copies: 0 },
                    { heroId: '11101', level: 1, copies: 0 },
                    { heroId: '11102', level: 1, copies: 0 }
                ];
                savePlayerEconomyData();
            }
            
            // è¿ç§»æ—§æ•°æ®ï¼šå¦‚æœæ²¡æœ‰ copies å­—æ®µï¼Œæ·»åŠ é»˜è®¤å€¼ 0
            playerHeroes.forEach(h => {
                if (h.copies == null) h.copies = 0;
            });
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•ï¼Œå¦‚æœæ²¡æœ‰ä¸”å·²åŠ è½½å¼ºåŒ–è¡¨ï¼Œåˆ™æ·»åŠ 
            const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
            if (!hasEquipSlotEnhance && equipSlotLevelTable && equipSlotLevelTable.length > 0) {
                const maxId = resourceConsumptionGameplayList.length > 0 
                    ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                    : 0;
                resourceConsumptionGameplayList.push({
                    id: maxId + 1,
                    name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                    itemName: '',
                    type: 'equipSlotEnhance'
                });
                savePlayerEconomyData();
            }
            
            // åŠ è½½è‹±é›„å‡çº§é…ç½®
            loadHeroUpgradeConfig();
        }
        
        // åŠ è½½è‹±é›„å‡çº§é…ç½®
        function loadHeroUpgradeConfig() {
            try {
                const saved = localStorage.getItem(HERO_UPGRADE_CONFIG_STORAGE_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    if (Array.isArray(config) && config.length >= 30) {
                        heroUpgradeConfig = config;
                    }
                }
            } catch (err) {
                console.error('åŠ è½½è‹±é›„å‡çº§é…ç½®å¤±è´¥:', err);
            }
        }
        
        // ä¿å­˜è‹±é›„å‡çº§é…ç½®
        function saveHeroUpgradeConfig() {
            try {
                localStorage.setItem(HERO_UPGRADE_CONFIG_STORAGE_KEY, JSON.stringify(heroUpgradeConfig));
                showMessage('è‹±é›„å‡çº§é…ç½®å·²ä¿å­˜', 'success');
            } catch (err) {
                console.error('ä¿å­˜è‹±é›„å‡çº§é…ç½®å¤±è´¥:', err);
                showMessage('ä¿å­˜é…ç½®å¤±è´¥', 'error');
            }
        }
        
        // æ›´æ–°è‹±é›„å‡çº§é…ç½®
        window.updateHeroUpgradeConfig = function(level, value) {
            if (level < 1 || level > 30) return;
            const copies = Math.max(0, parseInt(value) || 0);
            heroUpgradeConfig[level - 1] = copies;
        }
        
        // æ¢å¤é»˜è®¤è‹±é›„å‡çº§é…ç½®
        window.resetHeroUpgradeConfig = function() {
            if (!confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤é…ç½®å—ï¼Ÿ')) return;
            heroUpgradeConfig = [0, 1, 2, 3, 5, 7, 7, 9, 9, 12, 12, 12, 15, 15, 20, 20, 30, 30, 30, 40, 40, 40, 60, 60, 80, 80, 100, 100, 100, 120];
            // æ›´æ–°æ‰€æœ‰è¾“å…¥æ¡†
            for (let i = 1; i <= 30; i++) {
                const input = document.getElementById(`heroUpgradeLevel${i}`);
                if (input) input.value = heroUpgradeConfig[i - 1];
            }
            saveHeroUpgradeConfig();
            renderPlayerHeroes(); // åˆ·æ–°è‹±é›„æ˜¾ç¤º
        }
        
        // è·å–å‡çº§åˆ°æŒ‡å®šç­‰çº§éœ€è¦çš„æœ¬ä½“æ•°é‡
        function getCopiesNeededForLevel(targetLevel) {
            if (targetLevel < 1 || targetLevel > 30) return 0;
            return heroUpgradeConfig[targetLevel - 1] || 0;
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡çº§è‹±é›„
        function canUpgradeHero(heroData) {
            const currentLevel = heroData.level || 1;
            if (currentLevel >= 30) return false;
            const copiesNeeded = getCopiesNeededForLevel(currentLevel + 1);
            const copies = heroData.copies || 0;
            return copies >= copiesNeeded;
        }
        
        // å‡çº§è‹±é›„
        window.upgradePlayerHero = function(heroId) {
            const heroData = playerHeroes.find(h => String(h.heroId) === String(heroId));
            if (!heroData) {
                showMessage('æœªæ‰¾åˆ°è¯¥è‹±é›„', 'error');
                return;
            }
            
            const currentLevel = heroData.level || 1;
            if (currentLevel >= 30) {
                showMessage('è‹±é›„å·²è¾¾åˆ°æœ€é«˜ç­‰çº§', 'error');
                return;
            }
            
            const nextLevel = currentLevel + 1;
            const copiesNeeded = getCopiesNeededForLevel(nextLevel);
            const copies = heroData.copies || 0;
            
            if (copies < copiesNeeded) {
                showMessage(`å‡çº§éœ€è¦ ${copiesNeeded} ä¸ªæœ¬ä½“ï¼Œå½“å‰åªæœ‰ ${copies} ä¸ª`, 'error');
                return;
            }
            
            heroData.level = nextLevel;
            heroData.copies -= copiesNeeded;
            renderPlayerHeroes();
            savePlayerEconomyData();
            
            const hero = heroTable.find(h => String(h.id) === String(heroId));
            const heroName = hero ? hero.namecn : heroId;
            showMessage(`${heroName} å‡çº§åˆ° ${nextLevel} çº§ï¼`, 'success');
        }
        
        // åŠ è½½ç©å®¶ç»æµæ•°æ®
        function loadPlayerEconomyData() {
            try {
                const saved = localStorage.getItem('playerEconomyData');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.resources) {
                        Object.assign(playerResources, data.resources);
                        if (playerResources.currentDay == null) playerResources.currentDay = 1;
                        if (playerResources.dailyGold == null) playerResources.dailyGold = 0;
                        if (playerResources.dailyDiamond == null) playerResources.dailyDiamond = 0;
                        if (playerResources.dailyRecruitTickets == null) playerResources.dailyRecruitTickets = 0;
                    }
                    if (data.gameplayList) {
                        gameplayList = data.gameplayList;
                        // ç¡®ä¿ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜æœ‰å“è´¨æƒé‡é…ç½®å’Œé‡‘å¸æ‰è½é…ç½®
                        const mainDungeon = gameplayList.find(g => g.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜');
                        if (mainDungeon) {
                            if (!mainDungeon.mainDungeonConfig) {
                                mainDungeon.mainDungeonConfig = { qualityWeights: { 1: 60, 2: 30, 3: 10 }, qualities: [1, 2, 3] };
                            }
                            // ç¡®ä¿æœ‰é‡‘å¸æ‰è½é…ç½®ï¼ˆé»˜è®¤å¯ç”¨ï¼Œ40-60é‡‘å¸ï¼‰
                            if (!mainDungeon.mainDungeonConfig.goldDrop) {
                                mainDungeon.mainDungeonConfig.goldDrop = { enabled: true, minGold: 40, maxGold: 60 };
                            }
                        }
                    }
                    if (data.account) Object.assign(playerAccount, data.account);
                    if (data.bagItems) {
                        bagItems = data.bagItems;
                        cleanupCoreResourcesFromBag(); // æ¸…ç†æ ¸å¿ƒèµ„æº
                    }
                    if (data.playerHeroes && data.playerHeroes.length > 0) {
                        playerHeroes = data.playerHeroes;
                    }
                    if (data.playerEquipment) {
                        // ç¡®ä¿æ‰€æœ‰è£…å¤‡IDéƒ½æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œé¿å…ç±»å‹ä¸åŒ¹é…
                        playerEquipment = data.playerEquipment.map(id => String(id));
                    }
                    if (data.resourceConsumptionGameplayList) {
                        resourceConsumptionGameplayList = data.resourceConsumptionGameplayList;
                    }
                    if (data.recruitBoxLevel != null) recruitBoxLevel = data.recruitBoxLevel;
                    if (data.recruitCount != null) recruitCount = data.recruitCount;
                    if (data.equipSlotLevels) {
                        equipSlotLevels = data.equipSlotLevels;
                        // ç¡®ä¿ç»“æ„å®Œæ•´
                        for (let jobId = 1; jobId <= 4; jobId++) {
                            if (!equipSlotLevels[jobId]) equipSlotLevels[jobId] = {};
                            const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                            typeNames.forEach(typeName => {
                                if (equipSlotLevels[jobId][typeName] == null) equipSlotLevels[jobId][typeName] = 0;
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('åŠ è½½ç©å®¶ç»æµæ•°æ®å¤±è´¥:', error);
            }
            
            // å¦‚æœç©å®¶è‹±é›„åˆ—è¡¨ä¸ºç©ºï¼Œè®¾ç½®é»˜è®¤è‹±é›„
            if (playerHeroes.length === 0) {
                playerHeroes = [
                    { heroId: '11001', level: 1, copies: 0 },
                    { heroId: '11002', level: 1, copies: 0 },
                    { heroId: '11003', level: 1, copies: 0 },
                    { heroId: '11101', level: 1, copies: 0 },
                    { heroId: '11102', level: 1, copies: 0 }
                ];
                savePlayerEconomyData();
            }
            
            // è¿ç§»æ—§æ•°æ®ï¼šå¦‚æœæ²¡æœ‰ copies å­—æ®µï¼Œæ·»åŠ é»˜è®¤å€¼ 0
            playerHeroes.forEach(h => {
                if (h.copies == null) h.copies = 0;
            });
            
            // å¦‚æœèµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨ä¸ºç©ºï¼Œè®¾ç½®é»˜è®¤æ‹›å‹Ÿè§’è‰²ç©æ³•
            if (resourceConsumptionGameplayList.length === 0) {
                resourceConsumptionGameplayList = [
                    { id: 1, name: 'æ‹›å‹Ÿè§’è‰²', itemName: 'æ‹›å‹Ÿåˆ¸', type: 'recruit' }
                ];
                savePlayerEconomyData();
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•ï¼Œå¦‚æœæ²¡æœ‰ä¸”å·²åŠ è½½å¼ºåŒ–è¡¨ï¼Œåˆ™æ·»åŠ 
            const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
            if (!hasEquipSlotEnhance && equipSlotLevelTable && equipSlotLevelTable.length > 0) {
                const maxId = resourceConsumptionGameplayList.length > 0 
                    ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                    : 0;
                resourceConsumptionGameplayList.push({
                    id: maxId + 1,
                    name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                    itemName: '',
                    type: 'equipSlotEnhance'
                });
                savePlayerEconomyData();
            }
            
            // åŠ è½½è‹±é›„å‡çº§é…ç½®
            loadHeroUpgradeConfig();
            
            // æ›´æ–°ç•Œé¢
            const staminaInput = document.getElementById('playerStamina');
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            const goldInput = document.getElementById('playerGold');
            const diamondInput = document.getElementById('playerDiamond');
            const levelInput = document.getElementById('playerLevel');
            const expInput = document.getElementById('playerExp');
            const expRequiredInput = document.getElementById('playerExpRequired');
            const dailyGoldInput = document.getElementById('playerDailyGold');
            const dailyDiamondInput = document.getElementById('playerDailyDiamond');
            const dailyRecruitInput = document.getElementById('playerDailyRecruitTickets');
            const currentDayEl = document.getElementById('playerCurrentDay');
            
            const level = playerAccount.level != null ? playerAccount.level : 1;
            const tblExp = getExpRequiredForLevel(level + 1);
            if (tblExp != null) playerAccount.expRequired = tblExp;
            if (staminaInput) staminaInput.value = playerResources.stamina;
            if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina;
            if (goldInput) goldInput.value = playerResources.gold;
            if (diamondInput) diamondInput.value = playerResources.diamond;
            if (levelInput) levelInput.value = playerAccount.level;
            if (expInput) expInput.value = playerAccount.exp;
            if (expRequiredInput) expRequiredInput.value = playerAccount.expRequired != null ? playerAccount.expRequired : 100;
            if (dailyGoldInput) dailyGoldInput.value = playerResources.dailyGold != null ? playerResources.dailyGold : 0;
            if (dailyDiamondInput) dailyDiamondInput.value = playerResources.dailyDiamond != null ? playerResources.dailyDiamond : 0;
            if (dailyRecruitInput) dailyRecruitInput.value = playerResources.dailyRecruitTickets != null ? playerResources.dailyRecruitTickets : 0;
            if (currentDayEl) currentDayEl.textContent = playerResources.currentDay != null ? playerResources.currentDay : 1;
        }
        
        // ä¿å­˜ç©å®¶ç»æµæ•°æ®
        function savePlayerEconomyData() {
            try {
                const data = {
                    resources: playerResources,
                    gameplayList: gameplayList,
                    account: playerAccount,
                    bagItems: bagItems,
                    playerHeroes: playerHeroes,
                    playerEquipment: playerEquipment,
                    resourceConsumptionGameplayList: resourceConsumptionGameplayList,
                    recruitBoxLevel: recruitBoxLevel,
                    recruitCount: recruitCount,
                    equipSlotLevels: equipSlotLevels
                };
                localStorage.setItem('playerEconomyData', JSON.stringify(data));
            } catch (error) {
                console.error('ä¿å­˜ç©å®¶ç»æµæ•°æ®å¤±è´¥:', error);
            }
        }
        
        // ---------- ç»æµæ–¹æ¡ˆç®¡ç† ----------
        function loadEconomySchemes() {
            try {
                const raw = localStorage.getItem(ECONOMY_SCHEMES_STORAGE_KEY);
                if (!raw) return [];
                const list = JSON.parse(raw);
                return Array.isArray(list) ? list : [];
            } catch (e) {
                return [];
            }
        }
        
        function updateEconomySchemeSelect() {
            const selectEl = document.getElementById('economySchemeSelect');
            const statusEl = document.getElementById('economySchemeStatus');
            if (!selectEl) return;
            const schemes = loadEconomySchemes();
            const current = currentEconomySchemeId || (selectEl.value || '');
            selectEl.innerHTML = '<option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>';
            schemes.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.id;
                opt.textContent = s.name;
                if (s.id === current) opt.selected = true;
                selectEl.appendChild(opt);
            });
            if (statusEl) {
                statusEl.textContent = schemes.length
                    ? `å·²ä¿å­˜ ${schemes.length} ä¸ªæ–¹æ¡ˆï¼ˆæœ€å¤š ${MAX_ECONOMY_SCHEMES} ä¸ªï¼‰`
                    : 'æš‚æ— ä¿å­˜çš„æ–¹æ¡ˆ';
            }
        }
        
        window.saveEconomyScheme = function() {
            const nameInput = document.getElementById('economySchemeNameInput');
            const name = (nameInput && nameInput.value || '').trim();
            if (!name) {
                showMessage('è¯·è¾“å…¥æ–¹æ¡ˆåç§°', 'error');
                return;
            }
            const schemes = loadEconomySchemes();
            const snapshot = {
                resources: JSON.parse(JSON.stringify(playerResources)),
                gameplayList: JSON.parse(JSON.stringify(gameplayList)),
                account: JSON.parse(JSON.stringify(playerAccount)),
                bagItems: JSON.parse(JSON.stringify(bagItems)),
                playerHeroes: JSON.parse(JSON.stringify(playerHeroes)),
                playerEquipment: JSON.parse(JSON.stringify(playerEquipment)),
                resourceConsumptionGameplayList: JSON.parse(JSON.stringify(resourceConsumptionGameplayList)),
                recruitBoxLevel: recruitBoxLevel,
                recruitCount: recruitCount,
                heroUpgradeConfig: JSON.parse(JSON.stringify(heroUpgradeConfig)),
                equipSlotLevels: JSON.parse(JSON.stringify(equipSlotLevels))
            };
            const id = 'eco_' + Date.now();
            let list = schemes.filter(s => s.id !== currentEconomySchemeId);
            if (currentEconomySchemeId) {
                const idx = schemes.findIndex(s => s.id === currentEconomySchemeId);
                if (idx >= 0) {
                    const cur = { ...schemes[idx], name, ...snapshot };
                    list = schemes.slice();
                    list[idx] = cur;
                    currentEconomySchemeId = cur.id;
                    localStorage.setItem(ECONOMY_SCHEMES_STORAGE_KEY, JSON.stringify(list));
                    updateEconomySchemeSelect();
                    // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨è¯¥æ–¹æ¡ˆï¼Œåˆ·æ–°ä¸»é…ç½®æ•°æ®
                    refreshMainConfigFromEconomyScheme();
                    if (nameInput) nameInput.value = name;
                    showMessage(`æ–¹æ¡ˆ"${name}"å·²æ›´æ–°`, 'success');
                    return;
                }
            }
            if (list.length >= MAX_ECONOMY_SCHEMES) {
                showMessage(`æœ€å¤šä¿å­˜ ${MAX_ECONOMY_SCHEMES} ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆåˆ é™¤å†ä¿å­˜`, 'error');
                return;
            }
            const neu = { id, name, ...snapshot };
            list.push(neu);
            currentEconomySchemeId = id;
            localStorage.setItem(ECONOMY_SCHEMES_STORAGE_KEY, JSON.stringify(list));
            updateEconomySchemeSelect();
            // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨è¯¥æ–¹æ¡ˆï¼Œåˆ·æ–°ä¸»é…ç½®æ•°æ®
            refreshMainConfigFromEconomyScheme();
            if (nameInput) nameInput.value = name;
            showMessage(`æ–¹æ¡ˆ"${name}"å·²ä¿å­˜`, 'success');
        };
        
        window.loadEconomySchemeById = function() {
            const selectEl = document.getElementById('economySchemeSelect');
            const id = selectEl && selectEl.value;
            if (!id) {
                showMessage('è¯·å…ˆé€‰æ‹©è¦åŠ è½½çš„æ–¹æ¡ˆ', 'error');
                return;
            }
            const schemes = loadEconomySchemes();
            const s = schemes.find(x => x.id === id);
            if (!s) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            if (s.resources) Object.assign(playerResources, s.resources);
            if (s.account) Object.assign(playerAccount, s.account);
            if (Array.isArray(s.bagItems)) {
                bagItems = s.bagItems;
                cleanupCoreResourcesFromBag(); // æ¸…ç†æ ¸å¿ƒèµ„æº
            }
            if (Array.isArray(s.playerHeroes)) playerHeroes = s.playerHeroes;
            if (Array.isArray(s.playerEquipment)) playerEquipment = s.playerEquipment.map(x => String(x));
            if (Array.isArray(s.gameplayList)) gameplayList = s.gameplayList;
            if (Array.isArray(s.resourceConsumptionGameplayList)) resourceConsumptionGameplayList = s.resourceConsumptionGameplayList;
            if (s.recruitBoxLevel != null) recruitBoxLevel = s.recruitBoxLevel;
            if (s.recruitCount != null) recruitCount = s.recruitCount;
            if (Array.isArray(s.heroUpgradeConfig) && s.heroUpgradeConfig.length >= 30) {
                heroUpgradeConfig = s.heroUpgradeConfig;
            }
            // åŠ è½½è£…å¤‡å¼ºåŒ–æ•°æ®
            if (s.equipSlotLevels) {
                equipSlotLevels = JSON.parse(JSON.stringify(s.equipSlotLevels));
                // ç¡®ä¿ç»“æ„å®Œæ•´
                for (let jobId = 1; jobId <= 4; jobId++) {
                    if (!equipSlotLevels[jobId]) equipSlotLevels[jobId] = {};
                    const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                    typeNames.forEach(typeName => {
                        if (equipSlotLevels[jobId][typeName] == null) equipSlotLevels[jobId][typeName] = 0;
                    });
                }
            } else {
                // å¦‚æœæ–¹æ¡ˆä¸­æ²¡æœ‰å¼ºåŒ–æ•°æ®ï¼Œåˆå§‹åŒ–ä¸ºé»˜è®¤å€¼
                equipSlotLevels = {
                    1: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    2: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    3: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    4: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 }
                };
            }
            currentEconomySchemeId = id;
            savePlayerEconomyData();
            if (Array.isArray(heroUpgradeConfig)) {
                try {
                    localStorage.setItem(HERO_UPGRADE_CONFIG_STORAGE_KEY, JSON.stringify(heroUpgradeConfig));
                } catch (err) {}
            }
            // åˆ·æ–°ç•Œé¢
            const staminaInput = document.getElementById('playerStamina');
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            const goldInput = document.getElementById('playerGold');
            const diamondInput = document.getElementById('playerDiamond');
            const levelInput = document.getElementById('playerLevel');
            const expInput = document.getElementById('playerExp');
            const expRequiredInput = document.getElementById('playerExpRequired');
            const dailyGoldInput = document.getElementById('playerDailyGold');
            const dailyDiamondInput = document.getElementById('playerDailyDiamond');
            const dailyRecruitInput = document.getElementById('playerDailyRecruitTickets');
            const currentDayEl = document.getElementById('playerCurrentDay');
            const nameInput = document.getElementById('economySchemeNameInput');
            if (staminaInput) staminaInput.value = playerResources.stamina != null ? playerResources.stamina : 100;
            if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina != null ? playerResources.currentStamina : 0;
            if (goldInput) goldInput.value = playerResources.gold != null ? playerResources.gold : 0;
            if (diamondInput) diamondInput.value = playerResources.diamond != null ? playerResources.diamond : 0;
            const accLevel = playerAccount.level != null ? playerAccount.level : 1;
            const accTbl = getExpRequiredForLevel(accLevel + 1);
            if (accTbl != null) playerAccount.expRequired = accTbl;
            if (levelInput) levelInput.value = playerAccount.level != null ? playerAccount.level : 1;
            if (expInput) expInput.value = playerAccount.exp != null ? playerAccount.exp : 0;
            if (expRequiredInput) expRequiredInput.value = playerAccount.expRequired != null ? playerAccount.expRequired : 100;
            if (dailyGoldInput) dailyGoldInput.value = playerResources.dailyGold != null ? playerResources.dailyGold : 0;
            if (dailyDiamondInput) dailyDiamondInput.value = playerResources.dailyDiamond != null ? playerResources.dailyDiamond : 0;
            if (dailyRecruitInput) dailyRecruitInput.value = playerResources.dailyRecruitTickets != null ? playerResources.dailyRecruitTickets : 0;
            if (currentDayEl) currentDayEl.textContent = playerResources.currentDay != null ? playerResources.currentDay : 1;
            if (nameInput) nameInput.value = s.name || '';
            // æ£€æŸ¥å¹¶æ·»åŠ è£…å¤‡å¼ºåŒ–ç©æ³•ï¼ˆå¦‚æœequipSlotLevelTableå·²åŠ è½½ä½†ç©æ³•ä¸å­˜åœ¨ï¼‰
            if (equipSlotLevelTable && equipSlotLevelTable.length > 0) {
                const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
                if (!hasEquipSlotEnhance) {
                    const maxId = resourceConsumptionGameplayList.length > 0 
                        ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                        : 0;
                    resourceConsumptionGameplayList.push({
                        id: maxId + 1,
                        name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                        type: 'equipSlotEnhance'
                    });
                    savePlayerEconomyData();
                }
            }
            
            renderBagItems();
            renderPlayerHeroes();
            renderGameplayList();
            renderResourceGameplayList();
            renderPlayerOwnedEquipment();
            renderHeroUpgradeConfig();
            updateEconomySchemeSelect();
            // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨è¯¥æ–¹æ¡ˆï¼Œåˆ·æ–°ä¸»é…ç½®æ•°æ®
            refreshMainConfigFromEconomyScheme();
            showMessage(`å·²åŠ è½½æ–¹æ¡ˆ"${s.name}"`, 'success');
        };
        
        window.deleteEconomyScheme = function() {
            const selectEl = document.getElementById('economySchemeSelect');
            const id = selectEl && selectEl.value;
            if (!id) {
                showMessage('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–¹æ¡ˆ', 'error');
                return;
            }
            const schemes = loadEconomySchemes();
            const s = schemes.find(x => x.id === id);
            if (!s) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            if (!confirm(`ç¡®å®šåˆ é™¤æ–¹æ¡ˆ"${s.name}"å—ï¼Ÿ`)) return;
            const list = schemes.filter(x => x.id !== id);
            localStorage.setItem(ECONOMY_SCHEMES_STORAGE_KEY, JSON.stringify(list));
            if (currentEconomySchemeId === id) currentEconomySchemeId = null;
            // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨è¢«åˆ é™¤çš„æ–¹æ¡ˆï¼Œæ¸…ç©ºä¸»é…ç½®çš„å…³è”å¹¶åˆ·æ–°
            if (mainConfigEconomySchemeId === id) {
                mainConfigEconomySchemeId = null;
                useEconomySimulation = false;
                syncMainConfigEconomyUI();
                refreshMainConfigFromEconomyScheme();
            }
            const nameInput = document.getElementById('economySchemeNameInput');
            if (nameInput) nameInput.value = '';
            updateEconomySchemeSelect();
            updateMainConfigEconomySchemeSelect(); // æ›´æ–°ä¸»é…ç½®çš„ä¸‹æ‹‰æ¡†
            showMessage(`æ–¹æ¡ˆ"${s.name}"å·²åˆ é™¤`, 'success');
        };
        
        window.copyEconomyScheme = function() {
            const selectEl = document.getElementById('economySchemeSelect');
            const id = selectEl && selectEl.value;
            if (!id) {
                showMessage('è¯·å…ˆé€‰æ‹©è¦å¤åˆ¶çš„æ–¹æ¡ˆ', 'error');
                return;
            }
            const schemes = loadEconomySchemes();
            const s = schemes.find(x => x.id === id);
            if (!s) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }
            if (schemes.length >= MAX_ECONOMY_SCHEMES) {
                showMessage(`æœ€å¤šä¿å­˜ ${MAX_ECONOMY_SCHEMES} ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆåˆ é™¤å†å¤åˆ¶`, 'error');
                return;
            }
            let copyName = (s.name || 'æœªå‘½å') + ' - å‰¯æœ¬';
            let n = 1;
            while (schemes.some(x => x.name === copyName)) {
                copyName = (s.name || 'æœªå‘½å') + ' - å‰¯æœ¬' + (++n);
            }
            const copy = {
                id: 'eco_' + Date.now(),
                name: copyName,
                resources: JSON.parse(JSON.stringify(s.resources || {})),
                gameplayList: JSON.parse(JSON.stringify(s.gameplayList || [])),
                account: JSON.parse(JSON.stringify(s.account || {})),
                bagItems: JSON.parse(JSON.stringify(s.bagItems || [])),
                playerHeroes: JSON.parse(JSON.stringify(s.playerHeroes || [])),
                playerEquipment: (s.playerEquipment || []).map(x => String(x)),
                resourceConsumptionGameplayList: JSON.parse(JSON.stringify(s.resourceConsumptionGameplayList || [])),
                recruitBoxLevel: s.recruitBoxLevel != null ? s.recruitBoxLevel : 1,
                recruitCount: s.recruitCount != null ? s.recruitCount : 0,
                heroUpgradeConfig: Array.isArray(s.heroUpgradeConfig) ? JSON.parse(JSON.stringify(s.heroUpgradeConfig)) : [],
                equipSlotLevels: s.equipSlotLevels ? JSON.parse(JSON.stringify(s.equipSlotLevels)) : {
                    1: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    2: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    3: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                    4: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 }
                }
            };
            schemes.push(copy);
            localStorage.setItem(ECONOMY_SCHEMES_STORAGE_KEY, JSON.stringify(schemes));
            currentEconomySchemeId = copy.id;
            updateEconomySchemeSelect();
            // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨è¢«å¤åˆ¶çš„æ–¹æ¡ˆï¼Œåˆ·æ–°ä¸»é…ç½®æ•°æ®ï¼ˆè™½ç„¶å¤åˆ¶çš„æ˜¯æ–°æ–¹æ¡ˆï¼Œä½†åŸæ–¹æ¡ˆæ•°æ®å¯èƒ½å·²æ›´æ–°ï¼‰
            refreshMainConfigFromEconomyScheme();
            const nameInput = document.getElementById('economySchemeNameInput');
            if (nameInput) nameInput.value = copyName;
            showMessage(`å·²å¤åˆ¶æ–¹æ¡ˆä¸º"${copyName}"`, 'success');
        };
        
        // æ–°å»ºç»æµæ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.newEconomyScheme = function() {
            // æ¸…ç©ºå½“å‰æ–¹æ¡ˆID
            currentEconomySchemeId = null;
            
            // é‡ç½®æ‰€æœ‰æ•°æ®åˆ°åˆå§‹çŠ¶æ€
            // æ¸…ç©ºå‰¯æœ¬æŒ‘æˆ˜å¥–åŠ±ä¿¡æ¯ã€æ‹›å‹Ÿè§’è‰²è·å¾—ä¿¡æ¯
            lastMainDungeonGains = { exp: 0, levelUp: false, equipment: [], resources: [], gold: 0 };
            lastRecruitResult = { heroes: [], gold: 0 };
            
            // é‡ç½®å½“å‰å¤©æ•°ä¸º1
            playerResources.currentDay = 1;
            
            // é‡ç½®æ‹›å‹Ÿè§’è‰²çš„ç­‰çº§å’Œç»éªŒ
            recruitBoxLevel = 1;
            recruitCount = 0;
            
            // é‡ç½®ä½“åŠ›ã€é‡‘å¸ã€é’»çŸ³
            playerResources.stamina = 100;
            playerResources.currentStamina = 100;
            playerResources.gold = 0;
            playerResources.diamond = 0;
            playerResources.dailyGold = 0;
            playerResources.dailyDiamond = 0;
            playerResources.dailyRecruitTickets = 0;
            
            // é‡ç½®èƒŒåŒ…ï¼ˆåªä¿ç•™20ä¸ªæ‹›å‹Ÿåˆ¸ï¼‰
            bagItems = [];
            bagItems.push({ id: Date.now(), resourceId: '1021', name: getRecruitTicketName(), count: 20 });
            
            // é‡ç½®è‹±é›„åˆ—è¡¨ä¸ºé»˜è®¤5ä¸ªè§’è‰²
            playerHeroes = [
                { heroId: '11001', level: 1, copies: 0 },
                { heroId: '11002', level: 1, copies: 0 },
                { heroId: '11003', level: 1, copies: 0 },
                { heroId: '11101', level: 1, copies: 0 },
                { heroId: '11102', level: 1, copies: 0 }
            ];
            
            // é‡ç½®è´¦å·ä¿¡æ¯
            playerAccount.level = 1;
            playerAccount.exp = 0;
            const resetExpReq = getExpRequiredForLevel(2);
            playerAccount.expRequired = resetExpReq != null ? resetExpReq : 100;
            
            // é‡ç½®è£…å¤‡åˆ—è¡¨
            playerEquipment = [];
            
            // é‡ç½®ç©æ³•åˆ—è¡¨ä¸ºé»˜è®¤å€¼
            gameplayList = [
                { id: 1, name: 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜', staminaCost: 10, mainDungeonConfig: { qualityWeights: { 1: 60, 2: 30, 3: 10 }, qualities: [1, 2, 3], goldDrop: { enabled: true, minGold: 40, maxGold: 60 } } }
            ];
            
            // é‡ç½®èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨ä¸ºé»˜è®¤å€¼
            resourceConsumptionGameplayList = [
                { id: 1, name: 'æ‹›å‹Ÿè§’è‰²', itemName: 'æ‹›å‹Ÿåˆ¸', type: 'recruit' }
            ];
            
            // æ›´æ–°ç•Œé¢è¾“å…¥æ¡†
            const staminaInput = document.getElementById('playerStamina');
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            const goldInput = document.getElementById('playerGold');
            const diamondInput = document.getElementById('playerDiamond');
            const levelInput = document.getElementById('playerLevel');
            const expInput = document.getElementById('playerExp');
            const expRequiredInput = document.getElementById('playerExpRequired');
            const dailyGoldInput = document.getElementById('playerDailyGold');
            const dailyDiamondInput = document.getElementById('playerDailyDiamond');
            const dailyRecruitInput = document.getElementById('playerDailyRecruitTickets');
            const currentDayEl = document.getElementById('playerCurrentDay');
            
            if (staminaInput) staminaInput.value = 100;
            if (currentStaminaInput) currentStaminaInput.value = 100;
            if (goldInput) goldInput.value = 0;
            if (diamondInput) diamondInput.value = 0;
            if (levelInput) levelInput.value = 1;
            if (expInput) expInput.value = 0;
            if (expRequiredInput) expRequiredInput.value = playerAccount.expRequired;
            if (dailyGoldInput) dailyGoldInput.value = 0;
            if (dailyDiamondInput) dailyDiamondInput.value = 0;
            if (dailyRecruitInput) dailyRecruitInput.value = 0;
            if (currentDayEl) currentDayEl.textContent = 1;
            
            // åˆ·æ–°ç•Œé¢æ˜¾ç¤º
            renderBagItems();
            renderPlayerHeroes();
            renderPlayerOwnedEquipment();
            renderResourceGameplayList();
            renderGameplayList();
            renderHeroUpgradeConfig();
            
            // ä¿å­˜æ•°æ®åˆ°localStorage
            savePlayerEconomyData();
            
            // ç”Ÿæˆå”¯ä¸€çš„æ–¹æ¡ˆåç§°
            const schemes = loadEconomySchemes();
            let schemeName = 'æ–°æ–¹æ¡ˆ';
            let nameIndex = 1;
            while (schemes.some(s => s.name === schemeName)) {
                schemeName = `æ–°æ–¹æ¡ˆ${nameIndex}`;
                nameIndex++;
            }
            
            // å¡«å…¥æ–¹æ¡ˆåç§°è¾“å…¥æ¡†
            const nameInput = document.getElementById('economySchemeNameInput');
            if (nameInput) nameInput.value = schemeName;
            
            // æ¸…ç©ºä¸‹æ‹‰é€‰æ‹©æ¡†
            const selectEl = document.getElementById('economySchemeSelect');
            if (selectEl) selectEl.value = '';
            
            // æ›´æ–°ä¸‹æ‹‰é€‰æ‹©æ¡†æ˜¾ç¤º
            updateEconomySchemeSelect();
            
            // æ˜¾ç¤ºæç¤ºä¿¡æ¯
            showMessage(`å·²åˆ›å»ºæ–°æ–¹æ¡ˆ"${schemeName}"ï¼Œè¯·é…ç½®åä¿å­˜`, 'success');
        };
        
        // æ¨è¿› n å¤©ï¼Œå°†æ¯æ—¥èµ„æº Ã— n åŠ åˆ°å½“å‰èµ„æº
        function advanceDays(n) {
            if (n < 1) return;
            const staminaInput = document.getElementById('playerStamina');
            const dailyGoldInput = document.getElementById('playerDailyGold');
            const dailyDiamondInput = document.getElementById('playerDailyDiamond');
            const dailyRecruitInput = document.getElementById('playerDailyRecruitTickets');
            
            const perStamina = parseInt(staminaInput && staminaInput.value ? staminaInput.value : 0) || 0;
            const perGold = parseInt(dailyGoldInput && dailyGoldInput.value ? dailyGoldInput.value : 0) || 0;
            const perDiamond = parseInt(dailyDiamondInput && dailyDiamondInput.value ? dailyDiamondInput.value : 0) || 0;
            const perTickets = parseInt(dailyRecruitInput && dailyRecruitInput.value ? dailyRecruitInput.value : 0) || 0;
            
            const addStamina = perStamina * n;
            const addGold = perGold * n;
            const addDiamond = perDiamond * n;
            const addTickets = perTickets * n;
            
            playerResources.dailyGold = perGold;
            playerResources.dailyDiamond = perDiamond;
            playerResources.dailyRecruitTickets = perTickets;
            
            playerResources.currentStamina += addStamina;
            playerResources.gold += addGold;
            playerResources.diamond += addDiamond;
            playerResources.currentDay = (playerResources.currentDay || 1) + n;
            
            if (addTickets > 0) {
                const recruitTicketName = getRecruitTicketName();
                const existing = bagItems.find(i => i.resourceId === '1021' || i.name === recruitTicketName);
                if (existing) {
                    existing.count += addTickets;
                    if (!existing.resourceId) existing.resourceId = '1021';
                    if (!existing.name) existing.name = recruitTicketName;
                } else {
                    bagItems.push({ id: Date.now(), resourceId: '1021', name: recruitTicketName, count: addTickets });
                }
            }
            
            const currentStaminaEl = document.getElementById('playerCurrentStamina');
            const goldEl = document.getElementById('playerGold');
            const diamondEl = document.getElementById('playerDiamond');
            if (currentStaminaEl) currentStaminaEl.value = playerResources.currentStamina;
            if (goldEl) goldEl.value = playerResources.gold;
            if (diamondEl) diamondEl.value = playerResources.diamond;
            
            const currentDayEl = document.getElementById('playerCurrentDay');
            if (currentDayEl) currentDayEl.textContent = playerResources.currentDay;
            renderBagItems();
            renderResourceGameplayList();
            savePlayerEconomyData();
            
            const parts = [`ç¬¬ ${playerResources.currentDay} å¤©`];
            if (addStamina) parts.push(`ä½“åŠ› +${addStamina}`);
            if (addGold) parts.push(`é‡‘å¸ +${addGold}`);
            if (addDiamond) parts.push(`é’»çŸ³ +${addDiamond}`);
            if (addTickets) parts.push(`${getRecruitTicketName()} +${addTickets}`);
            showMessage(parts.join('ï¼Œ') + (n > 1 ? `ï¼ˆæ¨è¿›${n}å¤©ï¼‰` : ''), 'success');
        }
        
        // ä¸‹ä¸€å¤©ï¼šå°†æ¯æ—¥èµ„æºåŠ åˆ°å½“å‰èµ„æº
        window.nextDay = function() {
            advanceDays(1);
        };
        
        // ä¸‹10å¤©ï¼šå¤©æ•° +10ï¼Œè·å¾— 10 å€æ¯æ—¥èµ„æº
        window.nextTenDays = function() {
            advanceDays(10);
        };
        
        // é‡ç½®è´¦å·ä¿¡æ¯ï¼šæ¸…ç©ºå½“å‰èµ„æºã€è‹±é›„æ¢å¤é»˜è®¤ã€ç­‰çº§é‡ç½®ã€å·²æ‹¥æœ‰è£…å¤‡æ¸…ç©º
        window.resetAccountInfo = function() {
            const recruitTicketName = getRecruitTicketName();
            if (!confirm(`ç¡®å®šè¦é‡ç½®è´¦å·ä¿¡æ¯å—ï¼Ÿå°†æ¸…ç©ºå½“å‰èµ„æºã€æ¢å¤é»˜è®¤è‹±é›„ã€é‡ç½®ç­‰çº§ã€æ¸…ç©ºå·²æ‹¥æœ‰è£…å¤‡ã€é‡ç½®å¤©æ•°å’Œæ‹›å‹Ÿè¿›åº¦ï¼›é‡ç½®ååˆå§‹è·å¾—20${recruitTicketName}ï¼Œå¹¶æ¸…ç©ºå‰¯æœ¬æŒ‘æˆ˜å¥–åŠ±ä¸æ‹›å‹Ÿè·å¾—ä¿¡æ¯ã€‚`)) return;
            
            // æ¸…ç©ºå‰¯æœ¬æŒ‘æˆ˜å¥–åŠ±ä¿¡æ¯ã€æ‹›å‹Ÿè§’è‰²è·å¾—ä¿¡æ¯
            lastMainDungeonGains = { exp: 0, levelUp: false, equipment: [], resources: [], gold: 0 };
            lastRecruitResult = { heroes: [], gold: 0 };
            
            // é‡ç½®å½“å‰å¤©æ•°ä¸º1
            playerResources.currentDay = 1;
            
            // é‡ç½®æ‹›å‹Ÿè§’è‰²çš„ç­‰çº§å’Œç»éªŒ
            recruitBoxLevel = 1;
            recruitCount = 0;
            
            // å½“å‰ä½“åŠ›åˆå§‹ä¸ä¸‹ä¸€å¤©ä½“åŠ›ç›¸åŒï¼ˆä»è¾“å…¥æ¡†è¯»å–æˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼‰
            const staminaInput = document.getElementById('playerStamina');
            const dailyStamina = staminaInput ? (parseInt(staminaInput.value) || 100) : (playerResources.stamina || 100);
            playerResources.currentStamina = dailyStamina;
            playerResources.stamina = dailyStamina; // ç¡®ä¿staminaä¹Ÿæœ‰å€¼
            
            playerResources.gold = 0;
            playerResources.diamond = 0;
            bagItems = bagItems.filter(i => i.resourceId !== '1021' && i.name !== recruitTicketName);
            bagItems.push({ id: Date.now(), resourceId: '1021', name: recruitTicketName, count: 20 });
            
            playerHeroes = [
                { heroId: '11001', level: 1, copies: 0 },
                { heroId: '11002', level: 1, copies: 0 },
                { heroId: '11003', level: 1, copies: 0 },
                { heroId: '11101', level: 1, copies: 0 },
                { heroId: '11102', level: 1, copies: 0 }
            ];
            
            playerAccount.level = 1;
            playerAccount.exp = 0;
            const resetExpReq = getExpRequiredForLevel(2);
            playerAccount.expRequired = resetExpReq != null ? resetExpReq : 100;
            
            playerEquipment = [];
            
            // é‡ç½®è£…å¤‡å¼ºåŒ–æ•°æ®
            equipSlotLevels = {
                1: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                2: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                3: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 },
                4: { 'å¤´': 0, 'èº«': 0, 'æ‰‹': 0, 'è„š': 0 }
            };
            
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            const goldInput = document.getElementById('playerGold');
            const diamondInput = document.getElementById('playerDiamond');
            const levelInput = document.getElementById('playerLevel');
            const expInput = document.getElementById('playerExp');
            const expRequiredInput = document.getElementById('playerExpRequired');
            const currentDayEl = document.getElementById('playerCurrentDay');
            
            if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina;
            if (goldInput) goldInput.value = 0;
            if (diamondInput) diamondInput.value = 0;
            if (levelInput) levelInput.value = 1;
            if (expInput) expInput.value = 0;
            if (expRequiredInput) expRequiredInput.value = playerAccount.expRequired;
            if (currentDayEl) currentDayEl.textContent = 1;
            
            renderBagItems();
            renderPlayerHeroes();
            renderPlayerOwnedEquipment();
            renderResourceGameplayList();
            renderGameplayList();
            savePlayerEconomyData();
            showMessage('è´¦å·ä¿¡æ¯å·²é‡ç½®', 'success');
        };
        
        // æ·»åŠ ç©æ³•
        window.addGameplay = function() {
            const nameInput = document.getElementById('newGameplayName');
            const costInput = document.getElementById('newGameplayStaminaCost');
            
            if (!nameInput || !costInput) return;
            
            const name = nameInput.value.trim();
            const staminaCost = parseInt(costInput.value) || 0;
            
            if (!name) {
                showMessage('è¯·è¾“å…¥ç©æ³•åç§°', 'error');
                return;
            }
            
            const newGameplay = {
                id: Date.now(),
                name: name,
                staminaCost: staminaCost
            };
            
            gameplayList.push(newGameplay);
            nameInput.value = '';
            costInput.value = '0';
            
            renderGameplayList();
            savePlayerEconomyData();
            showMessage(`ç©æ³•"${name}"å·²æ·»åŠ `, 'success');
        };
        
        // ç§»é™¤ç©æ³•
        window.removeGameplay = function(gameplayId) {
            gameplayList = gameplayList.filter(g => g.id !== gameplayId);
            renderGameplayList();
            savePlayerEconomyData();
            showMessage('ç©æ³•å·²ç§»é™¤', 'success');
        };
        
        // ä»è£…å¤‡åç§°è§£æç­‰çº§ï¼ˆå¦‚ã€Œå¦å…‹å¤´ç™½10çº§ã€-> 10ï¼‰
        function getEquipmentLevelFromName(eq) {
            const name = (eq && eq.namecn) ? String(eq.namecn) : '';
            const m = name.match(/(\d+)\s*çº§/);
            return m ? parseInt(m[1], 10) : 1;
        }
        
        // æŒ‰æƒé‡éšæœºå“è´¨
        function rollQualityByWeights(qualityWeights) {
            const entries = Object.entries(qualityWeights || {}).filter(([_, w]) => (parseInt(w, 10) || 0) > 0);
            if (entries.length === 0) return 1;
            let total = 0;
            for (const [_, w] of entries) total += parseInt(w, 10) || 0;
            if (total <= 0) return 1;
            let r = Math.random() * total;
            for (const [q, w] of entries) {
                const ww = parseInt(w, 10) || 0;
                if (r < ww) return parseInt(q, 10) || 1;
                r -= ww;
            }
            return parseInt(entries[0][0], 10) || 1;
        }
        
        // æ‰§è¡Œå•æ¬¡ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜çš„æ ¸å¿ƒé€»è¾‘ï¼ˆè¿”å› { leveledUp, dropped, resources }ï¼‰
        function executeMainDungeonOnce(gameplay) {
            const curLevel = playerAccount.level || 1;
            playerAccount.exp += 10;
            let leveledUp = false;
            const expToNext = getExpRequiredForLevel(curLevel + 1);
            const required = expToNext != null ? expToNext : (playerAccount.expRequired || 100);
            if (playerAccount.exp >= required) {
                playerAccount.level = curLevel + 1;
                playerAccount.exp = 0;
                const nextNext = getExpRequiredForLevel(playerAccount.level + 1);
                playerAccount.expRequired = nextNext != null ? nextNext : Math.floor(required * 1.5);
                leveledUp = true;
            }
            
            const cfg = gameplay.mainDungeonConfig || { qualityWeights: { 1: 60, 2: 30, 3: 10 }, qualities: [1, 2, 3] };
            const playerLevel = playerAccount.level || 1;
            const count = Math.random() < 0.5 ? 1 : 2;
            const qualityNames = { 1: 'ç™½', 2: 'ç»¿', 3: 'è“' };
            const dropped = [];
            
            if (equipmentTable && equipmentTable.length > 0) {
                const typeList = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                for (let i = 0; i < count; i++) {
                    const quality = rollQualityByWeights(cfg.qualityWeights);
                    const job = 1 + Math.floor(Math.random() * 4);
                    const type = typeList[Math.floor(Math.random() * typeList.length)];
                    const candidates = equipmentTable.filter(eq => {
                        const eqJob = parseInt(eq.heroclass) || 0;
                        const eqQ = parseInt(eq.quality) || 1;
                        const eqLevel = getEquipmentLevelFromName(eq);
                        const eqType = eq.type || '';
                        return eqJob === job && eqQ === quality && eqLevel === playerLevel && eqType === type;
                    });
                    let pick = null;
                    if (candidates.length > 0) {
                        pick = candidates[Math.floor(Math.random() * candidates.length)];
                    } else {
                        const anyLevel = equipmentTable.filter(eq => {
                            const eqJob = parseInt(eq.heroclass) || 0;
                            const eqQ = parseInt(eq.quality) || 1;
                            const eqType = eq.type || '';
                            return eqJob === job && eqQ === quality && eqType === type;
                        });
                        if (anyLevel.length > 0) {
                            anyLevel.sort((a, b) => Math.abs(getEquipmentLevelFromName(a) - playerLevel) - Math.abs(getEquipmentLevelFromName(b) - playerLevel));
                            pick = anyLevel[0];
                        }
                    }
                    if (pick) {
                        const id = String(pick.id);
                        if (!playerEquipment.includes(id)) playerEquipment.push(id);
                        dropped.push({
                            name: pick.namecn || id,
                            quality: quality,
                            qualityName: qualityNames[quality]
                        });
                    }
                }
            }
            
            // èµ„æºæ‰è½é€»è¾‘ï¼ˆ1011, 1012, 1013, 1014ï¼‰
            const resourceDrops = [];
            const resourceIds = ['1011', '1012', '1013', '1014'];
            const resourceDropsConfig = cfg.resourceDrops || {};
            
            resourceIds.forEach(resourceId => {
                const dropConfig = resourceDropsConfig[resourceId];
                // å¦‚æœæœªé…ç½®æˆ–å¯ç”¨ï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼ˆ0-5éšæœºï¼‰
                const enabled = dropConfig == null || dropConfig.enabled !== false;
                if (enabled) {
                    const minCount = dropConfig && dropConfig.minCount != null ? dropConfig.minCount : 0;
                    const maxCount = dropConfig && dropConfig.maxCount != null ? dropConfig.maxCount : 5;
                    const dropCount = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
                    
                    if (dropCount > 0) {
                        const resourceName = getResourceName(resourceId);
                        resourceDrops.push({
                            resourceId: resourceId,
                            name: resourceName || resourceId,
                            count: dropCount
                        });
                        
                        // æ·»åŠ åˆ°èƒŒåŒ…
                        const existingItem = bagItems.find(item => item.resourceId === resourceId);
                        if (existingItem) {
                            existingItem.count += dropCount;
                        } else {
                            bagItems.push({
                                id: Date.now(),
                                resourceId: resourceId,
                                name: resourceName || resourceId,
                                count: dropCount
                            });
                        }
                    }
                }
            });
            
            // é‡‘å¸æ‰è½é€»è¾‘
            let goldDrop = 0;
            const goldDropConfig = cfg.goldDrop || {};
            const goldEnabled = goldDropConfig.enabled !== false; // é»˜è®¤å¯ç”¨
            if (goldEnabled) {
                const minGold = goldDropConfig.minGold != null ? goldDropConfig.minGold : 40;
                const maxGold = goldDropConfig.maxGold != null ? goldDropConfig.maxGold : 60;
                goldDrop = Math.floor(Math.random() * (maxGold - minGold + 1)) + minGold;
                
                if (goldDrop > 0) {
                    playerResources.gold = (playerResources.gold || 0) + goldDrop;
                }
            }
            
            return { leveledUp, dropped, resources: resourceDrops, gold: goldDrop };
        }
        
        // æ‰§è¡Œç©æ³•ï¼ˆæ¶ˆè€—ä½“åŠ›ï¼‰
        window.executeGameplay = function(gameplayId) {
            const gameplay = gameplayList.find(g => g.id === gameplayId);
            if (!gameplay) return;
            
            if (playerResources.currentStamina < gameplay.staminaCost) {
                showMessage(`ä½“åŠ›ä¸è¶³ï¼éœ€è¦${gameplay.staminaCost}ç‚¹ä½“åŠ›`, 'error');
                return;
            }
            
            playerResources.currentStamina -= gameplay.staminaCost;
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina;
            
            if (gameplay.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜') {
                const result = executeMainDungeonOnce(gameplay);
                if (result.leveledUp) {
                    const levelInput = document.getElementById('playerLevel');
                    if (levelInput) levelInput.value = playerAccount.level;
                    showMessage(`æ­å–œå‡çº§ï¼å½“å‰ç­‰çº§ï¼š${playerAccount.level}`, 'success');
                }
                const expInput = document.getElementById('playerExp');
                const expRequiredInput = document.getElementById('playerExpRequired');
                const dispReq = getExpRequiredForLevel((playerAccount.level || 1) + 1);
                if (expInput) expInput.value = playerAccount.exp;
                if (expRequiredInput) expRequiredInput.value = dispReq != null ? dispReq : playerAccount.expRequired;
                
                lastMainDungeonGains = {
                    exp: 10,
                    levelUp: result.leveledUp,
                    equipment: result.dropped,
                    resources: result.resources || [],
                    gold: result.gold || 0
                };
                
                // å¦‚æœæœ‰èµ„æºæ‰è½ï¼Œæ›´æ–°èƒŒåŒ…æ˜¾ç¤º
                if (result.resources && result.resources.length > 0) {
                    renderBagItems();
                }
                
                // å¦‚æœæœ‰é‡‘å¸æ‰è½ï¼Œæ›´æ–°é‡‘å¸æ˜¾ç¤º
                if (result.gold > 0) {
                    const goldInput = document.getElementById('playerGold');
                    if (goldInput) goldInput.value = playerResources.gold;
                    syncEconomyGoldDisplay();
                }
                
                let resultMsg = '';
                if (result.dropped.length > 0) {
                    renderPlayerOwnedEquipment();
                    const equipmentList = result.dropped.map(eq => {
                        const color = getQualityTextColor(eq.quality);
                        return `<span style="color: ${color}; font-weight: 600;">${eq.name}</span><span style="color: ${color}; font-size: 0.9em;">(${eq.qualityName})</span>`;
                    }).join('ã€');
                    resultMsg += `è·å¾—è£…å¤‡ï¼š${equipmentList}`;
                }
                if (result.resources && result.resources.length > 0) {
                    const resourceList = result.resources.map(res => `${res.name} x${res.count}`).join('ã€');
                    if (resultMsg) resultMsg += 'ï¼›';
                    resultMsg += `è·å¾—èµ„æºï¼š${resourceList}`;
                }
                if (result.gold > 0) {
                    if (resultMsg) resultMsg += 'ï¼›';
                    resultMsg += `è·å¾—é‡‘å¸ï¼š${result.gold}`;
                }
                if (resultMsg) {
                    showMessage(resultMsg, 'success');
                }
                
                renderGameplayList();
            }
            
            savePlayerEconomyData();
            showMessage(`å·²æ‰§è¡Œ"${gameplay.name}"ï¼Œæ¶ˆè€—${gameplay.staminaCost}ç‚¹ä½“åŠ›`, 'success');
        };
        
        // æ‰§è¡Œç©æ³•10æ¬¡
        window.executeGameplayTen = function(gameplayId) {
            const gameplay = gameplayList.find(g => g.id === gameplayId);
            if (!gameplay) return;
            
            const needed = gameplay.staminaCost * 10;
            if (playerResources.currentStamina < needed) {
                showMessage(`ä½“åŠ›ä¸è¶³ï¼éœ€è¦${needed}ç‚¹ä½“åŠ›æ‰èƒ½æ‰§è¡Œ10æ¬¡`, 'error');
                return;
            }
            
            if (gameplay.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜') {
                let totalExp = 0, totalLevelUps = 0, allDropped = [];
                const allResources = {};
                let totalGold = 0;
                const initialLevel = playerAccount.level || 1;
                
                for (let i = 0; i < 10; i++) {
                    playerResources.currentStamina -= gameplay.staminaCost;
                    const result = executeMainDungeonOnce(gameplay);
                    totalExp += 10;
                    if (result.leveledUp) totalLevelUps++;
                    allDropped = allDropped.concat(result.dropped);
                    if (result.resources) {
                        result.resources.forEach(res => {
                            if (!allResources[res.resourceId]) {
                                allResources[res.resourceId] = { resourceId: res.resourceId, name: res.name, count: 0 };
                            }
                            allResources[res.resourceId].count += res.count;
                        });
                    }
                    if (result.gold) {
                        totalGold += result.gold;
                    }
                }
                
                const currentStaminaInput = document.getElementById('playerCurrentStamina');
                if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina;
                const expInput = document.getElementById('playerExp');
                const expRequiredInput = document.getElementById('playerExpRequired');
                const levelInput = document.getElementById('playerLevel');
                const goldInput = document.getElementById('playerGold');
                const dispReq = getExpRequiredForLevel((playerAccount.level || 1) + 1);
                if (expInput) expInput.value = playerAccount.exp;
                if (expRequiredInput) expRequiredInput.value = dispReq != null ? dispReq : playerAccount.expRequired;
                if (levelInput) levelInput.value = playerAccount.level;
                if (goldInput) goldInput.value = playerResources.gold;
                syncEconomyGoldDisplay();
                
                lastMainDungeonGains = {
                    exp: totalExp,
                    levelUp: totalLevelUps > 0,
                    equipment: allDropped,
                    resources: Object.values(allResources),
                    gold: totalGold
                };
                
                if (allDropped.length > 0) {
                    renderPlayerOwnedEquipment();
                }
                if (Object.keys(allResources).length > 0) {
                    renderBagItems();
                }
                
                renderGameplayList();
                savePlayerEconomyData();
                
                let gainMsg = '';
                if (allDropped.length > 0) {
                    const equipmentList = allDropped.map(eq => {
                        const color = getQualityTextColor(eq.quality);
                        return `<span style="color: ${color}; font-weight: 600;">${eq.name}</span><span style="color: ${color}; font-size: 0.9em;">(${eq.qualityName})</span>`;
                    }).join('ã€');
                    gainMsg += `ï¼Œè·å¾—è£…å¤‡ï¼š${equipmentList}`;
                }
                if (Object.keys(allResources).length > 0) {
                    const resourceList = Object.values(allResources).map(res => `${res.name} x${res.count}`).join('ã€');
                    gainMsg += `ï¼Œè·å¾—èµ„æºï¼š${resourceList}`;
                }
                if (totalGold > 0) {
                    gainMsg += `ï¼Œè·å¾—é‡‘å¸ï¼š${totalGold}`;
                }
                const msg = `å·²æ‰§è¡Œ10æ¬¡ï¼Œæ¶ˆè€—${needed}ç‚¹ä½“åŠ›ï¼Œè·å¾—${totalExp}ç»éªŒ${totalLevelUps > 0 ? `ï¼Œå‡çº§${totalLevelUps}æ¬¡` : ''}${gainMsg}`;
                showMessage(msg, 'success');
            } else {
                showMessage('è¯¥åŠŸèƒ½ä»…æ”¯æŒä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜', 'error');
            }
        };
        
        // æŒ‘æˆ˜åˆ°æ— ä½“åŠ›
        window.executeGameplayUntilNoStamina = function(gameplayId) {
            const gameplay = gameplayList.find(g => g.id === gameplayId);
            if (!gameplay) return;
            
            if (playerResources.currentStamina < gameplay.staminaCost) {
                showMessage(`ä½“åŠ›ä¸è¶³ï¼éœ€è¦${gameplay.staminaCost}ç‚¹ä½“åŠ›`, 'error');
                return;
            }
            
            if (gameplay.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜') {
                let count = 0, totalExp = 0, totalLevelUps = 0, allDropped = [];
                const allResources = {};
                let totalGold = 0;
                const initialLevel = playerAccount.level || 1;
                
                while (playerResources.currentStamina >= gameplay.staminaCost) {
                    playerResources.currentStamina -= gameplay.staminaCost;
                    const result = executeMainDungeonOnce(gameplay);
                    count++;
                    totalExp += 10;
                    if (result.leveledUp) totalLevelUps++;
                    allDropped = allDropped.concat(result.dropped);
                    if (result.resources) {
                        result.resources.forEach(res => {
                            if (!allResources[res.resourceId]) {
                                allResources[res.resourceId] = { resourceId: res.resourceId, name: res.name, count: 0 };
                            }
                            allResources[res.resourceId].count += res.count;
                        });
                    }
                    if (result.gold) {
                        totalGold += result.gold;
                    }
                }
                
                const currentStaminaInput = document.getElementById('playerCurrentStamina');
                if (currentStaminaInput) currentStaminaInput.value = playerResources.currentStamina;
                const expInput = document.getElementById('playerExp');
                const expRequiredInput = document.getElementById('playerExpRequired');
                const levelInput = document.getElementById('playerLevel');
                const goldInput = document.getElementById('playerGold');
                const dispReq = getExpRequiredForLevel((playerAccount.level || 1) + 1);
                if (expInput) expInput.value = playerAccount.exp;
                if (expRequiredInput) expRequiredInput.value = dispReq != null ? dispReq : playerAccount.expRequired;
                if (levelInput) levelInput.value = playerAccount.level;
                if (goldInput) goldInput.value = playerResources.gold;
                syncEconomyGoldDisplay();
                
                lastMainDungeonGains = {
                    exp: totalExp,
                    levelUp: totalLevelUps > 0,
                    equipment: allDropped,
                    resources: Object.values(allResources),
                    gold: totalGold
                };
                
                if (allDropped.length > 0) {
                    renderPlayerOwnedEquipment();
                }
                if (Object.keys(allResources).length > 0) {
                    renderBagItems();
                }
                
                renderGameplayList();
                savePlayerEconomyData();
                
                let gainMsg = '';
                if (allDropped.length > 0) {
                    const equipmentList = allDropped.map(eq => {
                        const color = getQualityTextColor(eq.quality);
                        return `<span style="color: ${color}; font-weight: 600;">${eq.name}</span><span style="color: ${color}; font-size: 0.9em;">(${eq.qualityName})</span>`;
                    }).join('ã€');
                    gainMsg += `ï¼Œè·å¾—è£…å¤‡ï¼š${equipmentList}`;
                }
                if (Object.keys(allResources).length > 0) {
                    const resourceList = Object.values(allResources).map(res => `${res.name} x${res.count}`).join('ã€');
                    gainMsg += `ï¼Œè·å¾—èµ„æºï¼š${resourceList}`;
                }
                if (totalGold > 0) {
                    gainMsg += `ï¼Œè·å¾—é‡‘å¸ï¼š${totalGold}`;
                }
                const msg = `å·²æ‰§è¡Œ${count}æ¬¡ï¼Œæ¶ˆè€—${count * gameplay.staminaCost}ç‚¹ä½“åŠ›ï¼Œè·å¾—${totalExp}ç»éªŒ${totalLevelUps > 0 ? `ï¼Œå‡çº§${totalLevelUps}æ¬¡` : ''}${gainMsg}`;
                showMessage(msg, 'success');
            } else {
                showMessage('è¯¥åŠŸèƒ½ä»…æ”¯æŒä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜', 'error');
            }
        };
        
        // æ¸²æŸ“ç©æ³•åˆ—è¡¨
        function renderGameplayList() {
            const listEl = document.getElementById('gameplayList');
            if (!listEl) return;
            
            if (gameplayList.length === 0) {
                listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">æš‚æ— ç©æ³•ï¼Œè¯·æ·»åŠ ç©æ³•</div>';
                return;
            }
            
            listEl.innerHTML = gameplayList.map(gameplay => {
                if (gameplay.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜' && gameplay.mainDungeonConfig) {
                    const cfg = gameplay.mainDungeonConfig;
                    const qw = cfg.qualityWeights || { 1: 60, 2: 30, 3: 10 };
                    const q1 = qw[1] != null ? qw[1] : 60;
                    const q2 = qw[2] != null ? qw[2] : 30;
                    const q3 = qw[3] != null ? qw[3] : 10;
                    return `
                        <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333; font-size: 1em;">${gameplay.name}</div>
                                <button class="btn btn-danger" onclick="removeGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                            </div>
                            <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                                ä½“åŠ›æ¶ˆè€—ï¼š<span style="color: #ff6b6b; font-weight: 600;">${gameplay.staminaCost}</span> ç‚¹
                            </div>
                            <div style="margin-bottom: 12px; padding: 10px; background: #f8f9ff; border-radius: 6px; font-size: 0.9em;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px;">è£…å¤‡å“è´¨ä¸æƒé‡ï¼ˆ1ç™½ 2ç»¿ 3è“ï¼‰</div>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                    <div><label style="color: #666;">å“è´¨1æƒé‡</label><input type="number" min="0" value="${q1}" onchange="updateMainDungeonQualityWeight(1, this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" /></div>
                                    <div><label style="color: #666;">å“è´¨2æƒé‡</label><input type="number" min="0" value="${q2}" onchange="updateMainDungeonQualityWeight(2, this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" /></div>
                                    <div><label style="color: #666;">å“è´¨3æƒé‡</label><input type="number" min="0" value="${q3}" onchange="updateMainDungeonQualityWeight(3, this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" /></div>
                                </div>
                            </div>
                            <div style="margin-bottom: 12px;">
                                <button type="button" id="mainDungeonGoldDropToggleBtn_${gameplay.id}" onclick="toggleMainDungeonGoldDropConfig(${gameplay.id})" style="padding: 6px 14px; font-size: 0.85em; border: 2px solid #667eea; border-radius: 6px; background: #f0f4ff; color: #667eea; cursor: pointer; width: 100%; margin-bottom: 8px;">å±•å¼€é‡‘å¸æ‰è½é…ç½®</button>
                                <button type="button" id="mainDungeonResourceDropsToggleBtn_${gameplay.id}" onclick="toggleMainDungeonResourceDropsConfig(${gameplay.id})" style="padding: 6px 14px; font-size: 0.85em; border: 2px solid #667eea; border-radius: 6px; background: #f0f4ff; color: #667eea; cursor: pointer; width: 100%;">å±•å¼€èµ„æºæ‰è½é…ç½®</button>
                            </div>
                            <div id="mainDungeonGoldDropConfigArea_${gameplay.id}" style="display: none; padding: 10px; background: #f8f9ff; border-radius: 6px; font-size: 0.9em; margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px;">é‡‘å¸æ‰è½é…ç½®</div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <input type="checkbox" id="goldDropEnabled_${gameplay.id}" ${(cfg.goldDrop && cfg.goldDrop.enabled !== false) ? 'checked' : ''} onchange="updateMainDungeonGoldDrop(${gameplay.id}, 'enabled', this.checked)" style="width: 18px; height: 18px;" />
                                    <label style="font-weight: 600; color: #333; cursor: pointer;" for="goldDropEnabled_${gameplay.id}">å¯ç”¨é‡‘å¸æ‰è½</label>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-left: 26px;">
                                    <div>
                                        <label style="color: #666; font-size: 0.85em;">æœ€å°é‡‘å¸</label>
                                        <input type="number" id="goldDropMinGold_${gameplay.id}" min="0" max="1000" value="${cfg.goldDrop && cfg.goldDrop.minGold != null ? cfg.goldDrop.minGold : 40}" onchange="updateMainDungeonGoldDrop(${gameplay.id}, 'minGold', this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" ${(cfg.goldDrop && cfg.goldDrop.enabled === false) ? 'disabled' : ''} />
                                    </div>
                                    <div>
                                        <label style="color: #666; font-size: 0.85em;">æœ€å¤§é‡‘å¸</label>
                                        <input type="number" id="goldDropMaxGold_${gameplay.id}" min="0" max="1000" value="${cfg.goldDrop && cfg.goldDrop.maxGold != null ? cfg.goldDrop.maxGold : 60}" onchange="updateMainDungeonGoldDrop(${gameplay.id}, 'maxGold', this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" ${(cfg.goldDrop && cfg.goldDrop.enabled === false) ? 'disabled' : ''} />
                                    </div>
                                </div>
                            </div>
                            <div id="mainDungeonResourceDropsConfigArea_${gameplay.id}" style="display: none; padding: 10px; background: #f8f9ff; border-radius: 6px; font-size: 0.9em; margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px;">èµ„æºæ‰è½é…ç½®ï¼ˆ1011, 1012, 1013, 1014ï¼‰</div>
                                ${['1011', '1012', '1013', '1014'].map(resourceId => {
                                    const resourceName = getResourceName(resourceId) || resourceId;
                                    const dropConfig = cfg.resourceDrops && cfg.resourceDrops[resourceId] || {};
                                    const enabled = dropConfig.enabled !== false; // é»˜è®¤å¯ç”¨
                                    const minCount = dropConfig.minCount != null ? dropConfig.minCount : 0;
                                    const maxCount = dropConfig.maxCount != null ? dropConfig.maxCount : 5;
                                    return `
                                        <div style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px; border: 1px solid #e0e0e0;">
                                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                                <input type="checkbox" id="resourceDropEnabled_${gameplay.id}_${resourceId}" ${enabled ? 'checked' : ''} onchange="updateMainDungeonResourceDrop(${gameplay.id}, '${resourceId}', 'enabled', this.checked)" style="width: 18px; height: 18px;" />
                                                <label style="font-weight: 600; color: #333; cursor: pointer;" for="resourceDropEnabled_${gameplay.id}_${resourceId}">${resourceName} (${resourceId})</label>
                                            </div>
                                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-left: 26px;">
                                                <div>
                                                    <label style="color: #666; font-size: 0.85em;">æœ€å°æ•°é‡</label>
                                                    <input type="number" id="resourceDropMinCount_${gameplay.id}_${resourceId}" min="0" max="5" value="${minCount}" onchange="updateMainDungeonResourceDrop(${gameplay.id}, '${resourceId}', 'minCount', this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" ${!enabled ? 'disabled' : ''} />
                                                </div>
                                                <div>
                                                    <label style="color: #666; font-size: 0.85em;">æœ€å¤§æ•°é‡</label>
                                                    <input type="number" id="resourceDropMaxCount_${gameplay.id}_${resourceId}" min="0" max="5" value="${maxCount}" onchange="updateMainDungeonResourceDrop(${gameplay.id}, '${resourceId}', 'maxCount', this.value)" style="width: 100%; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em;" ${!enabled ? 'disabled' : ''} />
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 8px;">
                                <button class="btn btn-primary" onclick="executeGameplay(${gameplay.id})" style="padding: 8px; font-size: 0.9em;">æ‰§è¡Œ1æ¬¡</button>
                                <button class="btn btn-primary" onclick="executeGameplayTen(${gameplay.id})" style="padding: 8px; font-size: 0.9em;" ${playerResources.currentStamina < gameplay.staminaCost * 10 ? 'disabled' : ''}>æ‰§è¡Œ10æ¬¡</button>
                                <button class="btn btn-primary" onclick="executeGameplayUntilNoStamina(${gameplay.id})" style="padding: 8px; font-size: 0.9em;" ${playerResources.currentStamina < gameplay.staminaCost ? 'disabled' : ''}>æŒ‘æˆ˜åˆ°æ— ä½“åŠ›</button>
                            </div>
                            ${lastMainDungeonGains.exp > 0 || lastMainDungeonGains.equipment.length > 0 || (lastMainDungeonGains.resources && lastMainDungeonGains.resources.length > 0) || lastMainDungeonGains.gold > 0 ? `
                            <div style="margin-top: 12px; padding: 10px; background: #f0f9ff; border-radius: 6px; border: 1px solid #339af0;">
                                <div style="font-weight: 600; color: #1864ab; font-size: 0.9em; margin-bottom: 6px;">æœ¬æ¬¡æ‰€æœ‰è·å¾—çš„èµ„æº</div>
                                <div style="font-size: 0.85em; color: #333;">
                                    ${lastMainDungeonGains.exp > 0 ? `<div>ç»éªŒï¼š+${lastMainDungeonGains.exp}</div>` : ''}
                                    ${lastMainDungeonGains.levelUp ? `<div style="color: #51cf66; font-weight: 600;">ç­‰çº§æå‡ï¼š${playerAccount.level}</div>` : ''}
                                    ${lastMainDungeonGains.equipment.length > 0 ? `<div>è£…å¤‡ï¼š${lastMainDungeonGains.equipment.map(eq => {
                                        if (typeof eq === 'string') {
                                            // å…¼å®¹æ—§æ ¼å¼ï¼ˆå­—ç¬¦ä¸²ï¼‰
                                            return eq;
                                        } else {
                                            // æ–°æ ¼å¼ï¼ˆå¯¹è±¡ï¼‰
                                            const color = getQualityTextColor(eq.quality);
                                            return `<span style="color: ${color}; font-weight: 600;">${eq.name}</span><span style="color: ${color}; font-size: 0.9em;">(${eq.qualityName})</span>`;
                                        }
                                    }).join('ã€')}</div>` : ''}
                                    ${lastMainDungeonGains.resources && lastMainDungeonGains.resources.length > 0 ? `<div>èµ„æºï¼š${lastMainDungeonGains.resources.map(res => `${res.name} x${res.count}`).join('ã€')}</div>` : ''}
                                    ${lastMainDungeonGains.gold > 0 ? `<div>é‡‘å¸ï¼š+${lastMainDungeonGains.gold}</div>` : ''}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    `;
                }
                return `
                    <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: 600; color: #333; font-size: 1em;">${gameplay.name}</div>
                            <button class="btn btn-danger" onclick="removeGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                        </div>
                        <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                            ä½“åŠ›æ¶ˆè€—ï¼š<span style="color: #ff6b6b; font-weight: 600;">${gameplay.staminaCost}</span> ç‚¹
                        </div>
                        <button class="btn btn-primary" onclick="executeGameplay(${gameplay.id})" style="width: 100%; padding: 8px; font-size: 0.9em;">æ‰§è¡Œç©æ³•</button>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°ä¸»çº¿å‰¯æœ¬å“è´¨æƒé‡
        window.updateMainDungeonQualityWeight = function(quality, value) {
            const g = gameplayList.find(x => x.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜');
            if (!g || !g.mainDungeonConfig) return;
            if (!g.mainDungeonConfig.qualityWeights) g.mainDungeonConfig.qualityWeights = {};
            g.mainDungeonConfig.qualityWeights[quality] = parseInt(value, 10) || 0;
            savePlayerEconomyData();
        };
        
        // åˆ‡æ¢ä¸»çº¿å‰¯æœ¬èµ„æºæ‰è½é…ç½®æ˜¾ç¤º/éšè—
        window.toggleMainDungeonResourceDropsConfig = function(gameplayId) {
            const area = document.getElementById(`mainDungeonResourceDropsConfigArea_${gameplayId}`);
            const btn = document.getElementById(`mainDungeonResourceDropsToggleBtn_${gameplayId}`);
            if (!area || !btn) return;
            
            const isVisible = area.style.display !== 'none';
            area.style.display = isVisible ? 'none' : 'block';
            btn.textContent = isVisible ? 'å±•å¼€èµ„æºæ‰è½é…ç½®' : 'æ”¶èµ·èµ„æºæ‰è½é…ç½®';
        };
        
        // åˆ‡æ¢ä¸»çº¿å‰¯æœ¬é‡‘å¸æ‰è½é…ç½®æ˜¾ç¤º/éšè—
        window.toggleMainDungeonGoldDropConfig = function(gameplayId) {
            const area = document.getElementById(`mainDungeonGoldDropConfigArea_${gameplayId}`);
            const btn = document.getElementById(`mainDungeonGoldDropToggleBtn_${gameplayId}`);
            if (!area || !btn) return;
            
            const isVisible = area.style.display !== 'none';
            area.style.display = isVisible ? 'none' : 'block';
            btn.textContent = isVisible ? 'å±•å¼€é‡‘å¸æ‰è½é…ç½®' : 'æ”¶èµ·é‡‘å¸æ‰è½é…ç½®';
        };
        
        // æ›´æ–°ä¸»çº¿å‰¯æœ¬é‡‘å¸æ‰è½é…ç½®
        window.updateMainDungeonGoldDrop = function(gameplayId, field, value) {
            const g = gameplayList.find(x => x.id === gameplayId && x.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜');
            if (!g || !g.mainDungeonConfig) return;
            if (!g.mainDungeonConfig.goldDrop) g.mainDungeonConfig.goldDrop = {};
            
            if (field === 'enabled') {
                g.mainDungeonConfig.goldDrop.enabled = value;
                // æ›´æ–°è¾“å…¥æ¡†çš„ç¦ç”¨çŠ¶æ€
                const minInput = document.getElementById(`goldDropMinGold_${gameplayId}`);
                const maxInput = document.getElementById(`goldDropMaxGold_${gameplayId}`);
                if (minInput) minInput.disabled = !value;
                if (maxInput) maxInput.disabled = !value;
            } else if (field === 'minGold') {
                g.mainDungeonConfig.goldDrop.minGold = Math.max(0, Math.min(1000, parseInt(value, 10) || 40));
            } else if (field === 'maxGold') {
                g.mainDungeonConfig.goldDrop.maxGold = Math.max(0, Math.min(1000, parseInt(value, 10) || 60));
            }
            
            savePlayerEconomyData();
        };
        
        // æ›´æ–°ä¸»çº¿å‰¯æœ¬èµ„æºæ‰è½é…ç½®
        window.updateMainDungeonResourceDrop = function(gameplayId, resourceId, field, value) {
            const g = gameplayList.find(x => x.id === gameplayId && x.name === 'ä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜');
            if (!g || !g.mainDungeonConfig) return;
            if (!g.mainDungeonConfig.resourceDrops) g.mainDungeonConfig.resourceDrops = {};
            if (!g.mainDungeonConfig.resourceDrops[resourceId]) g.mainDungeonConfig.resourceDrops[resourceId] = {};
            
            if (field === 'enabled') {
                g.mainDungeonConfig.resourceDrops[resourceId].enabled = value;
                // æ›´æ–°è¾“å…¥æ¡†çš„ç¦ç”¨çŠ¶æ€
                const minInput = document.getElementById(`resourceDropMinCount_${gameplayId}_${resourceId}`);
                const maxInput = document.getElementById(`resourceDropMaxCount_${gameplayId}_${resourceId}`);
                if (minInput) minInput.disabled = !value;
                if (maxInput) maxInput.disabled = !value;
            } else if (field === 'minCount') {
                g.mainDungeonConfig.resourceDrops[resourceId].minCount = Math.max(0, Math.min(5, parseInt(value, 10) || 0));
            } else if (field === 'maxCount') {
                g.mainDungeonConfig.resourceDrops[resourceId].maxCount = Math.max(0, Math.min(5, parseInt(value, 10) || 5));
            }
            
            savePlayerEconomyData();
        };
        
        // æ·»åŠ èµ„æºæ¶ˆè€—ç©æ³•
        window.addResourceGameplay = function() {
            const nameInput = document.getElementById('newResourceGameplayName');
            const itemNameInput = document.getElementById('newResourceGameplayItemName');
            
            if (!nameInput || !itemNameInput) return;
            
            const name = nameInput.value.trim();
            const itemName = itemNameInput.value.trim();
            
            if (!name) {
                showMessage('è¯·è¾“å…¥ç©æ³•åç§°', 'error');
                return;
            }
            
            if (!itemName) {
                showMessage('è¯·è¾“å…¥æ¶ˆè€—é“å…·åç§°', 'error');
                return;
            }
            
            const maxId = resourceConsumptionGameplayList.length > 0 
                ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                : 0;
            const newGameplay = {
                id: maxId + 1,
                name: name,
                itemName: itemName,
                type: 'custom'
            };
            
            resourceConsumptionGameplayList.push(newGameplay);
            nameInput.value = '';
            itemNameInput.value = '';
            
            renderResourceGameplayList();
            savePlayerEconomyData();
            showMessage(`ç©æ³•"${name}"å·²æ·»åŠ `, 'success');
        };
        
        // ç§»é™¤èµ„æºæ¶ˆè€—ç©æ³•
        window.removeResourceGameplay = function(gameplayId) {
            resourceConsumptionGameplayList = resourceConsumptionGameplayList.filter(g => g.id !== gameplayId);
            renderResourceGameplayList();
            savePlayerEconomyData();
            showMessage('ç©æ³•å·²ç§»é™¤', 'success');
        };
        
        // å¥–æ± ç­‰çº§ï¼šç´¯è®¡æ‹›å‹Ÿæ¬¡æ•°è¾¾åˆ° HeroBoxLevel è¡¨å¯¹åº”æ¡£ä½å³å‡çº§
        function totalRecruitsToReachLevel(targetLevel) {
            if (!recruitBoxLevelTable.length) return 0;
            let sum = 0;
            for (const row of recruitBoxLevelTable) {
                if (row.level > targetLevel) break;
                sum += row.requiredCount || 0;
            }
            return sum;
        }
        
        function getRecruitProgress() {
            const count = recruitCount || 0;
            let level = 1;
            if (recruitBoxLevelTable.length) {
                for (const row of recruitBoxLevelTable) {
                    if (totalRecruitsToReachLevel(row.level) <= count) level = row.level;
                }
            }
            const next = recruitBoxLevelTable.find(r => r.level === level + 1);
            const neededForNext = next ? next.requiredCount : 0;
            const base = totalRecruitsToReachLevel(level);
            const currentProgress = Math.max(0, count - base);
            const isMax = !next;
            return { level, count, neededForNext, currentProgress, isMax };
        }
        
        function applyRecruitCount(n) {
            recruitCount = (recruitCount || 0) + n;
            const p = getRecruitProgress();
            recruitBoxLevel = p.level;
        }
        
        // æŒ‰æƒé‡ä»å¥–æ± ä¸­æŠ½ä¸€è¡Œï¼ˆHeroPoolGroupï¼Œå½“å‰ç­‰çº§ï¼‰
        function rollRecruitPoolRow(level) {
            const rows = recruitPoolTable.filter(r => r.level === level);
            if (!rows.length) return null;
            let total = 0;
            for (const r of rows) total += (r.weight || 0);
            if (total <= 0) return rows[0] || null;
            let rnd = Math.random() * total;
            for (const r of rows) {
                const w = r.weight || 0;
                if (rnd < w) return r;
                rnd -= w;
            }
            return rows[rows.length - 1];
        }
        
        // å•æ¬¡æ‹›å‹ŸæŠ½å¥–ï¼šè¿”å› { heroId æˆ– null, gold }
        function performRecruitDraw(level) {
            const row = rollRecruitPoolRow(level);
            if (!row) return { heroId: null, gold: 0 };
            const d = row.qualityOrGold;
            if (d >= 1 && d <= 4) {
                const quality = d + 2; // 1â†’3, 2â†’4, 3â†’5, 4â†’6
                const candidates = (heroTable || []).filter(h => (parseInt(h.quality) || 0) === quality);
                if (!candidates.length) return { heroId: null, gold: 0 };
                const hero = candidates[Math.floor(Math.random() * candidates.length)];
                return { heroId: hero.id, gold: 0 };
            }
            const gold = Math.max(0, parseInt(d) || 0);
            return { heroId: null, gold };
        }
        
        // æ‰§è¡Œ N æ¬¡æ‹›å‹ŸæŠ½å¥–ï¼Œæ›´æ–°ç©å®¶è‹±é›„/é‡‘å¸ï¼Œè¿”å› { heroes: [{heroId, name, quality, count}], gold }
        function runRecruitDraws(n) {
            const level = getRecruitProgress().level;
            const heroMap = {}; // {heroId: {heroId, name, quality, count}}
            let gold = 0;
            
            for (let i = 0; i < n; i++) {
                const r = performRecruitDraw(level);
                if (r.heroId) {
                    const heroId = String(r.heroId);
                    const hero = heroTable.find(h => String(h.id) === heroId);
                    const heroName = hero ? hero.namecn : heroId;
                    const heroQuality = hero ? (parseInt(hero.quality) || 1) : 1;
                    
                    // å¦‚æœå·²æœ‰è¯¥è‹±é›„ï¼Œå¢åŠ  copiesï¼›å¦åˆ™æ·»åŠ æ–°è‹±é›„
                    const existing = playerHeroes.find(h => String(h.heroId) === heroId);
                    if (existing) {
                        existing.copies = (existing.copies || 0) + 1;
                    } else {
                        playerHeroes.push({ heroId: heroId, level: 1, copies: 0 });
                    }
                    
                    // è®°å½•åˆ°ç»“æœä¸­
                    if (!heroMap[heroId]) {
                        heroMap[heroId] = { heroId, name: heroName, quality: heroQuality, count: 0 };
                    }
                    heroMap[heroId].count++;
                } else if (r.gold > 0) {
                    playerResources.gold = (playerResources.gold || 0) + r.gold;
                    gold += r.gold;
                }
            }
            
            return { heroes: Object.values(heroMap), gold };
        }
        
        // æ‰§è¡Œæ‹›å‹Ÿï¼šå•æŠ½
        window.executeRecruitSingle = function() {
            const itemName = getRecruitTicketName();
            const item = bagItems.find(item => item.resourceId === '1021' || item.name === itemName);
            if (!item || item.count < 1) {
                showMessage(`èƒŒåŒ…ä¸­æ²¡æœ‰è¶³å¤Ÿçš„${itemName}ï¼`, 'error');
                return;
            }
            item.count -= 1;
            if (item.count === 0) bagItems = bagItems.filter(i => i.name !== itemName);
            applyRecruitCount(1);
            lastRecruitResult = runRecruitDraws(1);
            renderBagItems();
            renderPlayerHeroes();
            renderResourceGameplayList();
            syncEconomyGoldDisplay();
            savePlayerEconomyData();
            showMessage(`æ¶ˆè€—1å¼ ${itemName}ï¼Œå•æŠ½å®Œæˆ`, 'success');
        };
        
        // æ‰§è¡Œæ‹›å‹Ÿï¼š10è¿æŠ½
        window.executeRecruitTen = function() {
            const itemName = getRecruitTicketName();
            const item = bagItems.find(item => item.resourceId === '1021' || item.name === itemName);
            if (!item || item.count < 10) {
                showMessage(`èƒŒåŒ…ä¸­æ²¡æœ‰è¶³å¤Ÿçš„${itemName}ï¼éœ€è¦10å¼ `, 'error');
                return;
            }
            item.count -= 10;
            if (item.count === 0) bagItems = bagItems.filter(i => i.resourceId !== '1021' && i.name !== itemName);
            applyRecruitCount(10);
            lastRecruitResult = runRecruitDraws(10);
            renderBagItems();
            renderPlayerHeroes();
            renderResourceGameplayList();
            syncEconomyGoldDisplay();
            savePlayerEconomyData();
            showMessage(`æ¶ˆè€—10å¼ ${itemName}ï¼Œ10è¿æŠ½å®Œæˆ`, 'success');
        };
        
        // æ‰§è¡Œæ‹›å‹Ÿï¼šæŠ½å…‰
        window.executeRecruitAll = function() {
            const itemName = getRecruitTicketName();
            const item = bagItems.find(item => item.resourceId === '1021' || item.name === itemName);
            if (!item || item.count === 0) {
                showMessage(`èƒŒåŒ…ä¸­æ²¡æœ‰${itemName}ï¼`, 'error');
                return;
            }
            const usedCount = item.count;
            bagItems = bagItems.filter(i => i.resourceId !== '1021' && i.name !== itemName);
            applyRecruitCount(usedCount);
            lastRecruitResult = runRecruitDraws(usedCount);
            renderBagItems();
            renderPlayerHeroes();
            renderResourceGameplayList();
            syncEconomyGoldDisplay();
            savePlayerEconomyData();
            showMessage(`æ¶ˆè€—${usedCount}å¼ ${itemName}ï¼ŒæŠ½å…‰å®Œæˆ`, 'success');
        };
        
        function syncEconomyGoldDisplay() {
            const el = document.getElementById('playerGold');
            if (el) el.value = playerResources.gold || 0;
            // é‡‘å¸å˜åŒ–æ—¶ï¼Œæ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆå› ä¸ºå¯èƒ½ä½¿ç”¨é‡‘å¸ä½œä¸ºææ–™ï¼‰
            renderResourceGameplayList();
        }
        
        // æ¸²æŸ“èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨
        function renderResourceGameplayList() {
            const listEl = document.getElementById('resourceGameplayList');
            if (!listEl) return;
            
            // æ›´æ–°èµ„æºæ¶ˆè€—ç©æ³•åˆ—è¡¨ä¸­çš„itemName
            updateResourceGameplayItemNames();
            
            if (resourceConsumptionGameplayList.length === 0) {
                listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">æš‚æ— èµ„æºæ¶ˆè€—ç©æ³•ï¼Œè¯·æ·»åŠ ç©æ³•</div>';
                return;
            }
            
            listEl.innerHTML = resourceConsumptionGameplayList.map(gameplay => {
                // è·å–èƒŒåŒ…ä¸­è¯¥é“å…·çš„æ•°é‡ï¼ˆæ”¯æŒæŒ‰resourceIdæˆ–nameæŸ¥æ‰¾ï¼‰
                let item = null;
                if (gameplay.type === 'recruit') {
                    item = bagItems.find(i => i.resourceId === '1021' || i.name === gameplay.itemName);
                } else {
                    item = bagItems.find(i => i.name === gameplay.itemName);
                }
                const itemCount = item ? item.count : 0;
                
                // å¦‚æœæ˜¯æ‹›å‹Ÿè§’è‰²ç©æ³•ï¼Œæ˜¾ç¤ºç‰¹æ®ŠæŒ‰é’®
                if (gameplay.type === 'recruit') {
                    const prog = getRecruitProgress();
                    const need = prog.neededForNext || 1;
                    const pct = prog.isMax ? 100 : Math.min(100, Math.floor((prog.currentProgress / need) * 100));
                    const progressBarHtml = prog.isMax
                        ? '<div style="font-size: 0.85em; color: #51cf66;">å·²æ»¡çº§</div>'
                        : `
                        <div style="margin-bottom: 4px; font-size: 0.85em; color: #666;">å‡çº§è¿›åº¦ï¼š${prog.currentProgress} / ${need} æ¬¡</div>
                        <div style="height: 10px; background: #e0e0e0; border-radius: 5px; overflow: hidden;">
                            <div style="height: 100%; width: ${pct}%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s;"></div>
                        </div>
                        `;
                    return `
                        <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333; font-size: 1em;">${gameplay.name}</div>
                                <button class="btn btn-danger" onclick="removeResourceGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                            </div>
                            <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                                æ¶ˆè€—é“å…·ï¼š<span style="color: #667eea; font-weight: 600;">${gameplay.itemName}</span>
                                <span style="margin-left: 10px;">æ‹¥æœ‰ï¼š<span style="color: ${itemCount > 0 ? '#51cf66' : '#ff6b6b'}; font-weight: 600;">${itemCount}</span> å¼ </span>
                            </div>
                            <div style="margin-bottom: 12px; padding: 10px; background: #f8f9ff; border-radius: 6px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px;">å½“å‰æ‹›å‹Ÿç­‰çº§ï¼š<span style="color: #667eea;">${prog.level}</span> çº§</div>
                                ${progressBarHtml}
                            </div>
                            ${(lastRecruitResult.heroes && lastRecruitResult.heroes.length > 0) || lastRecruitResult.gold > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: #e8f5e9; border-radius: 6px; border: 1px solid #51cf66;">
                                <div style="font-weight: 600; color: #2e7d32; font-size: 0.9em; margin-bottom: 6px;">æœ¬æ¬¡æ‹›å‹Ÿè·å¾—</div>
                                ${lastRecruitResult.heroes && lastRecruitResult.heroes.length > 0 ? `
                                <div style="margin-bottom: 6px;">
                                    ${lastRecruitResult.heroes.map(h => {
                                        const qualityNames = { 1: 'ç™½', 2: 'ç»¿', 3: 'è“', 4: 'ç´«', 5: 'æ©™', 6: 'çº¢' };
                                        const qualityName = qualityNames[h.quality] || 'ç™½';
                                        const qualityColor = getQualityTextColor(h.quality);
                                        return `<div style="font-size: 0.85em; color: #333; margin-bottom: 3px;">
                                            <span style="font-weight: 600; color: ${qualityColor};">${h.name}</span> 
                                            <span style="color: ${qualityColor}; font-size: 0.8em;">[${qualityName}]</span>
                                            <span style="color: #666;"> Ã— ${h.count}</span>
                                        </div>`;
                                    }).join('')}
                                </div>
                                ` : ''}
                                ${lastRecruitResult.gold > 0 ? `
                                <div style="font-size: 0.9em; color: #333;">é‡‘å¸ <span style="font-weight: 600; color: #ffc107;">${lastRecruitResult.gold}</span></div>
                                ` : ''}
                            </div>
                            ` : ''}
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                <button class="btn btn-primary" onclick="executeRecruitSingle()" style="padding: 8px; font-size: 0.85em;" ${itemCount < 1 ? 'disabled' : ''}>å•æŠ½ (1å¼ )</button>
                                <button class="btn btn-primary" onclick="executeRecruitTen()" style="padding: 8px; font-size: 0.85em;" ${itemCount < 10 ? 'disabled' : ''}>10è¿æŠ½ (10å¼ )</button>
                                <button class="btn btn-primary" onclick="executeRecruitAll()" style="padding: 8px; font-size: 0.85em;" ${itemCount === 0 ? 'disabled' : ''}>æŠ½å…‰ (${itemCount}å¼ )</button>
                            </div>
                        </div>
                    `;
                } else if (gameplay.type === 'equipSlotEnhance') {
                    // è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•
                    return renderEquipSlotEnhanceGameplay(gameplay);
                } else {
                    // æ™®é€šèµ„æºæ¶ˆè€—ç©æ³•
                    return `
                        <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333; font-size: 1em;">${gameplay.name}</div>
                                <button class="btn btn-danger" onclick="removeResourceGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                            </div>
                            <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                                æ¶ˆè€—é“å…·ï¼š<span style="color: #667eea; font-weight: 600;">${gameplay.itemName}</span>
                                <span style="margin-left: 10px;">æ‹¥æœ‰ï¼š<span style="color: ${itemCount > 0 ? '#51cf66' : '#ff6b6b'}; font-weight: 600;">${itemCount}</span></span>
                            </div>
                            <button class="btn btn-primary" onclick="executeResourceGameplay(${gameplay.id})" style="width: 100%; padding: 8px; font-size: 0.9em;" ${itemCount === 0 ? 'disabled' : ''}>æ‰§è¡Œç©æ³•</button>
                        </div>
                    `;
                }
            }).join('');
        }
        
        // è·å–èµ„æºæ•°é‡ï¼ˆæ ¸å¿ƒèµ„æºä»playerResourcesè·å–ï¼Œå…¶ä»–ä»bagItemsè·å–ï¼‰
        function getResourceCount(resourceId) {
            const resourceIdStr = String(resourceId);
            // æ ¸å¿ƒèµ„æºï¼š1001=é‡‘å¸, 1002=é’»çŸ³, 1003=ä½“åŠ›
            if (resourceIdStr === '1001') {
                return playerResources.gold || 0;
            } else if (resourceIdStr === '1002') {
                return playerResources.diamond || 0;
            } else if (resourceIdStr === '1003') {
                return playerResources.currentStamina || 0;
            } else {
                // å…¶ä»–èµ„æºä»èƒŒåŒ…è·å–
                const item = bagItems.find(i => i.resourceId === resourceIdStr);
                return item ? item.count : 0;
            }
        }
        
        // è·å–è£…å¤‡æ§½ä½å½“å‰ç­‰çº§çš„å±æ€§åŠ æˆï¼ˆä¸ç´¯åŠ ï¼Œåªå–å½“å‰ç­‰çº§ï¼‰
        function getEquipSlotCurrentAttributes(jobId, typeId, currentLevel) {
            if (!equipSlotLevelTable || currentLevel <= 0) {
                return { hp: 0, atk: 0, def: 0 };
            }
            
            // åªè·å–å½“å‰ç­‰çº§çš„æ•°æ®
            const levelData = equipSlotLevelTable.find(row => 
                row.type === typeId && row.heroClasses === jobId && row.slotLevel === currentLevel
            );
            
            if (levelData && levelData.attribute) {
                return {
                    hp: levelData.attribute.hp || 0,
                    atk: levelData.attribute.atk || 0,
                    def: levelData.attribute.def || 0
                };
            }
            return { hp: 0, atk: 0, def: 0 };
        }
        
        // è·å–è£…å¤‡æ§½ä½ç´¯è®¡å±æ€§åŠ æˆï¼ˆä»ç­‰çº§1åˆ°å½“å‰ç­‰çº§ç´¯åŠ ï¼‰
        function getEquipSlotTotalAttributes(jobId, typeId, currentLevel) {
            if (!equipSlotLevelTable || currentLevel <= 0) {
                return { hp: 0, atk: 0, def: 0 };
            }
            
            let totalAttrs = { hp: 0, atk: 0, def: 0 };
            for (let level = 1; level <= currentLevel; level++) {
                const levelData = equipSlotLevelTable.find(row => 
                    row.type === typeId && row.heroClasses === jobId && row.slotLevel === level
                );
                if (levelData && levelData.attribute) {
                    totalAttrs.hp += levelData.attribute.hp || 0;
                    totalAttrs.atk += levelData.attribute.atk || 0;
                    totalAttrs.def += levelData.attribute.def || 0;
                }
            }
            return totalAttrs;
        }
        
        // æ¸²æŸ“ä¸»é…ç½®è£…å¤‡å¼ºåŒ–é¢æ¿
        function renderMainConfigEquipSlotEnhancePanel() {
            const panel = document.getElementById('mainConfigEquipSlotEnhancePanel');
            if (!panel) return;
            
            if (!equipSlotLevelTable || equipSlotLevelTable.length === 0) {
                panel.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 20px;">è¯·å…ˆä¸Šä¼ è£…å¤‡è¡¨ï¼ˆåŒ…å«EquipSlotLevelé¡µç­¾ï¼‰</div>';
                return;
            }
            
            const typeNames = { 1: 'å¤´', 2: 'èº«', 3: 'æ‰‹', 4: 'è„š' };
            const jobNames = { 1: 'å¦å…‹', 2: 'æˆ˜å£«', 3: 'å°„æ‰‹', 4: 'è¾…åŠ©' };
            
            let html = '';
            
            // 4ä¸ªèŒä¸š
            for (let jobId = 1; jobId <= 4; jobId++) {
                let jobTotalHp = 0, jobTotalAtk = 0, jobTotalDef = 0;
                
                html += `
                    <div style="padding: 15px; background: #f8f9ff; border-radius: 8px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; color: #333; margin-bottom: 15px; text-align: center; font-size: 1em;">${jobNames[jobId]}</div>
                `;
                
                // 4ä¸ªéƒ¨ä½
                for (let typeId = 1; typeId <= 4; typeId++) {
                    const typeName = typeNames[typeId];
                    const currentLevel = mainConfigEquipSlotLevels[jobId] && mainConfigEquipSlotLevels[jobId][typeName] ? mainConfigEquipSlotLevels[jobId][typeName] : 0;
                    
                    // è·å–å½“å‰ç­‰çº§çš„å±æ€§åŠ æˆ
                    const currentAttrs = getEquipSlotCurrentAttributes(jobId, typeId, currentLevel);
                    const currentAttrsHtml = [];
                    if (currentAttrs.hp > 0) currentAttrsHtml.push(`è¡€é‡ +${currentAttrs.hp}`);
                    if (currentAttrs.atk > 0) currentAttrsHtml.push(`æ”»å‡» +${currentAttrs.atk}`);
                    if (currentAttrs.def > 0) currentAttrsHtml.push(`é˜²å¾¡ +${currentAttrs.def}`);
                    
                    // ç´¯åŠ åˆ°èŒä¸šæ€»åŠ æˆ
                    jobTotalHp += currentAttrs.hp;
                    jobTotalAtk += currentAttrs.atk;
                    jobTotalDef += currentAttrs.def;
                    
                    html += `
                        <div style="margin-bottom: 12px; padding: 10px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                            <div style="font-weight: 600; color: #333; font-size: 0.9em; margin-bottom: 6px;">${typeName}éƒ¨</div>
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <label style="font-size: 0.85em; color: #666; min-width: 50px;">ç­‰çº§ï¼š</label>
                                <input type="number" id="mainConfigEquipSlotLevel_${jobId}_${typeId}" 
                                    min="0" value="${currentLevel}" 
                                    onchange="updateMainConfigEquipSlotLevel(${jobId}, ${typeId}, this.value)"
                                    ${useEconomySimulation && mainConfigEconomySchemeId ? 'disabled' : ''}
                                    style="width: 80px; padding: 4px 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9em; text-align: center; ${useEconomySimulation && mainConfigEconomySchemeId ? 'background: #f5f5f5; cursor: not-allowed;' : ''}" />
                            </div>
                            ${useEconomySimulation && mainConfigEconomySchemeId ? `
                            <div style="font-size: 0.75em; color: #999; margin-top: 4px;">ï¼ˆæ¥è‡ªç»æµæ–¹æ¡ˆï¼‰</div>
                            ` : ''}
                            ${currentAttrsHtml.length > 0 ? `
                            <div style="font-size: 0.8em; color: #51cf66; padding: 4px; background: #f0f9f4; border-radius: 4px;">
                                å½“å‰åŠ æˆï¼š${currentAttrsHtml.join('ã€')}
                            </div>
                            ` : currentLevel === 0 ? `
                            <div style="font-size: 0.8em; color: #999; padding: 4px;">å½“å‰åŠ æˆï¼šæ— </div>
                            ` : ''}
                        </div>
                    `;
                }
                
                // æ˜¾ç¤ºèŒä¸šæ€»åŠ æˆ
                const jobTotalAttrsHtml = [];
                if (jobTotalHp > 0) jobTotalAttrsHtml.push(`è¡€é‡ +${jobTotalHp}`);
                if (jobTotalAtk > 0) jobTotalAttrsHtml.push(`æ”»å‡» +${jobTotalAtk}`);
                if (jobTotalDef > 0) jobTotalAttrsHtml.push(`é˜²å¾¡ +${jobTotalDef}`);
                
                html += `
                        <div style="margin-top: 10px; padding: 8px; background: #e8f5e9; border-radius: 6px; border: 1px solid #51cf66;">
                            <div style="font-weight: 600; color: #2e7d32; font-size: 0.9em; margin-bottom: 4px;">èŒä¸šæ€»åŠ æˆï¼š</div>
                            <div style="font-size: 0.85em; color: #2e7d32;">
                                ${jobTotalAttrsHtml.length > 0 ? jobTotalAttrsHtml.join('ã€') : 'æ— '}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            panel.innerHTML = html;
        }
        
        // æ›´æ–°ä¸»é…ç½®è£…å¤‡å¼ºåŒ–ç­‰çº§
        window.updateMainConfigEquipSlotLevel = function(jobId, typeId, value) {
            const typeNames = { 1: 'å¤´', 2: 'èº«', 3: 'æ‰‹', 4: 'è„š' };
            const typeName = typeNames[typeId];
            const level = Math.max(0, parseInt(value) || 0);
            
            if (!mainConfigEquipSlotLevels[jobId]) {
                mainConfigEquipSlotLevels[jobId] = {};
            }
            mainConfigEquipSlotLevels[jobId][typeName] = level;
            
            // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
            
            // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯
            for (let stage = 1; stage <= 20; stage++) {
                updateStageDamageInfo(stage);
            }
            
            // é‡æ–°æ¸²æŸ“è£…å¤‡å¼ºåŒ–é¢æ¿ï¼ˆæ›´æ–°æ˜¾ç¤ºï¼‰
            renderMainConfigEquipSlotEnhancePanel();
        };
        
        // æ¸²æŸ“è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•UI
        function renderEquipSlotEnhanceGameplay(gameplay) {
            if (!equipSlotLevelTable || equipSlotLevelTable.length === 0) {
                return `
                    <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: 600; color: #333; font-size: 1em;">${gameplay.name}</div>
                            <button class="btn btn-danger" onclick="removeResourceGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                        </div>
                        <div style="color: #999; text-align: center; padding: 20px;">è¯·å…ˆä¸Šä¼ è£…å¤‡è¡¨ï¼ˆåŒ…å«EquipSlotLevelé¡µç­¾ï¼‰</div>
                    </div>
                `;
            }
            
            const typeNames = { 1: 'å¤´', 2: 'èº«', 3: 'æ‰‹', 4: 'è„š' };
            const jobNames = { 1: 'å¦å…‹', 2: 'æˆ˜å£«', 3: 'å°„æ‰‹', 4: 'è¾…åŠ©' };
            
            let html = `
                <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; min-width: 1000px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="font-weight: 600; color: #333; font-size: 1.1em;">${gameplay.name}</div>
                        <button class="btn btn-danger" onclick="removeResourceGameplay(${gameplay.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px;">
            `;
            
            // 4ä¸ªèŒä¸š
            for (let jobId = 1; jobId <= 4; jobId++) {
                html += `
                    <div style="padding: 15px; background: #f8f9ff; border-radius: 8px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; color: #333; margin-bottom: 15px; text-align: center; font-size: 1em;">${jobNames[jobId]}</div>
                `;
                
                // 4ä¸ªéƒ¨ä½
                for (let typeId = 1; typeId <= 4; typeId++) {
                    const typeName = typeNames[typeId];
                    const currentLevel = equipSlotLevels[jobId] && equipSlotLevels[jobId][typeName] ? equipSlotLevels[jobId][typeName] : 0;
                    const nextLevel = currentLevel + 1;
                    
                    // è·å–å½“å‰ç­‰çº§çš„å±æ€§åŠ æˆï¼ˆä¸ç´¯åŠ ï¼‰
                    const currentAttrs = getEquipSlotCurrentAttributes(jobId, typeId, currentLevel);
                    const currentAttrsHtml = [];
                    if (currentAttrs.hp > 0) currentAttrsHtml.push(`è¡€é‡ +${currentAttrs.hp}`);
                    if (currentAttrs.atk > 0) currentAttrsHtml.push(`æ”»å‡» +${currentAttrs.atk}`);
                    if (currentAttrs.def > 0) currentAttrsHtml.push(`é˜²å¾¡ +${currentAttrs.def}`);
                    
                    // æŸ¥æ‰¾ä¸‹ä¸€çº§çš„æ•°æ®
                    const nextLevelData = equipSlotLevelTable.find(row => 
                        row.type === typeId && row.heroClasses === jobId && row.slotLevel === nextLevel
                    );
                    
                    html += `
                        <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                            <div style="font-weight: 600; color: #333; font-size: 0.95em; margin-bottom: 8px;">${typeName}éƒ¨</div>
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 8px;">
                                å½“å‰ç­‰çº§ï¼š<span style="color: #667eea; font-weight: 600; font-size: 1em;">${currentLevel}</span>
                            </div>
                            ${currentAttrsHtml.length > 0 ? `
                            <div style="font-size: 0.85em; color: #51cf66; margin-bottom: 8px; padding: 6px; background: #f0f9f4; border-radius: 4px;">
                                <div style="font-weight: 600; margin-bottom: 3px;">å½“å‰åŠ æˆï¼š</div>
                                <div>${currentAttrsHtml.join('ã€')}</div>
                            </div>
                            ` : currentLevel === 0 ? `
                            <div style="font-size: 0.85em; color: #999; margin-bottom: 8px; padding: 6px; background: #f5f5f5; border-radius: 4px;">
                                <div style="font-weight: 600; margin-bottom: 3px;">å½“å‰åŠ æˆï¼š</div>
                                <div>æ— </div>
                            </div>
                            ` : ''}
                    `;
                    
                    if (nextLevelData) {
                        // æ˜¾ç¤ºä¸‹ä¸€çº§éœ€è¦çš„ææ–™
                        const costItemsHtml = nextLevelData.costItems.map(cost => {
                            const resourceName = getResourceName(cost.resourceId) || cost.resourceId;
                            const itemCount = getResourceCount(cost.resourceId);
                            const hasEnough = itemCount >= cost.count;
                            return `
                                <div style="font-size: 0.85em; color: ${hasEnough ? '#51cf66' : '#ff6b6b'}; margin-bottom: 4px; padding: 3px 0;">
                                    ${resourceName} x${cost.count} <span style="color: #666;">(æ‹¥æœ‰: ${itemCount})</span>
                                </div>
                            `;
                        }).join('');
                        
                        // æ˜¾ç¤ºä¸‹ä¸€çº§å¢åŠ çš„å±æ€§
                        const nextAttrs = nextLevelData.attribute;
                        const nextAttrsHtml = [];
                        if (nextAttrs.hp > 0) nextAttrsHtml.push(`è¡€é‡ +${nextAttrs.hp}`);
                        if (nextAttrs.atk > 0) nextAttrsHtml.push(`æ”»å‡» +${nextAttrs.atk}`);
                        if (nextAttrs.def > 0) nextAttrsHtml.push(`é˜²å¾¡ +${nextAttrs.def}`);
                        
                        const canUpgrade = nextLevelData.costItems.every(cost => {
                            const itemCount = getResourceCount(cost.resourceId);
                            return itemCount >= cost.count;
                        });
                        
                        html += `
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 8px; padding: 6px; background: #f8f9ff; border-radius: 4px;">
                                <div style="font-weight: 600; margin-bottom: 4px; color: #333;">å‡çº§éœ€è¦ï¼š</div>
                                ${costItemsHtml}
                            </div>
                            <div style="font-size: 0.85em; color: #667eea; margin-bottom: 8px; padding: 6px; background: #f0f4ff; border-radius: 4px;">
                                <div style="font-weight: 600; margin-bottom: 3px;">ä¸‹ä¸€çº§åŠ æˆï¼š</div>
                                <div>${nextAttrsHtml.length > 0 ? nextAttrsHtml.join('ã€') : 'æ— '}</div>
                            </div>
                            <button class="btn btn-primary" onclick="upgradeEquipSlot(${jobId}, ${typeId})" style="width: 100%; padding: 6px 12px; font-size: 0.9em; font-weight: 600;" ${!canUpgrade ? 'disabled' : ''}>å¼ºåŒ–</button>
                        `;
                    } else {
                        html += `
                            <div style="font-size: 0.85em; color: #999; text-align: center; padding: 12px; background: #f5f5f5; border-radius: 4px;">å·²æ»¡çº§</div>
                        `;
                    }
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `
                    </div>
                </div>
            `;
            
            return html;
        }
        
        // å¼ºåŒ–è£…å¤‡æ§½ä½
        window.upgradeEquipSlot = function(jobId, typeId) {
            const typeNames = { 1: 'å¤´', 2: 'èº«', 3: 'æ‰‹', 4: 'è„š' };
            const typeName = typeNames[typeId];
            const currentLevel = equipSlotLevels[jobId] && equipSlotLevels[jobId][typeName] ? equipSlotLevels[jobId][typeName] : 0;
            const nextLevel = currentLevel + 1;
            
            // æŸ¥æ‰¾ä¸‹ä¸€çº§çš„æ•°æ®
            const nextLevelData = equipSlotLevelTable.find(row => 
                row.type === typeId && row.heroClasses === jobId && row.slotLevel === nextLevel
            );
            
            if (!nextLevelData) {
                showMessage('å·²è¾¾åˆ°æœ€å¤§ç­‰çº§', 'error');
                return;
            }
            
            // æ£€æŸ¥ææ–™æ˜¯å¦è¶³å¤Ÿ
            for (const cost of nextLevelData.costItems) {
                const itemCount = getResourceCount(cost.resourceId);
                if (itemCount < cost.count) {
                    const resourceName = getResourceName(cost.resourceId) || cost.resourceId;
                    showMessage(`ææ–™ä¸è¶³ï¼šéœ€è¦${resourceName} x${cost.count}`, 'error');
                    return;
                }
            }
            
            // æ¶ˆè€—ææ–™
            for (const cost of nextLevelData.costItems) {
                const resourceIdStr = String(cost.resourceId);
                // æ ¸å¿ƒèµ„æºï¼š1001=é‡‘å¸, 1002=é’»çŸ³, 1003=ä½“åŠ›
                if (resourceIdStr === '1001') {
                    playerResources.gold = (playerResources.gold || 0) - cost.count;
                    syncEconomyGoldDisplay();
                } else if (resourceIdStr === '1002') {
                    playerResources.diamond = (playerResources.diamond || 0) - cost.count;
                    const diamondInput = document.getElementById('playerDiamond');
                    if (diamondInput) diamondInput.value = playerResources.diamond;
                } else if (resourceIdStr === '1003') {
                    playerResources.currentStamina = (playerResources.currentStamina || 0) - cost.count;
                    const staminaInput = document.getElementById('playerCurrentStamina');
                    if (staminaInput) staminaInput.value = playerResources.currentStamina;
                } else {
                    // å…¶ä»–èµ„æºä»èƒŒåŒ…æ¶ˆè€—
                    const item = bagItems.find(i => i.resourceId === resourceIdStr);
                    if (item) {
                        item.count -= cost.count;
                        if (item.count <= 0) {
                            bagItems = bagItems.filter(i => i.resourceId !== resourceIdStr);
                        }
                    }
                }
            }
            
            // å‡çº§
            if (!equipSlotLevels[jobId]) equipSlotLevels[jobId] = {};
            equipSlotLevels[jobId][typeName] = nextLevel;
            
            // æ›´æ–°UI
            renderBagItems();
            renderResourceGameplayList();
            savePlayerEconomyData();
            
            const attrs = nextLevelData.attribute;
            const attrsText = [];
            if (attrs.hp > 0) attrsText.push(`è¡€é‡+${attrs.hp}`);
            if (attrs.atk > 0) attrsText.push(`æ”»å‡»+${attrs.atk}`);
            if (attrs.def > 0) attrsText.push(`é˜²å¾¡+${attrs.def}`);
            
            showMessage(`å¼ºåŒ–æˆåŠŸï¼${JOB_NAMES[jobId]}${typeName}éƒ¨æå‡åˆ°${nextLevel}çº§ï¼ˆ${attrsText.join('ã€')}ï¼‰`, 'success');
        };
        
        // æ‰§è¡Œæ™®é€šèµ„æºæ¶ˆè€—ç©æ³•
        window.executeResourceGameplay = function(gameplayId) {
            const gameplay = resourceConsumptionGameplayList.find(g => g.id === gameplayId);
            if (!gameplay) return;
            
            // æŸ¥æ‰¾èƒŒåŒ…ç‰©å“ï¼ˆæ”¯æŒæŒ‰resourceIdæˆ–nameæŸ¥æ‰¾ï¼‰
            let item = null;
            if (gameplay.type === 'recruit') {
                item = bagItems.find(i => i.resourceId === '1021' || i.name === gameplay.itemName);
            } else {
                item = bagItems.find(i => i.name === gameplay.itemName);
            }
            if (!item || item.count < 1) {
                showMessage(`èƒŒåŒ…ä¸­æ²¡æœ‰è¶³å¤Ÿçš„${gameplay.itemName}ï¼`, 'error');
                return;
            }
            
            item.count -= 1;
            if (item.count === 0) {
                if (gameplay.type === 'recruit') {
                    bagItems = bagItems.filter(i => i.resourceId !== '1021' && i.name !== gameplay.itemName);
                } else {
                    bagItems = bagItems.filter(i => i.name !== gameplay.itemName);
                }
            }
            
            renderBagItems();
            renderResourceGameplayList();
            savePlayerEconomyData();
            showMessage(`æ¶ˆè€—1ä¸ª${gameplay.itemName}ï¼Œæ‰§è¡Œ${gameplay.name}`, 'success');
        };
        
        // æ·»åŠ ç‰©å“åˆ°èƒŒåŒ…
        window.addItemToBag = function() {
            const resourceSelect = document.getElementById('newItemResourceSelect');
            const countInput = document.getElementById('newItemCount');
            
            if (!resourceSelect || !countInput) return;
            
            const resourceId = resourceSelect.value.trim();
            const count = parseInt(countInput.value) || 1;
            
            if (!resourceId) {
                showMessage('è¯·é€‰æ‹©èµ„æº', 'error');
                return;
            }
            
            // ä»ä¸‹æ‹‰æ¡†è·å–èµ„æºåç§°
            const selectedOption = resourceSelect.options[resourceSelect.selectedIndex];
            const resourceName = selectedOption ? (selectedOption.getAttribute('data-name') || selectedOption.textContent.split(' - ')[1] || '') : '';
            
            if (!resourceName) {
                showMessage('æ— æ³•è·å–èµ„æºåç§°', 'error');
                return;
            }
            
            // å¤„ç†æ ¸å¿ƒèµ„æºï¼ˆ1001=é‡‘å¸, 1002=é’»çŸ³, 1003=ä½“åŠ›ï¼‰ï¼šç›´æ¥æ›´æ–°ç©å®¶èµ„æºï¼Œä¸åŠ å…¥èƒŒåŒ…
            if (resourceId === '1001') {
                // é‡‘å¸
                playerResources.gold = (playerResources.gold || 0) + count;
                const goldInput = document.getElementById('playerGold');
                if (goldInput) goldInput.value = playerResources.gold;
                savePlayerEconomyData();
                showMessage(`å·²æ·»åŠ ${count}ä¸ª${resourceName}åˆ°ç©å®¶è´¦å·`, 'success');
                resourceSelect.value = '';
                countInput.value = '1';
                return;
            } else if (resourceId === '1002') {
                // é’»çŸ³
                playerResources.diamond = (playerResources.diamond || 0) + count;
                const diamondInput = document.getElementById('playerDiamond');
                if (diamondInput) diamondInput.value = playerResources.diamond;
                savePlayerEconomyData();
                showMessage(`å·²æ·»åŠ ${count}ä¸ª${resourceName}åˆ°ç©å®¶è´¦å·`, 'success');
                resourceSelect.value = '';
                countInput.value = '1';
                return;
            } else if (resourceId === '1003') {
                // ä½“åŠ›
                playerResources.currentStamina = (playerResources.currentStamina || 0) + count;
                const staminaInput = document.getElementById('playerCurrentStamina');
                if (staminaInput) staminaInput.value = playerResources.currentStamina;
                savePlayerEconomyData();
                showMessage(`å·²æ·»åŠ ${count}ä¸ª${resourceName}åˆ°ç©å®¶è´¦å·`, 'success');
                resourceSelect.value = '';
                countInput.value = '1';
                return;
            }
            
            // å…¶ä»–èµ„æºï¼šæ­£å¸¸æ·»åŠ åˆ°èƒŒåŒ…
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆæŒ‰èµ„æºidæˆ–åç§°åŒ¹é…ï¼‰
            const existingItem = bagItems.find(item => item.resourceId === resourceId || item.name === resourceName);
            if (existingItem) {
                existingItem.count += count;
                // æ›´æ–°èµ„æºidå’Œåç§°ï¼ˆå¦‚æœä¹‹å‰æ²¡æœ‰ï¼‰
                if (!existingItem.resourceId) existingItem.resourceId = resourceId;
                if (!existingItem.name) existingItem.name = resourceName;
            } else {
                bagItems.push({
                    id: Date.now(),
                    resourceId: resourceId,
                    name: resourceName,
                    count: count
                });
            }
            
            resourceSelect.value = '';
            countInput.value = '1';
            
            renderBagItems();
            renderResourceGameplayList(); // æ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆææ–™æ•°é‡å˜åŒ–ï¼‰
            savePlayerEconomyData();
            showMessage(`ç‰©å“"${resourceName}"å·²æ·»åŠ åˆ°èƒŒåŒ…`, 'success');
        };
        
        // æ¸…ç†èƒŒåŒ…ä¸­çš„æ ¸å¿ƒèµ„æºï¼ˆ1001=é‡‘å¸, 1002=é’»çŸ³, 1003=ä½“åŠ›ï¼‰
        function cleanupCoreResourcesFromBag() {
            const beforeCount = bagItems.length;
            bagItems = bagItems.filter(item => {
                const resourceId = item.resourceId || '';
                return resourceId !== '1001' && resourceId !== '1002' && resourceId !== '1003';
            });
            // å¦‚æœæ¸…ç†äº†ç‰©å“ï¼Œä¿å­˜æ•°æ®
            if (bagItems.length !== beforeCount) {
                savePlayerEconomyData();
            }
        }
        
        // ç§»é™¤èƒŒåŒ…ç‰©å“
        window.removeBagItem = function(itemId) {
            bagItems = bagItems.filter(item => item.id !== itemId);
            renderBagItems();
            renderResourceGameplayList(); // æ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆææ–™æ•°é‡å˜åŒ–ï¼‰
            savePlayerEconomyData();
            showMessage('ç‰©å“å·²ç§»é™¤', 'success');
        };
        
        // æ¸²æŸ“èƒŒåŒ…ç‰©å“åˆ—è¡¨
        function renderBagItems() {
            const listEl = document.getElementById('bagItemsList');
            if (listEl) {
                // è¿‡æ»¤æ‰æ ¸å¿ƒèµ„æºï¼ˆ1001=é‡‘å¸, 1002=é’»çŸ³, 1003=ä½“åŠ›ï¼‰ï¼Œè¿™äº›èµ„æºä¸åœ¨èƒŒåŒ…ä¸­æ˜¾ç¤º
                const filteredItems = bagItems.filter(item => {
                    const resourceId = item.resourceId || '';
                    return resourceId !== '1001' && resourceId !== '1002' && resourceId !== '1003';
                });
                
                if (filteredItems.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">èƒŒåŒ…ä¸ºç©º</div>';
                } else {
                    listEl.innerHTML = filteredItems.map(item => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: white; border: 1px solid #e0e0e0; border-radius: 6px; margin-bottom: 8px;">
                            <div>
                                <div style="font-weight: 600; color: #333;">${item.name}</div>
                                <div style="font-size: 0.85em; color: #666;">æ•°é‡ï¼š${item.count}</div>
                            </div>
                            <button class="btn btn-danger" onclick="removeBagItem(${item.id})" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                        </div>
                    `).join('');
                }
            }
            // èƒŒåŒ…ç‰©å“å˜åŒ–æ—¶ï¼Œæ›´æ–°æ‹›å‹Ÿè§’è‰²åŠŸèƒ½çš„æ‹›å‹Ÿåˆ¸æ•°é‡åŠä¸»çº¿å‰¯æœ¬æŒ‘æˆ˜æŒ‰é’®çŠ¶æ€
            renderResourceGameplayList(); // æ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆææ–™æ•°é‡å˜åŒ–ï¼‰
            renderGameplayList();
        }
        
        // æ›´æ–°è‹±é›„é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼ˆç”¨äºæ·»åŠ è‹±é›„ï¼‰
        function updateHeroSelects() {
            const addHeroSelect = document.getElementById('addHeroSelect');
            if (!addHeroSelect) return;
            
            addHeroSelect.innerHTML = '<option value="">é€‰æ‹©è‹±é›„ï¼ˆä»è‹±é›„è¡¨è¯»å–ï¼‰</option>';
            
            if (heroTable && heroTable.length > 0) {
                heroTable.forEach(hero => {
                    const option = document.createElement('option');
                    option.value = hero.id;
                    option.textContent = `${hero.namecn || hero.id} (${hero.id})`;
                    addHeroSelect.appendChild(option);
                });
            }
        }
        
        // æ·»åŠ ç©å®¶è‹±é›„
        window.addPlayerHero = function() {
            const heroSelect = document.getElementById('addHeroSelect');
            const levelInput = document.getElementById('addHeroLevel');
            
            if (!heroSelect || !levelInput) return;
            
            const heroId = heroSelect.value.trim();
            const level = parseInt(levelInput.value) || 1;
            
            if (!heroId) {
                showMessage('è¯·é€‰æ‹©è‹±é›„', 'error');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²æ‹¥æœ‰
            const existing = playerHeroes.find(h => h.heroId === heroId);
            if (existing) {
                existing.level = level;
                showMessage(`è‹±é›„${heroId}çš„ç­‰çº§å·²æ›´æ–°ä¸º${level}çº§`, 'success');
            } else {
                playerHeroes.push({ heroId: heroId, level: level });
                showMessage(`è‹±é›„${heroId}å·²æ·»åŠ ï¼Œç­‰çº§${level}çº§`, 'success');
            }
            
            heroSelect.value = '';
            levelInput.value = '1';
            
            renderPlayerHeroes();
            savePlayerEconomyData();
        };
        
        // ç§»é™¤ç©å®¶è‹±é›„
        window.removePlayerHero = function(heroId) {
            playerHeroes = playerHeroes.filter(h => h.heroId !== heroId);
            renderPlayerHeroes();
            savePlayerEconomyData();
            showMessage('è‹±é›„å·²ç§»é™¤', 'success');
        };
        
        // æ›´æ–°ç©å®¶è‹±é›„ç­‰çº§
        window.updatePlayerHeroLevel = function(heroId, newLevel) {
            const hero = playerHeroes.find(h => h.heroId === heroId);
            if (hero) {
                hero.level = parseInt(newLevel) || 1;
                renderPlayerHeroes();
                savePlayerEconomyData();
            }
        };
        
        // æ¸²æŸ“ç©å®¶è‹±é›„åˆ—è¡¨
        function renderPlayerHeroes() {
            const listEl = document.getElementById('playerHeroesList');
            if (!listEl) return;
            
            if (playerHeroes.length === 0) {
                listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">æš‚æ— è‹±é›„</div>';
                return;
            }
            
            listEl.innerHTML = playerHeroes.map(heroData => {
                const hero = heroTable.find(h => h.id === heroData.heroId);
                const heroName = hero ? hero.namecn : heroData.heroId;
                const heroLevel = heroData.level || 1;
                
                // è·å–è¯¥ç­‰çº§çš„å±æ€§
                let attrs = {};
                if (hero && hero.levels && hero.levels[heroLevel]) {
                    attrs = hero.levels[heroLevel];
                }
                
                // æ ¹æ®å“è´¨è®¾ç½®é¢œè‰²ï¼ˆ1=ç™½ï¼Œ2=ç»¿ï¼Œ3=è“ï¼Œ4=ç´«ï¼Œ5=æ©™ï¼Œ6=çº¢ï¼‰
                const qualityColors = {
                    1: { border: '#d0d0d0', bg: '#f5f5f5', text: '#666' }, // ç™½è‰²
                    2: { border: '#51cf66', bg: '#f0f9f4', text: '#2b8a3e' }, // ç»¿è‰²
                    3: { border: '#339af0', bg: '#e7f5ff', text: '#1864ab' }, // è“è‰²
                    4: { border: '#845ef7', bg: '#f3f0ff', text: '#5f3dc4' }, // ç´«è‰²
                    5: { border: '#ff922b', bg: '#fff4e6', text: '#d9480f' }, // æ©™è‰²
                    6: { border: '#ff6b6b', bg: '#ffe3e3', text: '#c92a2a' }  // çº¢è‰²
                };
                const qualityNames = { 1: 'ç™½', 2: 'ç»¿', 3: 'è“', 4: 'ç´«', 5: 'æ©™', 6: 'çº¢' };
                const heroQuality = hero ? (parseInt(hero.quality) || 1) : 1;
                const colors = qualityColors[heroQuality] || qualityColors[1];
                const qualityName = qualityNames[heroQuality] || 'ç™½';
                
                return `
                    <div style="background: ${colors.bg}; border: 2px solid ${colors.border}; border-radius: 8px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: 600; color: ${colors.text}; font-size: 1em;">${heroName} <span style="font-size: 0.75em; color: ${colors.border};">[${qualityName}]</span></div>
                            <button class="btn btn-danger" onclick="removePlayerHero('${heroData.heroId}')" style="padding: 4px 12px; font-size: 0.85em; background: #ff6b6b;">åˆ é™¤</button>
                        </div>
                        <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                            <div>è‹±é›„IDï¼š${heroData.heroId}</div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                                <span>ç­‰çº§ï¼š</span>
                                <span style="font-weight: 600; color: ${colors.text};">${heroLevel}</span>
                                ${heroLevel < 30 ? `<span style="color: #999; font-size: 0.85em;">/ 30</span>` : '<span style="color: #51cf66; font-size: 0.85em;">(æ»¡çº§)</span>'}
                            </div>
                            <div style="margin-top: 8px; padding: 8px; background: #f0f0f0; border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 0.85em;">å‡çº§è¿›åº¦ï¼š</span>
                                    <span style="font-weight: 600; color: #667eea;">${heroData.copies || 0}</span>
                                </div>
                                ${heroLevel < 30 ? (() => {
                                    const copiesNeeded = getCopiesNeededForLevel(heroLevel + 1);
                                    const copies = heroData.copies || 0;
                                    const pct = copiesNeeded > 0 ? Math.min(100, Math.floor((copies / copiesNeeded) * 100)) : 0;
                                    const canUpgrade = copies >= copiesNeeded;
                                    return `
                                        <div style="margin-bottom: 6px;">
                                            <div style="font-size: 0.8em; color: #666; margin-bottom: 3px;">
                                                å‡çº§åˆ° ${heroLevel + 1} çº§éœ€è¦ï¼š<span style="font-weight: 600;">${copiesNeeded}</span> ä¸ªæœ¬ä½“
                                            </div>
                                            <div style="height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                                                <div style="height: 100%; width: ${pct}%; background: ${canUpgrade ? 'linear-gradient(90deg, #51cf66, #40c057)' : 'linear-gradient(90deg, #667eea, #764ba2)'}; transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                        <button class="btn btn-primary" onclick="upgradePlayerHero('${heroData.heroId}')" 
                                            style="width: 100%; padding: 6px; font-size: 0.85em; ${canUpgrade ? '' : 'opacity: 0.5; cursor: not-allowed;'}" 
                                            ${canUpgrade ? '' : 'disabled'}>
                                            ${canUpgrade ? `å‡çº§åˆ° ${heroLevel + 1} çº§` : 'å‡çº§è¿›åº¦ä¸è¶³'}
                                        </button>
                                    `;
                                })() : '<div style="font-size: 0.8em; color: #51cf66;">å·²è¾¾åˆ°æœ€é«˜ç­‰çº§</div>'}
                            </div>
                            ${attrs.baseAttack || attrs.baseDefense || attrs.baseHp ? `
                            <div style="margin-top: 8px; padding: 8px; background: #f8f9ff; border-radius: 4px; font-size: 0.85em;">
                                ${attrs.baseAttack ? `<div>æ”»å‡»ï¼š${attrs.baseAttack}</div>` : ''}
                                ${attrs.baseDefense ? `<div>é˜²å¾¡ï¼š${attrs.baseDefense}</div>` : ''}
                                ${attrs.baseHp ? `<div>ç”Ÿå‘½ï¼š${attrs.baseHp}</div>` : ''}
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°è£…å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateEquipmentSelect() {
            const addEquipmentSelect = document.getElementById('addEquipmentSelect');
            if (!addEquipmentSelect) return;
            
            addEquipmentSelect.innerHTML = '<option value="">é€‰æ‹©è£…å¤‡ï¼ˆä»è£…å¤‡è¡¨è¯»å–ï¼‰</option>';
            
            if (equipmentTable && equipmentTable.length > 0) {
                equipmentTable.forEach(eq => {
                    const option = document.createElement('option');
                    option.value = eq.id;
                    option.textContent = `${eq.namecn || eq.id} (${eq.id})`;
                    addEquipmentSelect.appendChild(option);
                });
            }
        }
        
        // æ·»åŠ ç©å®¶è£…å¤‡
        window.addPlayerEquipment = function() {
            const equipmentSelect = document.getElementById('addEquipmentSelect');
            
            if (!equipmentSelect) return;
            
            const equipmentId = equipmentSelect.value.trim();
            
            if (!equipmentId) {
                showMessage('è¯·é€‰æ‹©è£…å¤‡', 'error');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²æ‹¥æœ‰ï¼ˆç»Ÿä¸€è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒï¼‰
            const equipmentIdStr = String(equipmentId);
            if (playerEquipment.includes(equipmentIdStr)) {
                showMessage('è¯¥è£…å¤‡å·²æ‹¥æœ‰', 'info');
                return;
            }
            
            playerEquipment.push(equipmentIdStr);
            equipmentSelect.value = '';
            
            renderPlayerOwnedEquipment();
            savePlayerEconomyData();
            showMessage(`è£…å¤‡${equipmentId}å·²æ·»åŠ `, 'success');
        };
        
        // ç§»é™¤ç©å®¶è£…å¤‡
        window.removePlayerEquipment = function(equipmentId) {
            // ç»Ÿä¸€è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
            const equipmentIdStr = String(equipmentId);
            playerEquipment = playerEquipment.filter(id => String(id) !== equipmentIdStr);
            renderPlayerOwnedEquipment();
            savePlayerEconomyData();
            showMessage('è£…å¤‡å·²ç§»é™¤', 'success');
        };
        
        // æ¸²æŸ“ç©å®¶å·²æ‹¥æœ‰è£…å¤‡é¢æ¿ï¼ˆåªæ˜¾ç¤ºå·²æ‹¥æœ‰çš„è£…å¤‡ï¼‰
        function renderPlayerOwnedEquipment() {
            const panelEl = document.getElementById('playerOwnedEquipmentPanel');
            if (!panelEl) {
                console.error('playerOwnedEquipmentPanel å…ƒç´ ä¸å­˜åœ¨');
                return;
            }
            
            console.log('renderPlayerOwnedEquipment - playerEquipment:', playerEquipment);
            console.log('renderPlayerOwnedEquipment - equipmentTable length:', equipmentTable ? equipmentTable.length : 0);
            
            if (!equipmentTable || equipmentTable.length === 0) {
                panelEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">è¯·å…ˆä¸Šä¼ è£…å¤‡è¡¨</div>';
                return;
            }
            
            if (playerEquipment.length === 0) {
                panelEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">æš‚æ— å·²æ‹¥æœ‰è£…å¤‡</div>';
                return;
            }
            
            // æŒ‰èŒä¸šåˆ†ç»„æ˜¾ç¤ºå·²æ‹¥æœ‰çš„è£…å¤‡
            const jobNames = { 1: 'å¦å…‹', 2: 'æˆ˜å£«', 3: 'å°„æ‰‹', 4: 'è¾…åŠ©' };
            const typeNames = { 'head': 'å¤´', 'body': 'èº«', 'hand': 'æ‰‹', 'foot': 'è„š' };
            
            let html = '';
            let totalOwnedCount = 0;
            
            // ç¡®ä¿ playerEquipment æ•°ç»„ä¸­çš„æ‰€æœ‰IDéƒ½æ˜¯å­—ç¬¦ä¸²æ ¼å¼
            const playerEquipmentStr = playerEquipment.map(id => String(id));
            console.log('renderPlayerOwnedEquipment - playerEquipmentStr:', playerEquipmentStr);
            
            // å…ˆæ‰¾å‡ºæ‰€æœ‰å·²æ‹¥æœ‰çš„è£…å¤‡ï¼ˆä¸æŒ‰èŒä¸šè¿‡æ»¤ï¼‰
            const allOwnedEquipments = equipmentTable.filter(eq => {
                const eqIdStr = String(eq.id);
                return playerEquipmentStr.includes(eqIdStr);
            });
            
            console.log('renderPlayerOwnedEquipment - æ‰€æœ‰å·²æ‹¥æœ‰è£…å¤‡æ•°é‡:', allOwnedEquipments.length);
            allOwnedEquipments.forEach(eq => {
                const parsedJob = parseInt(eq.heroclass) || 0;
                console.log(`å·²æ‹¥æœ‰è£…å¤‡: ID=${eq.id}, èŒä¸šåŸå§‹å€¼=${eq.heroclass} (ç±»å‹: ${typeof eq.heroclass}), è§£æå=${parsedJob}, ç±»å‹=${eq.type}, åç§°=${eq.namecn || eq.id}`);
            });
            
            // è¾…åŠ©å‡½æ•°ï¼šä»è£…å¤‡åç§°æ¨æ–­èŒä¸šï¼ˆ1=å¦å…‹ï¼Œ2=æˆ˜å£«ï¼Œ3=å°„æ‰‹ï¼Œ4=è¾…åŠ©ï¼‰
            function inferJobFromName(name) {
                if (!name) return 0;
                const nameStr = String(name).trim();
                if (nameStr.includes('å¦å…‹')) return 1;
                if (nameStr.includes('æˆ˜å£«')) return 2;
                if (nameStr.includes('å°„æ‰‹')) return 3;
                if (nameStr.includes('è¾…åŠ©')) return 4;
                return 0;
            }
            
            // æŒ‰èŒä¸šåˆ†ç»„
            for (let job = 1; job <= 4; job++) {
                // è·å–è¯¥èŒä¸šå·²æ‹¥æœ‰çš„è£…å¤‡
                // ç»Ÿä¸€è½¬æ¢ä¸ºæ•°å­—ç±»å‹è¿›è¡Œæ¯”è¾ƒï¼Œé¿å…ç±»å‹ä¸åŒ¹é…
                const ownedEquipments = allOwnedEquipments.filter(eq => {
                    // é¦–å…ˆå°è¯•ä» heroclass å­—æ®µè§£æ
                    let eqJob = parseInt(eq.heroclass) || 0;
                    
                    // å¦‚æœè§£æå¤±è´¥æˆ–ä¸º0ï¼Œå°è¯•ä»è£…å¤‡åç§°æ¨æ–­
                    if (eqJob === 0 && eq.namecn) {
                        eqJob = inferJobFromName(eq.namecn);
                    }
                    
                    // å¦‚æœè¿˜æ˜¯0ï¼Œå°è¯•ä»è£…å¤‡IDæ¨æ–­ï¼ˆIDæ ¼å¼å¦‚ï¼š13111001ï¼Œç¬¬3ä½å¯èƒ½æ˜¯èŒä¸šï¼‰
                    if (eqJob === 0 && eq.id) {
                        const idStr = String(eq.id).trim();
                        if (idStr.length >= 3) {
                            const thirdChar = parseInt(idStr[2]);
                            if (thirdChar >= 1 && thirdChar <= 4) {
                                eqJob = thirdChar;
                            }
                        }
                    }
                    
                    const matches = eqJob === job;
                    if (matches) {
                        console.log(`èŒä¸š ${job} åŒ¹é…è£…å¤‡: ID=${eq.id}, heroclass=${eq.heroclass} (è§£æä¸º${eqJob}), åç§°=${eq.namecn || eq.id}`);
                    }
                    return matches;
                });
                
                totalOwnedCount += ownedEquipments.length;
                console.log(`èŒä¸š ${job} (${jobNames[job]}) å·²æ‹¥æœ‰è£…å¤‡æ•°é‡: ${ownedEquipments.length}`);
                
                if (ownedEquipments.length === 0) continue;
                
                html += `
                    <div style="background: white; border: 2px solid #51cf66; border-radius: 8px; padding: 15px;">
                        <div style="font-weight: 600; color: #667eea; font-size: 1.1em; margin-bottom: 15px;">${jobNames[job] || 'æœªçŸ¥èŒä¸š'}</div>
                `;
                
                // æŒ‰éƒ¨ä½åˆ†ç»„
                const types = ['head', 'body', 'hand', 'foot'];
                const typeMapping = {
                    'head': ['head', 'å¤´', 'å¤´éƒ¨', 'å¤´ç›”'],
                    'body': ['body', 'èº«', 'èº«ä½“', 'èƒ¸ç”²', 'æŠ¤ç”²'],
                    'hand': ['hand', 'æ‰‹', 'æ‰‹éƒ¨', 'æ­¦å™¨'],
                    'foot': ['foot', 'è„š', 'è„šéƒ¨', 'é‹å­', 'é´å­']
                };
                
                types.forEach(type => {
                    // ç»Ÿä¸€è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒï¼Œå…¼å®¹å¤šç§éƒ¨ä½åç§°æ ¼å¼
                    const typeEquipments = ownedEquipments.filter(eq => {
                        const eqType = String(eq.type || '').trim().toLowerCase();
                        const validTypes = typeMapping[type];
                        const matches = validTypes.some(validType => eqType === validType.toLowerCase());
                        
                        if (matches) {
                            console.log(`éƒ¨ä½ ${type} åŒ¹é…è£…å¤‡: ID=${eq.id}, type=${eq.type}, åç§°=${eq.namecn || eq.id}`);
                        }
                        return matches;
                    });
                    
                    console.log(`èŒä¸š ${job} (${jobNames[job]}) éƒ¨ä½ ${type} å·²æ‹¥æœ‰è£…å¤‡æ•°é‡: ${typeEquipments.length}`);
                    
                    if (typeEquipments.length === 0) return;
                    
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="font-weight: 600; color: #333; margin-bottom: 8px; font-size: 0.95em;">${typeNames[type] || type}éƒ¨</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px;">
                    `;
                    
                    typeEquipments.forEach(eq => {
                        // æ ¹æ®å“è´¨è®¾ç½®é¢œè‰²ï¼ˆ1=ç™½ï¼Œ2=ç»¿ï¼Œ3=è“ï¼Œ4=ç´«ï¼Œ5=æ©™ï¼Œ6=çº¢ï¼‰
                        const qualityColors = {
                            1: { border: '#d0d0d0', bg: '#f5f5f5', text: '#666' }, // ç™½è‰²
                            2: { border: '#51cf66', bg: '#f0f9f4', text: '#2b8a3e' }, // ç»¿è‰²
                            3: { border: '#339af0', bg: '#e7f5ff', text: '#1864ab' }, // è“è‰²
                            4: { border: '#845ef7', bg: '#f3f0ff', text: '#5f3dc4' }, // ç´«è‰²
                            5: { border: '#ff922b', bg: '#fff4e6', text: '#d9480f' }, // æ©™è‰²
                            6: { border: '#ff6b6b', bg: '#ffe3e3', text: '#c92a2a' }  // çº¢è‰²
                        };
                        const qualityNames = { 1: 'ç™½', 2: 'ç»¿', 3: 'è“', 4: 'ç´«', 5: 'æ©™', 6: 'çº¢' };
                        const eqQuality = parseInt(eq.quality) || 1;
                        const colors = qualityColors[eqQuality] || qualityColors[1];
                        const qualityName = qualityNames[eqQuality] || 'ç™½';
                        
                        html += `
                            <div style="padding: 10px; border: 2px solid ${colors.border}; border-radius: 6px; background: ${colors.bg}; position: relative;">
                                <div style="font-size: 0.9em; font-weight: 600; color: ${colors.text}; margin-bottom: 4px;">${eq.namecn || eq.id} <span style="font-size: 0.75em; color: ${colors.border};">[${qualityName}]</span></div>
                                <div style="font-size: 0.75em; color: #666; margin-bottom: 4px;">${eq.id}</div>
                                ${eq.hp || eq.atk || eq.def ? `
                                <div style="font-size: 0.7em; color: #888; margin-top: 4px;">
                                    ${eq.hp ? `HP:${eq.hp} ` : ''}
                                    ${eq.atk ? `ATK:${eq.atk} ` : ''}
                                    ${eq.def ? `DEF:${eq.def}` : ''}
                                </div>
                                ` : ''}
                                <button class="btn btn-danger" onclick="removePlayerEquipment('${eq.id}')" style="position: absolute; top: 4px; right: 4px; padding: 2px 6px; font-size: 0.7em; background: #ff6b6b;">Ã—</button>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            console.log('renderPlayerOwnedEquipment - totalOwnedCount:', totalOwnedCount);
            console.log('renderPlayerOwnedEquipment - html length:', html.length);
            
            if (!html) {
                html = '<div style="color: #999; text-align: center; padding: 20px; grid-column: 1 / -1;">æš‚æ— å·²æ‹¥æœ‰è£…å¤‡</div>';
            }
            
            panelEl.innerHTML = html;
            console.log('renderPlayerOwnedEquipment - æ¸²æŸ“å®Œæˆï¼ŒpanelEl.innerHTML length:', panelEl.innerHTML.length);
            
            // å¼ºåˆ¶æ˜¾ç¤ºï¼Œç¡®ä¿å®¹å™¨å¯è§
            panelEl.style.display = 'grid';
            panelEl.style.minHeight = '100px';
            panelEl.style.visibility = 'visible';
        }
        
        // ç›‘å¬èµ„æºè¾“å…¥å˜åŒ–
        function setupEconomyInputListeners() {
            const staminaInput = document.getElementById('playerStamina');
            const currentStaminaInput = document.getElementById('playerCurrentStamina');
            const goldInput = document.getElementById('playerGold');
            const diamondInput = document.getElementById('playerDiamond');
            const levelInput = document.getElementById('playerLevel');
            const expInput = document.getElementById('playerExp');
            const expRequiredInput = document.getElementById('playerExpRequired');
            const dailyGoldInput = document.getElementById('playerDailyGold');
            const dailyDiamondInput = document.getElementById('playerDailyDiamond');
            const dailyRecruitInput = document.getElementById('playerDailyRecruitTickets');
            
            if (staminaInput) {
                staminaInput.addEventListener('change', function() {
                    playerResources.stamina = parseInt(this.value) || 100;
                    savePlayerEconomyData();
                });
            }
            
            if (currentStaminaInput) {
                currentStaminaInput.addEventListener('change', function() {
                    playerResources.currentStamina = parseInt(this.value) || 0;
                    savePlayerEconomyData();
                });
            }
            
            if (goldInput) {
                goldInput.addEventListener('change', function() {
                    playerResources.gold = parseInt(this.value) || 0;
                    renderResourceGameplayList(); // æ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆé‡‘å¸å¯èƒ½ä½œä¸ºææ–™ï¼‰
                    savePlayerEconomyData();
                });
            }
            
            if (diamondInput) {
                diamondInput.addEventListener('change', function() {
                    playerResources.diamond = parseInt(this.value) || 0;
                    renderResourceGameplayList(); // æ›´æ–°è£…å¤‡å¼ºåŒ–ç©æ³•æ˜¾ç¤ºï¼ˆé’»çŸ³å¯èƒ½ä½œä¸ºææ–™ï¼‰
                    savePlayerEconomyData();
                });
            }
            
            if (dailyGoldInput) {
                dailyGoldInput.addEventListener('change', function() {
                    playerResources.dailyGold = parseInt(this.value) || 0;
                    savePlayerEconomyData();
                });
            }
            if (dailyDiamondInput) {
                dailyDiamondInput.addEventListener('change', function() {
                    playerResources.dailyDiamond = parseInt(this.value) || 0;
                    savePlayerEconomyData();
                });
            }
            if (dailyRecruitInput) {
                dailyRecruitInput.addEventListener('change', function() {
                    playerResources.dailyRecruitTickets = parseInt(this.value) || 0;
                    savePlayerEconomyData();
                });
            }
            
            if (levelInput) {
                levelInput.addEventListener('change', function() {
                    playerAccount.level = parseInt(this.value) || 1;
                    savePlayerEconomyData();
                });
            }
            
            if (expInput) {
                expInput.addEventListener('change', function() {
                    playerAccount.exp = parseInt(this.value) || 0;
                    savePlayerEconomyData();
                });
            }
            
            if (expRequiredInput) {
                expRequiredInput.addEventListener('change', function() {
                    playerAccount.expRequired = parseInt(this.value) || 100;
                    savePlayerEconomyData();
                });
            }
        }

        // æ–¹æ¡ˆç®¡ç†
        const STORAGE_KEY = 'battleSimulatorSchemes';
        const MAX_SCHEMES = 10;
        let currentSchemeId = null;
        
        // 20æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆç®¡ç†
        const BATTLE_WAVE_STORAGE_KEY = 'battleSimulatorBattleWaveSchemes';
        const MAX_BATTLE_WAVE_SCHEMES = 8;
        let currentBattleWaveSchemeId = null;
        
        // ä¸»é…ç½®å…³è”ç©å®¶ç»æµæ¨¡æ‹Ÿ
        let useEconomySimulation = false;
        let mainConfigEconomySchemeId = null;
        
        function loadEconomySchemesForMain() {
            try {
                const raw = localStorage.getItem('battleSimulatorEconomySchemes');
                if (!raw) return [];
                const list = JSON.parse(raw);
                return Array.isArray(list) ? list : [];
            } catch (e) { return []; }
        }
        
        function getMainConfigEconomySchemeData() {
            if (!useEconomySimulation || !mainConfigEconomySchemeId) return null;
            const schemes = loadEconomySchemesForMain();
            const s = schemes.find(x => x.id === mainConfigEconomySchemeId);
            return s ? { playerHeroes: s.playerHeroes || [], playerEquipment: (s.playerEquipment || []).map(x => String(x)) } : null;
        }
        
        function updateMainConfigEconomySchemeSelect() {
            const wrap = document.getElementById('mainConfigEconomySchemeWrap');
            const sel = document.getElementById('mainConfigEconomySchemeSelect');
            const hint = document.getElementById('mainConfigEconomyHint');
            if (!sel) return;
            const schemes = loadEconomySchemesForMain();
            sel.innerHTML = '<option value="">é€‰æ‹©æ–¹æ¡ˆ...</option>';
            schemes.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.id;
                opt.textContent = s.name;
                if (s.id === mainConfigEconomySchemeId) opt.selected = true;
                sel.appendChild(opt);
            });
            if (wrap) wrap.style.display = useEconomySimulation ? 'flex' : 'none';
            if (hint) hint.style.display = useEconomySimulation ? 'block' : 'none';
        }
        
        window.toggleUseEconomySimulation = function() {
            const cb = document.getElementById('useEconomySimulationCheckbox');
            useEconomySimulation = !!(cb && cb.checked);
            if (!useEconomySimulation) {
                mainConfigEconomySchemeId = null;
                // å–æ¶ˆä½¿ç”¨ç»æµæ–¹æ¡ˆæ—¶ï¼Œé‡ç½®è£…å¤‡å¼ºåŒ–ç­‰çº§ä¸º0ï¼ˆæˆ–ä¿æŒå½“å‰å€¼ï¼Œæ ¹æ®éœ€æ±‚ï¼‰
                // è¿™é‡Œä¿æŒå½“å‰å€¼ï¼Œç”¨æˆ·å¯ä»¥æ‰‹åŠ¨ä¿®æ”¹
            } else if (mainConfigEconomySchemeId) {
                // å¦‚æœå·²é€‰æ‹©ç»æµæ–¹æ¡ˆï¼Œé‡æ–°åŠ è½½è£…å¤‡å¼ºåŒ–æ•°æ®
                const schemes = loadEconomySchemesForMain();
                const scheme = schemes.find(s => s.id === mainConfigEconomySchemeId);
                if (scheme && scheme.equipSlotLevels) {
                    mainConfigEquipSlotLevels = JSON.parse(JSON.stringify(scheme.equipSlotLevels));
                    // ç¡®ä¿ç»“æ„å®Œæ•´
                    for (let jobId = 1; jobId <= 4; jobId++) {
                        if (!mainConfigEquipSlotLevels[jobId]) mainConfigEquipSlotLevels[jobId] = {};
                        const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                        typeNames.forEach(typeName => {
                            if (mainConfigEquipSlotLevels[jobId][typeName] == null) mainConfigEquipSlotLevels[jobId][typeName] = 0;
                        });
                    }
                    
                    // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§
                    characters.forEach(char => {
                        applyJobEquipmentStats(char);
                    });
                    
                    // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
                    updateFinalAttributesPanel();
                    
                    // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯
                    for (let stage = 1; stage <= 20; stage++) {
                        updateStageDamageInfo(stage);
                    }
                }
            }
            updateMainConfigEconomySchemeSelect();
            updateAllCharacterHeroSelects();
            characters.forEach(c => updateCharacterHeroLevelSelect(c.id));
            updateJobEquipmentPanel();
            renderMainConfigEquipSlotEnhancePanel(); // åˆ·æ–°è£…å¤‡å¼ºåŒ–é¢æ¿ï¼ˆæ›´æ–°ç¦ç”¨çŠ¶æ€ï¼‰
            if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();
            if (typeof updatePlatformAttributes === 'function') updatePlatformAttributes();
        };
        
        window.onMainConfigEconomySchemeChange = function() {
            const sel = document.getElementById('mainConfigEconomySchemeSelect');
            mainConfigEconomySchemeId = (sel && sel.value) || null;
            
            // å¦‚æœé€‰æ‹©äº†ç»æµæ–¹æ¡ˆï¼Œè¯»å–è¯¥æ–¹æ¡ˆçš„è£…å¤‡å¼ºåŒ–æ•°æ®
            if (mainConfigEconomySchemeId && useEconomySimulation) {
                const schemes = loadEconomySchemesForMain();
                const scheme = schemes.find(s => s.id === mainConfigEconomySchemeId);
                if (scheme && scheme.equipSlotLevels) {
                    // å°†ç»æµæ–¹æ¡ˆçš„è£…å¤‡å¼ºåŒ–æ•°æ®åº”ç”¨åˆ°ä¸»é…ç½®
                    mainConfigEquipSlotLevels = JSON.parse(JSON.stringify(scheme.equipSlotLevels));
                    // ç¡®ä¿ç»“æ„å®Œæ•´
                    for (let jobId = 1; jobId <= 4; jobId++) {
                        if (!mainConfigEquipSlotLevels[jobId]) mainConfigEquipSlotLevels[jobId] = {};
                        const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                        typeNames.forEach(typeName => {
                            if (mainConfigEquipSlotLevels[jobId][typeName] == null) mainConfigEquipSlotLevels[jobId][typeName] = 0;
                        });
                    }
                    
                    // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§
                    characters.forEach(char => {
                        applyJobEquipmentStats(char);
                    });
                    
                    // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
                    updateFinalAttributesPanel();
                    
                    // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯
                    for (let stage = 1; stage <= 20; stage++) {
                        updateStageDamageInfo(stage);
                    }
                }
            }
            
            updateAllCharacterHeroSelects();
            characters.forEach(c => updateCharacterHeroLevelSelect(c.id));
            updateJobEquipmentPanel();
            renderMainConfigEquipSlotEnhancePanel(); // åˆ·æ–°è£…å¤‡å¼ºåŒ–é¢æ¿ï¼ˆæ›´æ–°ç¦ç”¨çŠ¶æ€ï¼‰
            
            // ä¸»é…ç½®ä¸­åŠ è½½ç»æµæ–¹æ¡ˆæ—¶æ‰§è¡Œä¸€é”®ä¸Šé˜µ
            if (mainConfigEconomySchemeId && useEconomySimulation) {
                if (typeof autoDeployHeroes === 'function') {
                    try {
                        autoDeployHeroes();
                    } catch (err) {
                        console.warn('æ‰§è¡Œä¸€é”®ä¸Šé˜µå¤±è´¥:', err);
                    }
                }
            }
            
            if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();
            if (typeof updatePlatformAttributes === 'function') updatePlatformAttributes();
        };
        
        // åŒæ­¥ä¸»é…ç½®ç»æµå…³è” UIï¼ˆå‹¾é€‰ã€ä¸‹æ‹‰ï¼‰ä¸å…¨å±€çŠ¶æ€
        function syncMainConfigEconomyUI() {
            const cb = document.getElementById('useEconomySimulationCheckbox');
            if (cb) cb.checked = useEconomySimulation;
            updateMainConfigEconomySchemeSelect();
        }
        
        // åˆ·æ–°ä¸»é…ç½®ä¸­ä½¿ç”¨çš„ç»æµæ–¹æ¡ˆæ•°æ®ï¼ˆå½“ç»æµæ–¹æ¡ˆæ›´æ–°æ—¶è°ƒç”¨ï¼‰
        function refreshMainConfigFromEconomyScheme() {
            // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨ç»æµæ–¹æ¡ˆï¼Œåˆ™åˆ·æ–°ç›¸å…³æ•°æ®
            if (useEconomySimulation && mainConfigEconomySchemeId) {
                const schemes = loadEconomySchemesForMain();
                const scheme = schemes.find(s => s.id === mainConfigEconomySchemeId);
                if (scheme && scheme.equipSlotLevels) {
                    // åˆ·æ–°è£…å¤‡å¼ºåŒ–æ•°æ®
                    mainConfigEquipSlotLevels = JSON.parse(JSON.stringify(scheme.equipSlotLevels));
                    // ç¡®ä¿ç»“æ„å®Œæ•´
                    for (let jobId = 1; jobId <= 4; jobId++) {
                        if (!mainConfigEquipSlotLevels[jobId]) mainConfigEquipSlotLevels[jobId] = {};
                        const typeNames = ['å¤´', 'èº«', 'æ‰‹', 'è„š'];
                        typeNames.forEach(typeName => {
                            if (mainConfigEquipSlotLevels[jobId][typeName] == null) mainConfigEquipSlotLevels[jobId][typeName] = 0;
                        });
                    }
                    
                    // é‡æ–°åº”ç”¨æ‰€æœ‰è§’è‰²çš„å±æ€§
                    characters.forEach(char => {
                        applyJobEquipmentStats(char);
                    });
                    
                    // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
                    updateFinalAttributesPanel();
                    
                    // æ›´æ–°æ‰€æœ‰å…³å¡çš„ä¼¤å®³ä¿¡æ¯
                    for (let stage = 1; stage <= 20; stage++) {
                        updateStageDamageInfo(stage);
                    }
                }
                
                updateAllCharacterHeroSelects();
                characters.forEach(c => updateCharacterHeroLevelSelect(c.id));
                updateJobEquipmentPanel();
                renderMainConfigEquipSlotEnhancePanel(); // åˆ·æ–°è£…å¤‡å¼ºåŒ–é¢æ¿
            }
            if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();
            if (typeof updatePlatformAttributes === 'function') updatePlatformAttributes();
        }
        
        // å…±äº«å­˜å‚¨é…ç½®
        const SHARED_GIST_ID_KEY = 'battleSimulatorSharedGistId';
        let sharedGistId = null;
        
        // åŠ è½½å…±äº«Gist ID
        function loadSharedGistId() {
            const saved = localStorage.getItem(SHARED_GIST_ID_KEY);
            if (saved) {
                sharedGistId = saved;
                document.getElementById('sharedGistId').value = sharedGistId;
            }
        }
        
        // ä¿å­˜å…±äº«Gist ID
        window.saveSharedGistId = function() {
            const gistId = document.getElementById('sharedGistId').value.trim();
            if (gistId) {
                sharedGistId = gistId;
                localStorage.setItem(SHARED_GIST_ID_KEY, gistId);
                showMessage('Gist IDå·²ä¿å­˜', 'success');
                updateSharedStorageStatus('å·²é…ç½®å…±äº«å­˜å‚¨');
            } else {
                sharedGistId = null;
                localStorage.removeItem(SHARED_GIST_ID_KEY);
                showMessage('å·²æ¸…é™¤Gist IDï¼Œå°†ä»…ä½¿ç”¨æœ¬åœ°å­˜å‚¨', 'info');
                updateSharedStorageStatus('æœªé…ç½®å…±äº«å­˜å‚¨');
            }
        };
        
        // æ›´æ–°å…±äº«å­˜å‚¨çŠ¶æ€æ˜¾ç¤º
        function updateSharedStorageStatus(message) {
            const statusEl = document.getElementById('sharedStorageStatus');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }
        
        // ä»GitHub Gistè¯»å–æ•°æ®
        async function readFromGist(gistId) {
            try {
                console.log('æ­£åœ¨ä»Gistè¯»å–æ•°æ®ï¼ŒGist ID:', gistId);
                const response = await fetch(`https://api.github.com/gists/${gistId}`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error('Gistä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥Gist IDæ˜¯å¦æ­£ç¡®');
                    } else if (response.status === 403) {
                        throw new Error('æ— æ³•è®¿é—®Gistï¼Œè¯·ç¡®ä¿Gistä¸ºå…¬å¼€çŠ¶æ€');
                    } else {
                        throw new Error(`æ— æ³•è®¿é—®Gistï¼ˆHTTP ${response.status}ï¼‰ï¼Œè¯·æ£€æŸ¥Gist IDæ˜¯å¦æ­£ç¡®`);
                    }
                }
                
                const gist = await response.json();
                console.log('Gistæ–‡ä»¶åˆ—è¡¨:', Object.keys(gist.files || {}));
                
                // æŸ¥æ‰¾æ•°æ®æ–‡ä»¶ï¼ˆé€šå¸¸å‘½åä¸º data.jsonï¼‰
                const files = Object.keys(gist.files || {});
                let dataFile = files.find(f => f.includes('data') || f.includes('json'));
                if (!dataFile && files.length > 0) {
                    dataFile = files[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ–‡ä»¶
                }
                
                if (!dataFile) {
                    throw new Error('Gistä¸­æ²¡æœ‰æ‰¾åˆ°æ•°æ®æ–‡ä»¶');
                }
                
                console.log('ä½¿ç”¨æ•°æ®æ–‡ä»¶:', dataFile);
                const content = gist.files[dataFile].content;
                
                if (!content) {
                    throw new Error('æ•°æ®æ–‡ä»¶å†…å®¹ä¸ºç©º');
                }
                
                // æ£€æŸ¥æ–‡ä»¶å¤§å°
                const contentSize = content.length;
                const sizeInMB = (contentSize / 1024 / 1024).toFixed(2);
                console.log('æ•°æ®æ–‡ä»¶å¤§å°:', sizeInMB, 'MB (', contentSize, 'å­—ç¬¦)');
                
                // æ£€æŸ¥æ˜¯å¦å¯èƒ½è¢«æˆªæ–­ï¼ˆGitHub Gist APIå¯èƒ½æˆªæ–­å¤§æ–‡ä»¶ï¼‰
                if (contentSize > 900000) { // æ¥è¿‘1MB
                    console.warn('è­¦å‘Šï¼šæ–‡ä»¶å¤§å°æ¥è¿‘æˆ–è¶…è¿‡1MBï¼Œå¯èƒ½è¢«æˆªæ–­');
                }
                
                // æ£€æŸ¥å†…å®¹æ˜¯å¦ä»¥å®Œæ•´çš„JSONç»“æŸ
                const trimmedContent = content.trim();
                const isComplete = trimmedContent.endsWith('}') || trimmedContent.endsWith(']');
                
                if (!isComplete && parseFloat(sizeInMB) > 0.8) {
                    // å°è¯•ä¿®å¤è¢«æˆªæ–­çš„JSONï¼ˆå¦‚æœæ¥è¿‘æ–‡ä»¶æœ«å°¾ï¼‰
                    console.warn('æ£€æµ‹åˆ°JSONå¯èƒ½è¢«æˆªæ–­ï¼Œå°è¯•ä¿®å¤...');
                    let fixedContent = trimmedContent;
                    
                    // å°è¯•æ‰¾åˆ°æœ€åä¸€ä¸ªå®Œæ•´çš„å¯¹è±¡æˆ–æ•°ç»„
                    let lastBrace = fixedContent.lastIndexOf('}');
                    let lastBracket = fixedContent.lastIndexOf(']');
                    let lastComplete = Math.max(lastBrace, lastBracket);
                    
                    if (lastComplete > fixedContent.length * 0.9) {
                        // å¦‚æœæœ€åä¸€ä¸ªå®Œæ•´å­—ç¬¦åœ¨90%ä¹‹åï¼Œå°è¯•è¡¥å…¨
                        if (lastBrace > lastBracket) {
                            // å¯èƒ½æ˜¯å¯¹è±¡è¢«æˆªæ–­
                            fixedContent = fixedContent.substring(0, lastBrace + 1);
                            // å°è¯•è¡¥å…¨å¤–å±‚çš„é—­åˆ
                            let openBraces = (fixedContent.match(/\{/g) || []).length;
                            let closeBraces = (fixedContent.match(/\}/g) || []).length;
                            if (openBraces > closeBraces) {
                                fixedContent += '}'.repeat(openBraces - closeBraces);
                            }
                        } else {
                            // å¯èƒ½æ˜¯æ•°ç»„è¢«æˆªæ–­
                            fixedContent = fixedContent.substring(0, lastBracket + 1);
                            // å°è¯•è¡¥å…¨å¤–å±‚çš„é—­åˆ
                            let openBrackets = (fixedContent.match(/\[/g) || []).length;
                            let closeBrackets = (fixedContent.match(/\]/g) || []).length;
                            if (openBrackets > closeBrackets) {
                                fixedContent += ']'.repeat(openBrackets - closeBrackets);
                            }
                        }
                        
                        console.log('å°è¯•ä½¿ç”¨ä¿®å¤åçš„JSON...');
                        try {
                            const parsedData = JSON.parse(fixedContent);
                            console.log('æˆåŠŸè§£æä¿®å¤åçš„JSONæ•°æ®ï¼Œå­—æ®µ:', Object.keys(parsedData));
                            showMessage('è­¦å‘Šï¼šæ•°æ®æ–‡ä»¶å¯èƒ½è¢«éƒ¨åˆ†æˆªæ–­ï¼Œå·²å°è¯•ä¿®å¤ã€‚å»ºè®®é‡æ–°ä¸Šä¼ å®Œæ•´æ•°æ®ã€‚', 'warning');
                            return parsedData;
                        } catch (fixError) {
                            console.warn('ä¿®å¤å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹å†…å®¹å°è¯•è§£æ');
                        }
                    }
                }
                
                try {
                    const parsedData = JSON.parse(content);
                    console.log('æˆåŠŸè§£æJSONæ•°æ®ï¼Œå­—æ®µ:', Object.keys(parsedData));
                    return parsedData;
                } catch (parseError) {
                    console.error('JSONè§£æå¤±è´¥:', parseError);
                    // å°è¯•æ‰¾åˆ°æˆªæ–­ä½ç½®
                    const errorMsg = parseError.message || '';
                    const lineMatch = errorMsg.match(/line (\d+)/);
                    const colMatch = errorMsg.match(/column (\d+)/);
                    
                    let detailedError = 'æ•°æ®æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼ˆä¸æ˜¯æœ‰æ•ˆçš„JSONï¼‰ï¼š' + parseError.message;
                    if (lineMatch && colMatch) {
                        const line = parseInt(lineMatch[1]);
                        const col = parseInt(colMatch[1]);
                        const lines = content.split('\n');
                        const lineContent = lines[line - 1] || '';
                        const beforeError = lineContent.substring(0, Math.min(col - 1, 50));
                        detailedError += `\n\né”™è¯¯ä½ç½®ï¼šç¬¬${line}è¡Œï¼Œç¬¬${col}åˆ—\né™„è¿‘å†…å®¹ï¼š${beforeError}...\n\næ–‡ä»¶å¤§å°ï¼š${sizeInMB} MB\n\nå¯èƒ½åŸå› ï¼š\n1. æ–‡ä»¶è¶…è¿‡GitHub Gistçš„1MBé™åˆ¶ï¼Œæ•°æ®è¢«æˆªæ–­\n2. JSONæ ¼å¼é”™è¯¯\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥ä¸Šä¼ çš„æ•°æ®å¤§å°\n2. å¦‚æœæ–‡ä»¶å¤ªå¤§ï¼Œåˆ é™¤ä¸€äº›ä¸å¿…è¦çš„æ•°æ®åé‡æ–°ä¸Šä¼ \n3. å°è¯•æ¸…ç†ç»æµæ–¹æ¡ˆä¸­çš„æ—§æ•°æ®`;
                    } else if (!isComplete) {
                        detailedError += `\n\næ–‡ä»¶å¤§å°ï¼š${sizeInMB} MB\næ–‡ä»¶æœªä»¥}æˆ–]ç»“å°¾ï¼Œå¯èƒ½è¢«æˆªæ–­\n\nå»ºè®®ï¼š\n1. é‡æ–°ä¸Šä¼ æ•°æ®ï¼ˆä½¿ç”¨ç´§å‡‘æ ¼å¼ï¼‰\n2. åˆ é™¤ä¸€äº›ä¸å¿…è¦çš„æ•°æ®ï¼ˆå¦‚æ—§æ–¹æ¡ˆã€æµ‹è¯•æ•°æ®ï¼‰\n3. æ¸…ç†ç»æµæ–¹æ¡ˆä¸­ä¸éœ€è¦çš„æ•°æ®`;
                    }
                    throw new Error(detailedError);
                }
            } catch (error) {
                console.error('è¯»å–Gistå¤±è´¥:', error);
                // å¦‚æœæ˜¯æˆ‘ä»¬æŠ›å‡ºçš„é”™è¯¯ï¼Œç›´æ¥æŠ›å‡ºï¼›å¦åˆ™åŒ…è£…ä¸€ä¸‹
                if (error.message) {
                    throw error;
                } else {
                    throw new Error('è¯»å–Gistæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼š' + String(error));
                }
            }
        }
        
        // å†™å…¥æ•°æ®åˆ°GitHub Gistï¼ˆéœ€è¦Personal Access Tokenï¼‰
        async function writeToGist(gistId, data, token) {
            try {
                // ä½¿ç”¨ç´§å‡‘æ ¼å¼ï¼ˆæ— ç¼©è¿›ï¼‰æ¥å‡å°æ–‡ä»¶å¤§å°
                const jsonString = JSON.stringify(data);
                const sizeInMB = (new Blob([jsonString]).size / 1024 / 1024).toFixed(2);
                console.log('å‡†å¤‡ä¸Šä¼ çš„æ•°æ®å¤§å°:', sizeInMB, 'MB (ç´§å‡‘æ ¼å¼)');
                
                if (parseFloat(sizeInMB) > 0.95) {
                    const confirm = window.confirm(`è­¦å‘Šï¼šæ•°æ®å¤§å° ${sizeInMB} MBï¼Œéå¸¸æ¥è¿‘GitHub Gistçš„1MBé™åˆ¶ã€‚\n\nå¦‚æœä¸Šä¼ å¤±è´¥ï¼Œå»ºè®®ï¼š\n1. åˆ é™¤ä¸€äº›ä¸å¿…è¦çš„æ•°æ®ï¼ˆå¦‚æ—§çš„æ–¹æ¡ˆã€æµ‹è¯•æ•°æ®ç­‰ï¼‰\n2. æ¸…ç†ç»æµæ–¹æ¡ˆä¸­ä¸éœ€è¦çš„æ•°æ®\n\næ˜¯å¦ç»§ç»­ä¸Šä¼ ï¼Ÿ`);
                    if (!confirm) {
                        throw new Error('ç”¨æˆ·å–æ¶ˆä¸Šä¼ ');
                    }
                }
                
                const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        files: {
                            'battle-simulator-data.json': {
                                content: jsonString
                            }
                        }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'å†™å…¥Gistå¤±è´¥');
                }
                
                return await response.json();
            } catch (error) {
                console.error('å†™å…¥Gistå¤±è´¥:', error);
                throw error;
            }
        }
        
        // ä»å…±äº«å­˜å‚¨åŒæ­¥æ•°æ®
        window.syncFromShared = async function() {
            if (!sharedGistId) {
                showMessage('è¯·å…ˆé…ç½®Gist ID', 'error');
                return;
            }
            
            updateSharedStorageStatus('æ­£åœ¨åŒæ­¥...');
            try {
                const sharedData = await readFromGist(sharedGistId);
                console.log('ä»å…±äº«å­˜å‚¨è¯»å–çš„æ•°æ®å­—æ®µ:', Object.keys(sharedData));
                
                let syncCount = 0;
                const syncMessages = [];
                
                // åŒæ­¥è£…å¤‡è¡¨
                if (sharedData.equipmentTable && Array.isArray(sharedData.equipmentTable)) {
                    equipmentTable = sharedData.equipmentTable;
                    localStorage.setItem(EQUIPMENT_STORAGE_KEY, JSON.stringify(equipmentTable));
                    updateEquipmentTableInfo();
                    updateJobEquipmentPanel();
                    syncCount++;
                    syncMessages.push(`è£…å¤‡è¡¨ï¼ˆ${equipmentTable.length}ä»¶ï¼‰`);
                    console.log('å·²åŒæ­¥è£…å¤‡è¡¨ï¼Œå…±', equipmentTable.length, 'ä»¶');
                }
                
                // åŒæ­¥è‹±é›„è¡¨
                if (sharedData.heroTable && Array.isArray(sharedData.heroTable)) {
                    heroTable = sharedData.heroTable;
                    localStorage.setItem(HERO_STORAGE_KEY, JSON.stringify(heroTable));
                    updateHeroTableInfo();
                    updateHeroSelect();
                    syncCount++;
                    syncMessages.push(`è‹±é›„è¡¨ï¼ˆ${heroTable.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥è‹±é›„è¡¨ï¼Œå…±', heroTable.length, 'ä¸ª');
                }
                
                // åŒæ­¥æ€ªç‰©è¡¨
                if (sharedData.monsterTable && Array.isArray(sharedData.monsterTable)) {
                    monsterTable = sharedData.monsterTable;
                    localStorage.setItem(MONSTER_STORAGE_KEY, JSON.stringify(monsterTable));
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects();
                    updateBattleWaveMonsterSelects(); // æ›´æ–°æ³¢æ¬¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
                    syncCount++;
                    syncMessages.push(`æ€ªç‰©è¡¨ï¼ˆ${monsterTable.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥æ€ªç‰©è¡¨ï¼Œå…±', monsterTable.length, 'ä¸ª');
                }
                
                // åŒæ­¥æ–¹æ¡ˆ
                if (sharedData.schemes && Array.isArray(sharedData.schemes)) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(sharedData.schemes));
                    renderSchemeList();
                    syncCount++;
                    syncMessages.push(`æ–¹æ¡ˆï¼ˆ${sharedData.schemes.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥æ–¹æ¡ˆï¼Œå…±', sharedData.schemes.length, 'ä¸ª');
                }
                
                // åŒæ­¥æ­¦å™¨æŠ€èƒ½å‡çº§è¡¨
                if (sharedData.weaponCostTable && Array.isArray(sharedData.weaponCostTable)) {
                    weaponCostTable = sharedData.weaponCostTable;
                    localStorage.setItem('weaponCostTable', JSON.stringify(weaponCostTable));
                    updateUpgradeTableInfo();
                    updateWeaponLevelViewerOptions();
                    syncCount++;
                    syncMessages.push(`æ­¦å™¨å‡çº§è¡¨ï¼ˆ${weaponCostTable.length}æ¡ï¼‰`);
                    console.log('å·²åŒæ­¥æ­¦å™¨å‡çº§è¡¨ï¼Œå…±', weaponCostTable.length, 'æ¡');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰æ­¦å™¨å‡çº§è¡¨æ•°æ®ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                if (sharedData.skillCostTable && Array.isArray(sharedData.skillCostTable)) {
                    skillCostTable = sharedData.skillCostTable;
                    localStorage.setItem('skillCostTable', JSON.stringify(skillCostTable));
                    updateUpgradeTableInfo();
                    syncCount++;
                    syncMessages.push(`æŠ€èƒ½å‡çº§è¡¨ï¼ˆ${skillCostTable.length}æ¡ï¼‰`);
                    console.log('å·²åŒæ­¥æŠ€èƒ½å‡çº§è¡¨ï¼Œå…±', skillCostTable.length, 'æ¡');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰æŠ€èƒ½å‡çº§è¡¨æ•°æ®ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                // åŒæ­¥25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆ
                if (sharedData.battleWaveSchemes && Array.isArray(sharedData.battleWaveSchemes)) {
                    localStorage.setItem(BATTLE_WAVE_STORAGE_KEY, JSON.stringify(sharedData.battleWaveSchemes));
                    updateBattleWaveSchemeSelect();
                    syncCount++;
                    syncMessages.push(`25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆï¼ˆ${sharedData.battleWaveSchemes.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆï¼Œå…±', sharedData.battleWaveSchemes.length, 'ä¸ª');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                // åŒæ­¥æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼ˆåŒ…å«ä¸‰ä¸ªéƒ¨åˆ†ï¼‰
                let recruitTableSynced = false;
                if (sharedData.recruitInfoTable && Array.isArray(sharedData.recruitInfoTable)) {
                    recruitInfoTable = sharedData.recruitInfoTable;
                    localStorage.setItem(RECRUIT_INFO_STORAGE_KEY, JSON.stringify(recruitInfoTable));
                    recruitTableSynced = true;
                    console.log('å·²åŒæ­¥æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼Œå…±', recruitInfoTable.length, 'æ¡');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                if (sharedData.recruitBoxLevelTable && Array.isArray(sharedData.recruitBoxLevelTable)) {
                    recruitBoxLevelTable = sharedData.recruitBoxLevelTable;
                    localStorage.setItem(RECRUIT_BOX_LEVEL_STORAGE_KEY, JSON.stringify(recruitBoxLevelTable));
                    recruitTableSynced = true;
                    console.log('å·²åŒæ­¥æ‹›å‹Ÿå¥–æ± ç­‰çº§è¡¨ï¼Œå…±', recruitBoxLevelTable.length, 'æ¡£');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰æ‹›å‹Ÿå¥–æ± ç­‰çº§è¡¨ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                if (sharedData.recruitPoolTable && Array.isArray(sharedData.recruitPoolTable)) {
                    recruitPoolTable = sharedData.recruitPoolTable;
                    localStorage.setItem(RECRUIT_POOL_STORAGE_KEY, JSON.stringify(recruitPoolTable));
                    recruitTableSynced = true;
                    console.log('å·²åŒæ­¥æ‹›å‹Ÿå¥–æ± è¡¨ï¼Œå…±', recruitPoolTable.length, 'æ¡');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰æ‹›å‹Ÿå¥–æ± è¡¨ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                if (recruitTableSynced) {
                    syncCount++;
                    syncMessages.push(`æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨ï¼ˆä¿¡æ¯${recruitInfoTable.length}æ¡ï¼Œç­‰çº§${recruitBoxLevelTable.length}æ¡£ï¼Œå¥–æ± ${recruitPoolTable.length}æ¡ï¼‰`);
                    // æ›´æ–°æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨çŠ¶æ€æ˜¾ç¤º
                    const status = document.getElementById('recruitInfoTableStatus');
                    const info = document.getElementById('recruitInfoTableInfo');
                    if (status) status.textContent = `å·²åŠ è½½æ‹›å‹Ÿè¡¨ ${recruitInfoTable.length} æ¡ï¼Œå¥–æ± ç­‰çº§ ${recruitBoxLevelTable.length} æ¡£ï¼ŒHeroPoolGroup ${recruitPoolTable.length} æ¡`;
                    if (info) info.innerHTML = `HeroBoxLevel: ${recruitBoxLevelTable.length} æ¡ï¼›HeroPoolGroup: ${recruitPoolTable.length} æ¡ï¼›æ‹›å‹Ÿä¿¡æ¯: ${recruitInfoTable.length} æ¡`;
                }
                
                // åŒæ­¥ç©å®¶è´¦å·ç­‰çº§è¡¨
                if (sharedData.accountLevelTable && Array.isArray(sharedData.accountLevelTable)) {
                    accountLevelTable = sharedData.accountLevelTable;
                    localStorage.setItem(ACCOUNT_LEVEL_TABLE_STORAGE_KEY, JSON.stringify(accountLevelTable));
                    syncCount++;
                    syncMessages.push(`ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼ˆ${accountLevelTable.length}æ¡ï¼‰`);
                    console.log('å·²åŒæ­¥ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼Œå…±', accountLevelTable.length, 'æ¡');
                    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                    const status = document.getElementById('accountLevelTableStatus');
                    const info = document.getElementById('accountLevelTableInfo');
                    if (status) status.textContent = `å·²åŠ è½½ç©å®¶è´¦å·ç­‰çº§è¡¨ ${accountLevelTable.length} æ¡`;
                    if (info) info.innerHTML = `å…± ${accountLevelTable.length} æ¡ï¼Œå‡åˆ°å„çº§æ‰€éœ€ç»éªŒå·²å¯¼å…¥`;
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰ç©å®¶è´¦å·ç­‰çº§è¡¨ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                // åŒæ­¥ç©å®¶ç»æµæ¨¡æ‹Ÿæ–¹æ¡ˆ
                if (sharedData.economySchemes && Array.isArray(sharedData.economySchemes)) {
                    localStorage.setItem(ECONOMY_SCHEMES_STORAGE_KEY, JSON.stringify(sharedData.economySchemes));
                    updateEconomySchemeSelect();
                    // å¦‚æœä¸»é…ç½®æ­£åœ¨ä½¿ç”¨ç»æµæ–¹æ¡ˆï¼Œåˆ·æ–°ä¸»é…ç½®æ•°æ®
                    refreshMainConfigFromEconomyScheme();
                    syncCount++;
                    syncMessages.push(`ç©å®¶ç»æµæ¨¡æ‹Ÿæ–¹æ¡ˆï¼ˆ${sharedData.economySchemes.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥ç©å®¶ç»æµæ¨¡æ‹Ÿæ–¹æ¡ˆï¼Œå…±', sharedData.economySchemes.length, 'ä¸ª');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰ç©å®¶ç»æµæ¨¡æ‹Ÿæ–¹æ¡ˆï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                // åŒæ­¥ç‰©å“è¡¨
                if (sharedData.resourceItemTable && Array.isArray(sharedData.resourceItemTable)) {
                    resourceItemTable = sharedData.resourceItemTable;
                    localStorage.setItem(RESOURCE_ITEM_STORAGE_KEY, JSON.stringify(resourceItemTable));
                    updateResourceSelect();
                    updateResourceLabels();
                    syncCount++;
                    syncMessages.push(`ç‰©å“è¡¨ï¼ˆ${resourceItemTable.length}ä¸ªï¼‰`);
                    console.log('å·²åŒæ­¥ç‰©å“è¡¨ï¼Œå…±', resourceItemTable.length, 'ä¸ª');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰ç‰©å“è¡¨æ•°æ®ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                // åŒæ­¥è£…å¤‡å¼ºåŒ–è¡¨
                if (sharedData.equipSlotLevelTable && Array.isArray(sharedData.equipSlotLevelTable)) {
                    equipSlotLevelTable = sharedData.equipSlotLevelTable;
                    localStorage.setItem(EQUIP_SLOT_LEVEL_STORAGE_KEY, JSON.stringify(equipSlotLevelTable));
                    // æ£€æŸ¥å¹¶æ·»åŠ è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•
                    const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
                    if (!hasEquipSlotEnhance && equipSlotLevelTable.length > 0) {
                        const maxId = resourceConsumptionGameplayList.length > 0 
                            ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                            : 0;
                        resourceConsumptionGameplayList.push({
                            id: maxId + 1,
                            name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                            itemName: '',
                            type: 'equipSlotEnhance'
                        });
                        savePlayerEconomyData();
                    }
                    renderResourceGameplayList();
                    renderMainConfigEquipSlotEnhancePanel();
                    syncCount++;
                    syncMessages.push(`è£…å¤‡å¼ºåŒ–è¡¨ï¼ˆ${equipSlotLevelTable.length}æ¡ï¼‰`);
                    console.log('å·²åŒæ­¥è£…å¤‡å¼ºåŒ–è¡¨ï¼Œå…±', equipSlotLevelTable.length, 'æ¡');
                } else {
                    console.log('å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰è£…å¤‡å¼ºåŒ–è¡¨æ•°æ®ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æ•°æ®ï¼‰');
                }
                
                if (syncCount > 0) {
                    showMessage(`åŒæ­¥æˆåŠŸï¼å·²åŠ è½½ï¼š${syncMessages.join('ã€')}`, 'success');
                    updateSharedStorageStatus('åŒæ­¥å®Œæˆ');
                } else {
                    showMessage('åŒæ­¥å®Œæˆï¼Œä½†å…±äº«å­˜å‚¨ä¸­æ²¡æœ‰å¯ç”¨çš„æ•°æ®', 'info');
                    updateSharedStorageStatus('æ— æ•°æ®å¯åŒæ­¥');
                }
            } catch (error) {
                console.error('åŒæ­¥å¤±è´¥è¯¦æƒ…:', error);
                const errorMsg = error.message || String(error);
                showMessage('åŒæ­¥å¤±è´¥ï¼š' + errorMsg + '\n\nè¯·æ£€æŸ¥ï¼š\n1. Gist IDæ˜¯å¦æ­£ç¡®\n2. Gistæ˜¯å¦ä¸ºå…¬å¼€çŠ¶æ€\n3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸', 'error');
                updateSharedStorageStatus('åŒæ­¥å¤±è´¥ï¼š' + errorMsg);
            }
        };
        
        // ä¸Šä¼ æ•°æ®åˆ°å…±äº«å­˜å‚¨
        window.syncToShared = async function() {
            if (!sharedGistId) {
                showMessage('è¯·å…ˆé…ç½®Gist ID', 'error');
                return;
            }
            
            // æç¤ºéœ€è¦Personal Access Token
            const token = prompt('è¯·è¾“å…¥GitHub Personal Access Tokenï¼ˆéœ€è¦repoæƒé™ï¼‰ï¼š\n\nåˆ›å»ºTokenï¼šhttps://github.com/settings/tokens\n\nå¦‚æœä¸æƒ³ä½¿ç”¨Tokenï¼Œå¯ä»¥æ‰‹åŠ¨å¤åˆ¶æ•°æ®åˆ°Gist');
            
            if (!token) {
                showMessage('å·²å–æ¶ˆä¸Šä¼ ', 'info');
                return;
            }
            
            updateSharedStorageStatus('æ­£åœ¨ä¸Šä¼ ...');
            try {
                // æ”¶é›†æ‰€æœ‰æ•°æ®
                const sharedData = {
                    equipmentTable: equipmentTable,
                    heroTable: heroTable,
                    monsterTable: monsterTable,
                    schemes: loadSchemes(),
                    // æ­¦å™¨æŠ€èƒ½å‡çº§è¡¨
                    weaponCostTable: weaponCostTable,
                    skillCostTable: skillCostTable,
                    // 25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆ
                    battleWaveSchemes: loadBattleWaveSchemes(),
                    // æ‹›å‹Ÿè§’è‰²ä¿¡æ¯è¡¨
                    recruitInfoTable: recruitInfoTable,
                    recruitBoxLevelTable: recruitBoxLevelTable,
                    recruitPoolTable: recruitPoolTable,
                    // ç©å®¶è´¦å·ç­‰çº§è¡¨
                    accountLevelTable: accountLevelTable,
                    // ç©å®¶ç»æµæ¨¡æ‹Ÿæ–¹æ¡ˆ
                    economySchemes: loadEconomySchemes(),
                    // ç‰©å“è¡¨
                    resourceItemTable: resourceItemTable,
                    // è£…å¤‡å¼ºåŒ–è¡¨
                    equipSlotLevelTable: equipSlotLevelTable,
                    lastUpdate: new Date().toISOString(),
                    version: VERSION
                };
                
                await writeToGist(sharedGistId, sharedData, token);
                
                showMessage('ä¸Šä¼ æˆåŠŸï¼æ‰€æœ‰æ•°æ®å·²ä¿å­˜åˆ°å…±äº«å­˜å‚¨', 'success');
                updateSharedStorageStatus('ä¸Šä¼ å®Œæˆ');
            } catch (error) {
                showMessage('ä¸Šä¼ å¤±è´¥ï¼š' + error.message, 'error');
                updateSharedStorageStatus('ä¸Šä¼ å¤±è´¥');
            }
        };

        // ä¿å­˜æ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.saveScheme = function() {
            let name = document.getElementById('schemeNameInput').value.trim();
            
            // åŠ è½½ç°æœ‰æ–¹æ¡ˆ
            const schemes = loadSchemes();
            
            // å¦‚æœè¾“å…¥æ¡†ä¸ºç©ºï¼Œä½†æœ‰å½“å‰é€‰ä¸­çš„æ–¹æ¡ˆï¼Œä½¿ç”¨å½“å‰æ–¹æ¡ˆçš„åç§°
            if (!name && currentSchemeId) {
                const existingScheme = schemes.find(s => s.id === currentSchemeId);
                if (existingScheme) {
                    name = existingScheme.name;
                    // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤º
                    document.getElementById('schemeNameInput').value = name;
                }
            }
            
            // å¦‚æœè¿˜æ˜¯æ²¡æœ‰åç§°ï¼Œæç¤ºç”¨æˆ·è¾“å…¥
            if (!name) {
                showMessage('è¯·è¾“å…¥æ–¹æ¡ˆåç§°', 'error');
                return;
            }

            // æ£€æŸ¥æ–¹æ¡ˆæ•°é‡
            if (schemes.length >= MAX_SCHEMES && !currentSchemeId) {
                showMessage(`æœ€å¤šåªèƒ½ä¿å­˜${MAX_SCHEMES}ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆåˆ é™¤ä¸€ä¸ª`, 'error');
                return;
            }

            // è·å–å½“å‰æ–¹æ¡ˆçš„æ­»äº¡æ—¶é—´ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            let lastDeathTime = null;
            if (currentSchemeId) {
                const existingScheme = schemes.find(s => s.id === currentSchemeId);
                if (existingScheme && existingScheme.lastDeathTime !== undefined) {
                    lastDeathTime = existingScheme.lastDeathTime;
                }
            }

            // å‡†å¤‡æ–¹æ¡ˆæ•°æ®
            // å…ˆä»ç•Œé¢è¯»å–æœ€æ–°çš„åŸºç¡€å±æ€§å€¼ï¼ˆå¦‚æœç”¨æˆ·æ‰‹åŠ¨ä¿®æ”¹äº†ï¼‰
            characters.forEach(char => {
                const card = document.querySelector(`[data-char-id="${char.id}"]`);
                if (card) {
                    const attackInput = card.querySelector('.char-attack');
                    const defenseInput = card.querySelector('.char-defense');
                    const hpInput = card.querySelector('.char-hp');
                    
                    if (attackInput) {
                        const inputValue = parseInt(attackInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseAttack = inputValue;
                        }
                    }
                    if (defenseInput) {
                        const inputValue = parseInt(defenseInput.value);
                        if (!isNaN(inputValue) && inputValue >= 0) {
                            char.baseDefense = inputValue;
                        }
                    }
                    if (hpInput) {
                        const inputValue = parseInt(hpInput.value);
                        if (!isNaN(inputValue) && inputValue > 0) {
                            char.baseHp = inputValue;
                            char.maxHp = inputValue;
                        }
                    }
                }
            });
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„å¹³å°å±æ€§é…ç½®
            platformConfig.heroCount = parseInt(document.getElementById('platformHeroCount').value) || 0;
            platformConfig.heroLevelSum = parseInt(document.getElementById('platformHeroLevelSum').value) || 0;
            platformConfig.attackCoeff = parseFloat(document.getElementById('platformAttackCoeff').value) || 0;
            platformConfig.defenseCoeff = parseFloat(document.getElementById('platformDefenseCoeff').value) || 0;
            platformConfig.hpCoeff = parseFloat(document.getElementById('platformHpCoeff').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„è½¦è¾†å±æ€§é…ç½®
            vehicleConfig.attack = parseInt(document.getElementById('vehicleAttack').value) || 0;
            vehicleConfig.defense = parseInt(document.getElementById('vehicleDefense').value) || 0;
            vehicleConfig.hp = parseInt(document.getElementById('vehicleHp').value) || 0;
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„å…³å¡é…ç½®
            for (let stage = 1; stage <= 20; stage++) {
                const monsterSelect = document.getElementById(`stage-${stage}-monster`);
                const atkSpeedInput = document.getElementById(`stage-${stage}-atkSpeed`);
                const damageCoeffInput = document.getElementById(`stage-${stage}-damageCoeff`);
                const hpCoeffInput = document.getElementById(`stage-${stage}-hpCoeff`);
                
                if (monsterSelect && atkSpeedInput && damageCoeffInput && hpCoeffInput) {
                    stageConfig[stage] = {
                        monsterId: monsterSelect.value || '',
                        atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                        damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                        hpCoeff: parseFloat(hpCoeffInput.value) || 0
                    };
                }
            }
            
            const schemeData = {
                id: currentSchemeId || Date.now().toString(),
                name: name,
                saveTime: new Date().toISOString(),
                // ä¿å­˜è§’è‰²é¢æ¿ä¿¡æ¯
                characters: characters.map(char => ({
                    id: char.id, // è§’è‰²ID
                    name: char.name, // è§’è‰²åç§°
                    job: char.job, // èŒä¸š
                    // åŸºç¡€å±æ€§ï¼ˆä»è§’è‰²å¯¹è±¡ä¸­è·å–ï¼Œå·²åŒ…å«æ‰‹åŠ¨ä¿®æ”¹çš„å€¼ï¼‰
                    baseAttack: char.baseAttack || char.attack || 20, // åŸºç¡€æ”»å‡»åŠ›
                    baseDefense: char.baseDefense || char.defense || 10, // åŸºç¡€é˜²å¾¡åŠ›
                    baseHp: char.baseHp || char.hp || 100, // åŸºç¡€è¡€é‡
                    // æœ€ç»ˆå±æ€§ï¼ˆåŒ…å«è£…å¤‡åŠ æˆï¼‰
                    attack: char.attack || char.baseAttack || 20,
                    defense: char.defense || char.baseDefense || 10,
                    hp: char.hp || char.baseHp || 100,
                    maxHp: char.maxHp || char.baseHp || 100,
                    // è‹±é›„é€‰æ‹©ä¿¡æ¯
                    selectedHeroId: char.selectedHeroId || null, // é€‰æ‹©çš„è‹±é›„ID
                    selectedHeroLevel: char.selectedHeroLevel || null, // é€‰æ‹©çš„è‹±é›„ç­‰çº§
                    // èŒä¸šç‰¹æ®Šå±æ€§ç³»æ•°
                    healRate: char.healRate || 0, // å›è¡€é€Ÿåº¦ï¼ˆè§’è‰²5ï¼‰
                    damageReduction: char.damageReduction || 0, // å‡ä¼¤ç™¾åˆ†æ¯”ï¼ˆè§’è‰²1ï¼‰
                    skillDamage: char.skillDamage || 0 // æŠ€èƒ½ä¼¤å®³ç³»æ•°ï¼ˆè§’è‰²2ã€3ã€4ï¼‰
                })),
                // ä¿å­˜è£…å¤‡é¢æ¿ä¿¡æ¯ï¼ˆèŒä¸šè£…å¤‡é…ç½®ï¼‰
                characterEquipment: JSON.parse(JSON.stringify(characterEquipment)),
                // ä¿å­˜å¹³å°å±æ€§é…ç½®
                platformConfig: JSON.parse(JSON.stringify(platformConfig)),
                // ä¿å­˜å¹³å°å±æ€§ï¼ˆè½¦è¾†ï¼‰é…ç½®
                vehicleConfig: JSON.parse(JSON.stringify(vehicleConfig)),
            // ä¿å­˜å…³å¡é…ç½®
            stageConfig: JSON.parse(JSON.stringify(stageConfig)),
            // ä¿å­˜å½“å‰é€‰æ‹©çš„25æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆID
            battleWaveSchemeId: currentBattleWaveSchemeId || null,
            // ä¸»é…ç½®å…³è”ç©å®¶ç»æµæ¨¡æ‹Ÿï¼ˆä»ç•Œé¢è¯»å–æœ€æ–°çŠ¶æ€ï¼‰
            useEconomySimulation: (function() {
                const cb = document.getElementById('useEconomySimulationCheckbox');
                return cb ? cb.checked : useEconomySimulation;
            })(),
            economySchemeId: (function() {
                const sel = document.getElementById('mainConfigEconomySchemeSelect');
                return (sel && sel.value) ? sel.value : (mainConfigEconomySchemeId || null);
            })(),
            
            // ä»ç•Œé¢è¯»å–æœ€æ–°çš„20æ³¢æ€ªç‰©æ•°æ®è¾“å…¥é…ç½®
            // ç¡®ä¿ä¿å­˜æ—¶è¯»å–ç•Œé¢ä¸Šçš„æœ€æ–°å€¼
            battleWaveData: (function() {
                const latestBattleWaveData = {};
                for (let wave = 1; wave <= 25; wave++) {
                    const monsterSelect = document.getElementById(`battle-wave-${wave}-monster`);
                    const attackInput = document.getElementById(`battle-wave-${wave}-attack`);
                    const defenseInput = document.getElementById(`battle-wave-${wave}-defense`);
                    const hpInput = document.getElementById(`battle-wave-${wave}-hp`);
                    const atkSpeedInput = document.getElementById(`battle-wave-${wave}-atkSpeed`);
                    const damageCoeffInput = document.getElementById(`battle-wave-${wave}-damageCoeff`);
                    const hpCoeffInput = document.getElementById(`battle-wave-${wave}-hpCoeff`);
                    const spawnRateInput = document.getElementById(`battle-wave-${wave}-spawnRate`);
                    const durationInput = document.getElementById(`battle-wave-${wave}-duration`);
                    const coinRewardInput = document.getElementById(`battle-wave-${wave}-coinReward`);
                    
                    if (monsterSelect && attackInput && defenseInput && hpInput && 
                        atkSpeedInput && damageCoeffInput && hpCoeffInput &&
                        spawnRateInput && durationInput) {
                        latestBattleWaveData[wave] = {
                            monsterId: monsterSelect.value || '',
                            attack: parseFloat(attackInput.value) || 10,
                            defense: parseFloat(defenseInput.value) || 5,
                            hp: parseFloat(hpInput.value) || 50,
                            atkSpeed: parseFloat(atkSpeedInput.value) || 0.33,
                            damageCoeff: parseFloat(damageCoeffInput.value) || 1,
                            hpCoeff: parseFloat(hpCoeffInput.value) || 1,
                            spawnRate: parseFloat(spawnRateInput.value) || 1,
                            duration: parseFloat(durationInput.value) || 10,
                            coinReward: coinRewardInput ? (parseFloat(coinRewardInput.value) || 0) : 0
                        };
                    } else {
                        // å¦‚æœç•Œé¢å…ƒç´ ä¸å­˜åœ¨ï¼Œä½¿ç”¨å†…å­˜ä¸­çš„æ•°æ®
                        latestBattleWaveData[wave] = battleWaveData[wave] || {
                            monsterId: '',
                            attack: 10,
                            defense: 5,
                            hp: 50,
                            atkSpeed: 0.33,
                            damageCoeff: 1,
                            hpCoeff: 1,
                            spawnRate: 1,
                            duration: 10,
                            coinReward: 0
                        };
                    }
                }
                return latestBattleWaveData;
            })(),
                // ä¿å­˜æ€ªç‰©å±æ€§
                monsterConfig: {
                    spawnRate: parseFloat(document.getElementById('spawnRate').value) || 1, // åˆ·æ–°é€Ÿåº¦
                    attack: parseInt(document.getElementById('monsterAttack').value) || 10, // æ”»å‡»åŠ›
                    defense: parseInt(document.getElementById('monsterDefense').value) || 5, // é˜²å¾¡åŠ›
                    hp: parseInt(document.getElementById('monsterHp').value) || 50, // è¡€é‡
                    atkSpeed: parseFloat(document.getElementById('monsterAtkSpeed').value) || 1, // æ”»å‡»é€Ÿåº¦
                    damageCoeff: parseFloat(document.getElementById('monsterDamageCoeff').value) || 1, // æ”»å‡»ç³»æ•°
                    hpCoeff: parseFloat(document.getElementById('monsterHpCoeff').value) || 0 // è¡€é‡ç³»æ•°
                },
                lastDeathTime: lastDeathTime // ä¿å­˜ä¸Šæ¬¡çš„æ­»äº¡æ—¶é—´
            };

            // å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°ï¼›å¦åˆ™æ·»åŠ 
            if (currentSchemeId) {
                const existingIndex = schemes.findIndex(s => s.id === currentSchemeId);
                if (existingIndex >= 0) {
                    schemes[existingIndex] = schemeData;
                } else {
                    // å¦‚æœIDå­˜åœ¨ä½†åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°ï¼Œç›´æ¥æ·»åŠ ï¼ˆå¯èƒ½æ˜¯æ•°æ®ä¸åŒæ­¥ï¼‰
                    schemes.push(schemeData);
                }
            } else {
                schemes.push(schemeData);
            }

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));

            // è°ƒè¯•ï¼šè¾“å‡ºä¿å­˜çš„æ–¹æ¡ˆä¿¡æ¯
            console.log('ä¿å­˜æ–¹æ¡ˆ:', {
                name: schemeData.name,
                characters: schemeData.characters.map(c => ({
                    id: c.id,
                    job: c.job,
                    heroId: c.selectedHeroId,
                    heroLevel: c.selectedHeroLevel,
                    baseAttack: c.baseAttack,
                    baseDefense: c.baseDefense,
                    baseHp: c.baseHp,
                    damageReduction: c.damageReduction,
                    skillDamage: c.skillDamage,
                    healRate: c.healRate
                })),
                equipment: schemeData.characterEquipment,
                platformConfig: schemeData.platformConfig,
                vehicleConfig: schemeData.vehicleConfig,
                monster: schemeData.monsterConfig
            });

            // æ›´æ–°å½“å‰æ–¹æ¡ˆID
            currentSchemeId = schemeData.id;

            // åˆ·æ–°æ–¹æ¡ˆåˆ—è¡¨
            renderSchemeList();

            // ä¸æ¸…ç©ºè¾“å…¥æ¡†ï¼Œä¿ç•™æ–¹æ¡ˆåç§°ï¼Œæ–¹ä¾¿ç”¨æˆ·ç»§ç»­ä¿®æ”¹å¹¶ä¿å­˜
            // å¦‚æœç”¨æˆ·æƒ³åˆ›å»ºæ–°æ–¹æ¡ˆï¼Œå¯ä»¥ç‚¹å‡»"æ–°å»ºæ–¹æ¡ˆ"æŒ‰é’®

            showMessage(`æ–¹æ¡ˆ"${name}"å·²ä¿å­˜`, 'success');
        };

        // åŠ è½½æ–¹æ¡ˆåˆ—è¡¨
        function loadSchemes() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('åŠ è½½æ–¹æ¡ˆå¤±è´¥:', error);
                return [];
            }
        }

        // åŠ è½½æ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.loadScheme = function(schemeId) {
            const schemes = loadSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            if (!scheme) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }

            // åŠ è½½è§’è‰²é…ç½®
            scheme.characters.forEach((charData, index) => {
                if (characters[index]) {
                    // åŠ è½½èŒä¸šï¼ˆå¦‚æœå­˜åœ¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                    if (charData.job) {
                        characters[index].job = charData.job;
                    } else {
                        // å…¼å®¹æ—§æ–¹æ¡ˆï¼Œè®¾ç½®é»˜è®¤èŒä¸š
                        if (index === 0) characters[index].job = JOB_TYPES.TANK;
                        else if (index === 1) characters[index].job = JOB_TYPES.WARRIOR;
                        else if (index === 2 || index === 3) characters[index].job = JOB_TYPES.ARCHER;
                        else if (index === 4) characters[index].job = JOB_TYPES.SUPPORT;
                    }
                    
                    // åŠ è½½è‹±é›„é€‰æ‹©ä¿¡æ¯ï¼ˆå¿…é¡»åœ¨åŠ è½½åŸºç¡€å±æ€§ä¹‹å‰ï¼‰
                    if (charData.selectedHeroId !== undefined) {
                        characters[index].selectedHeroId = charData.selectedHeroId || null;
                    }
                    if (charData.selectedHeroLevel !== undefined) {
                        characters[index].selectedHeroLevel = charData.selectedHeroLevel || null;
                    }
                    
                    // åŠ è½½åŸºç¡€å±æ€§ï¼ˆå…¼å®¹æ—§æ–¹æ¡ˆï¼‰
                    // å¦‚æœæœ‰é€‰æ‹©çš„è‹±é›„å’Œç­‰çº§ï¼ŒåŸºç¡€å±æ€§ä¼šä»è‹±é›„æ•°æ®ä¸­è·å–ï¼Œå¦åˆ™ä½¿ç”¨ä¿å­˜çš„å€¼
                    if (!charData.selectedHeroId || !charData.selectedHeroLevel) {
                        characters[index].baseAttack = charData.baseAttack || charData.attack || 20;
                        characters[index].baseDefense = charData.baseDefense || charData.defense || 10;
                        characters[index].baseHp = charData.baseHp || charData.hp || 100;
                    }
                    
                    // åŠ è½½èŒä¸šç‰¹æ®Šå±æ€§ç³»æ•°
                    characters[index].healRate = charData.healRate !== undefined ? charData.healRate : 0;
                    characters[index].damageReduction = charData.damageReduction !== undefined ? charData.damageReduction : 0;
                    characters[index].skillDamage = charData.skillDamage !== undefined ? charData.skillDamage : 0;
                }
            });
            
            // åŠ è½½èŒä¸šè£…å¤‡é…ç½®ï¼ˆè£…å¤‡é¢æ¿ä¿¡æ¯ï¼‰
            if (scheme.characterEquipment) {
                characterEquipment = JSON.parse(JSON.stringify(scheme.characterEquipment));
                saveCharacterEquipment();
            } else {
                // å¦‚æœæ²¡æœ‰è£…å¤‡é…ç½®ï¼Œåˆå§‹åŒ–é»˜è®¤é…ç½®
                characterEquipment = {
                    1: { head: null, body: null, hand: null, foot: null },
                    2: { head: null, body: null, hand: null, foot: null },
                    3: { head: null, body: null, hand: null, foot: null },
                    4: { head: null, body: null, hand: null, foot: null }
                };
            }
            
            // æ›´æ–°èŒä¸šè£…å¤‡é¢æ¿
            updateJobEquipmentPanel();
            
            // åˆ·æ–°ç•Œé¢ï¼ˆå¿…é¡»åœ¨åº”ç”¨è£…å¤‡å±æ€§ä¹‹å‰ï¼Œä»¥ä¾¿æ­£ç¡®æ˜¾ç¤ºè‹±é›„é€‰æ‹©ï¼‰
            initCharacters();
            
            // åº”ç”¨è§’è‰²å±æ€§
            characters.forEach(char => {
                if (char.selectedHeroId && char.selectedHeroLevel) {
                    // å¦‚æœæœ‰é€‰æ‹©çš„è‹±é›„å’Œç­‰çº§ï¼Œä»è‹±é›„æ•°æ®ä¸­è·å–å±æ€§
                    updateCharacterHeroLevel(char.id, char.selectedHeroLevel);
                } else {
                    // å¦‚æœæ²¡æœ‰é€‰æ‹©è‹±é›„ï¼Œä½¿ç”¨ä¿å­˜çš„åŸºç¡€å±æ€§ï¼Œç„¶ååº”ç”¨è£…å¤‡å±æ€§
                    applyJobEquipmentStats(char);
                }
            });
            
            // æ›´æ–°æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();

            // åŠ è½½æ€ªç‰©é…ç½®
            if (scheme.monsterConfig) {
                document.getElementById('spawnRate').value = scheme.monsterConfig.spawnRate || 1;
                document.getElementById('monsterAttack').value = scheme.monsterConfig.attack || 10;
                document.getElementById('monsterDefense').value = scheme.monsterConfig.defense || 5;
                document.getElementById('monsterHp').value = scheme.monsterConfig.hp || 50;
                document.getElementById('monsterAtkSpeed').value = scheme.monsterConfig.atkSpeed || 1;
                document.getElementById('monsterDamageCoeff').value = scheme.monsterConfig.damageCoeff !== undefined ? scheme.monsterConfig.damageCoeff : 1;
                document.getElementById('monsterHpCoeff').value = scheme.monsterConfig.hpCoeff !== undefined ? scheme.monsterConfig.hpCoeff : 0;
            }

            // åŠ è½½å¹³å°å±æ€§é…ç½®
            if (scheme.platformConfig) {
                platformConfig.heroCount = scheme.platformConfig.heroCount !== undefined ? scheme.platformConfig.heroCount : 0;
                platformConfig.heroLevelSum = scheme.platformConfig.heroLevelSum !== undefined ? scheme.platformConfig.heroLevelSum : 0;
                platformConfig.attackCoeff = scheme.platformConfig.attackCoeff !== undefined ? scheme.platformConfig.attackCoeff : 0;
                platformConfig.defenseCoeff = scheme.platformConfig.defenseCoeff !== undefined ? scheme.platformConfig.defenseCoeff : 0;
                platformConfig.hpCoeff = scheme.platformConfig.hpCoeff !== undefined ? scheme.platformConfig.hpCoeff : 0;
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                document.getElementById('platformHeroCount').value = platformConfig.heroCount;
                document.getElementById('platformHeroLevelSum').value = platformConfig.heroLevelSum;
                document.getElementById('platformAttackCoeff').value = platformConfig.attackCoeff;
                document.getElementById('platformDefenseCoeff').value = platformConfig.defenseCoeff;
                document.getElementById('platformHpCoeff').value = platformConfig.hpCoeff;
                
                // æ›´æ–°å¹³å°å±æ€§æ˜¾ç¤ºï¼ˆupdatePlatformAttributes ä¼šè°ƒç”¨ ensurePlatformConfigFromSource å’Œ updatePlatformEconomyHeroDisplayï¼‰
                updatePlatformAttributes();
            } else {
                // å³ä½¿æ²¡æœ‰å¹³å°é…ç½®ï¼Œä¹Ÿè¦æ›´æ–°ç»æµæ–¹æ¡ˆè‹±é›„æ˜¾ç¤ºï¼ˆå¦‚æœå¯ç”¨äº†ç»æµæ–¹æ¡ˆï¼‰
                if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();
                if (typeof ensurePlatformConfigFromSource === 'function') ensurePlatformConfigFromSource();
            }

            // åŠ è½½å¹³å°å±æ€§ï¼ˆè½¦è¾†ï¼‰é…ç½®
            if (scheme.vehicleConfig) {
                vehicleConfig.attack = scheme.vehicleConfig.attack !== undefined ? scheme.vehicleConfig.attack : 0;
                vehicleConfig.defense = scheme.vehicleConfig.defense !== undefined ? scheme.vehicleConfig.defense : 0;
                vehicleConfig.hp = scheme.vehicleConfig.hp !== undefined ? scheme.vehicleConfig.hp : 0;
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                document.getElementById('vehicleAttack').value = vehicleConfig.attack;
                document.getElementById('vehicleDefense').value = vehicleConfig.defense;
                document.getElementById('vehicleHp').value = vehicleConfig.hp;
                
                // æ›´æ–°è½¦è¾†å±æ€§æ˜¾ç¤º
                updateVehicleAttributes();
            }

            // åŠ è½½å…³å¡é…ç½®
            if (scheme.stageConfig) {
                // åˆå¹¶ä¿å­˜çš„å…³å¡é…ç½®
                for (let stage = 1; stage <= 20; stage++) {
                    if (scheme.stageConfig[stage]) {
                        stageConfig[stage] = {
                            monsterId: scheme.stageConfig[stage].monsterId || '',
                            atkSpeed: scheme.stageConfig[stage].atkSpeed !== undefined ? scheme.stageConfig[stage].atkSpeed : 0.33,
                            damageCoeff: scheme.stageConfig[stage].damageCoeff !== undefined ? scheme.stageConfig[stage].damageCoeff : 1,
                            hpCoeff: scheme.stageConfig[stage].hpCoeff !== undefined ? scheme.stageConfig[stage].hpCoeff : 0
                        };
                    }
                }
                
                // é‡æ–°åˆå§‹åŒ–å…³å¡é…ç½®ç•Œé¢ä»¥åº”ç”¨åŠ è½½çš„é…ç½®
                initStageConfig();
            }

            // ä¸»é…ç½®å…³è”ç©å®¶ç»æµæ¨¡æ‹Ÿ
            useEconomySimulation = !!(scheme.useEconomySimulation);
            mainConfigEconomySchemeId = scheme.economySchemeId || null;
            syncMainConfigEconomyUI();
            // æ›´æ–°å¹³å°ç»æµæ–¹æ¡ˆè‹±é›„æ˜¾ç¤º
            if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();
            
            // åŠ è½½20æ³¢æ€ªç‰©æ•°æ®è¾“å…¥é…ç½®ï¼ˆæ ¹æ®æ–¹æ¡ˆIDåŠ è½½ï¼‰
            if (scheme.battleWaveSchemeId) {
                currentBattleWaveSchemeId = scheme.battleWaveSchemeId;
                // æ›´æ–°ä¸‹æ‹‰é€‰æ‹©æ¡†
                updateBattleWaveSchemeSelect();
                // åŠ è½½å¯¹åº”çš„20æ³¢æ–¹æ¡ˆ
                loadBattleWaveSchemeById(scheme.battleWaveSchemeId);
            } else if (scheme.battleWaveData) {
                // å…¼å®¹æ—§æ–¹æ¡ˆï¼šå¦‚æœä¿å­˜äº†å®Œæ•´æ•°æ®ï¼Œç›´æ¥åŠ è½½
                for (let wave = 1; wave <= 25; wave++) {
                    if (scheme.battleWaveData[wave]) {
                        battleWaveData[wave] = {
                            monsterId: scheme.battleWaveData[wave].monsterId || '',
                            attack: scheme.battleWaveData[wave].attack !== undefined ? scheme.battleWaveData[wave].attack : 10,
                            defense: scheme.battleWaveData[wave].defense !== undefined ? scheme.battleWaveData[wave].defense : 5,
                            hp: scheme.battleWaveData[wave].hp !== undefined ? scheme.battleWaveData[wave].hp : 50,
                            atkSpeed: scheme.battleWaveData[wave].atkSpeed !== undefined ? scheme.battleWaveData[wave].atkSpeed : 0.33,
                            damageCoeff: scheme.battleWaveData[wave].damageCoeff !== undefined ? scheme.battleWaveData[wave].damageCoeff : 1,
                            hpCoeff: scheme.battleWaveData[wave].hpCoeff !== undefined ? scheme.battleWaveData[wave].hpCoeff : 1,
                            spawnRate: scheme.battleWaveData[wave].spawnRate !== undefined ? scheme.battleWaveData[wave].spawnRate : 1,
                            duration: scheme.battleWaveData[wave].duration !== undefined ? scheme.battleWaveData[wave].duration : 10,
                            coinReward: scheme.battleWaveData[wave].coinReward !== undefined ? scheme.battleWaveData[wave].coinReward : 0
                        };
                    }
                }
                // é‡æ–°åˆå§‹åŒ–25æ³¢æ€ªç‰©æ•°æ®è¾“å…¥ç•Œé¢ä»¥åº”ç”¨åŠ è½½çš„é…ç½®
                initBattleWaveData();
            }

            // æ›´æ–°å½“å‰æ–¹æ¡ˆID
            currentSchemeId = schemeId;
            
            // æ›´æ–°æ–¹æ¡ˆåç§°è¾“å…¥æ¡†ï¼Œæ˜¾ç¤ºå½“å‰æ–¹æ¡ˆåç§°
            document.getElementById('schemeNameInput').value = scheme.name;

            // æ¸²æŸ“æ–¹æ¡ˆåˆ—è¡¨
            renderSchemeList();

            // æ˜¾ç¤ºä¸Šæ¬¡çš„æ­»äº¡æ—¶é—´
            displayLastDeathTime(scheme);

            showMessage(`å·²åŠ è½½æ–¹æ¡ˆ"${scheme.name}"`, 'success');
            
            // ä¿å­˜å½“å‰ä½¿ç”¨çš„æ–¹æ¡ˆID
            localStorage.setItem('battleSimulatorLastScheme', schemeId);
        };

        // æ˜¾ç¤ºä¸Šæ¬¡çš„æ­»äº¡æ—¶é—´
        function displayLastDeathTime(scheme) {
            if (scheme.lastDeathTime && scheme.lastDeathTime.time) {
                const deathTime = scheme.lastDeathTime.time;
                const deathDate = scheme.lastDeathTime.date || '';
                showMessage(`ä¸Šæ¬¡é¦–ä¸ªè§’è‰²æ­»äº¡æ—¶é—´: ${formatTime(deathTime)}${deathDate ? ` (${deathDate})` : ''}`, 'info');
            }
        }

        // åˆ é™¤æ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.deleteScheme = function(schemeId, event) {
            event.stopPropagation(); // é˜»æ­¢è§¦å‘ç‚¹å‡»äº‹ä»¶

            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ–¹æ¡ˆå—ï¼Ÿ')) {
                return;
            }

            const schemes = loadSchemes();
            const filtered = schemes.filter(s => s.id !== schemeId);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));

            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ–¹æ¡ˆï¼Œæ¸…ç©ºå½“å‰æ–¹æ¡ˆID
            if (currentSchemeId === schemeId) {
                currentSchemeId = null;
                document.getElementById('schemeNameInput').value = '';
            }

            renderSchemeList();
            showMessage('æ–¹æ¡ˆå·²åˆ é™¤', 'success');
        }

        // æ–°å»ºæ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.newScheme = function() {
            currentSchemeId = null;
            document.getElementById('schemeNameInput').value = '';
            useEconomySimulation = false;
            mainConfigEconomySchemeId = null;
            syncMainConfigEconomyUI();
            resetConfig();
            renderSchemeList();
            showMessage('å·²åˆ›å»ºæ–°æ–¹æ¡ˆï¼Œè¯·é…ç½®åä¿å­˜', 'info');
        };

        // æ¸…ç©ºå½“å‰é…ç½®ï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.clearCurrentScheme = function() {
            currentSchemeId = null;
            document.getElementById('schemeNameInput').value = '';
            useEconomySimulation = false;
            mainConfigEconomySchemeId = null;
            syncMainConfigEconomyUI();
            resetConfig();
            renderSchemeList();
        };

        // æ¸²æŸ“æ–¹æ¡ˆåˆ—è¡¨
        function renderSchemeList() {
            const schemes = loadSchemes();
            const listEl = document.getElementById('schemeList');
            const warningEl = document.getElementById('schemeWarning');

            if (schemes.length === 0) {
                listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">æš‚æ— ä¿å­˜çš„æ–¹æ¡ˆ</div>';
                warningEl.textContent = '';
                return;
            }

            listEl.innerHTML = schemes.map(scheme => {
                const saveDate = new Date(scheme.saveTime);
                const isActive = currentSchemeId === scheme.id;
                return `
                    <div class="scheme-item ${isActive ? 'active' : ''}" onclick="loadScheme('${scheme.id}')">
                        <div class="scheme-item-actions">
                            <button class="scheme-item-btn copy" onclick="copyScheme('${scheme.id}', event)" title="å¤åˆ¶æ–¹æ¡ˆ">ğŸ“‹</button>
                            <button class="scheme-item-btn delete" onclick="deleteScheme('${scheme.id}', event)" title="åˆ é™¤æ–¹æ¡ˆ">Ã—</button>
                        </div>
                        <div class="scheme-item-name">${scheme.name}</div>
                        <div class="scheme-item-meta">${saveDate.toLocaleString('zh-CN')}</div>
                    </div>
                `;
            }).join('');

            // æ˜¾ç¤ºæ–¹æ¡ˆæ•°é‡è­¦å‘Š
            if (schemes.length >= MAX_SCHEMES) {
                warningEl.textContent = `âš ï¸ å·²ä¿å­˜${schemes.length}ä¸ªæ–¹æ¡ˆï¼ˆæœ€å¤š${MAX_SCHEMES}ä¸ªï¼‰`;
            } else {
                warningEl.textContent = '';
            }
        }

        // å¤åˆ¶æ–¹æ¡ˆï¼ˆå…¨å±€å‡½æ•°ï¼‰
        window.copyScheme = function(schemeId, event) {
            event.stopPropagation(); // é˜»æ­¢è§¦å‘ç‚¹å‡»äº‹ä»¶

            const schemes = loadSchemes();
            const scheme = schemes.find(s => s.id === schemeId);
            
            if (!scheme) {
                showMessage('æ–¹æ¡ˆä¸å­˜åœ¨', 'error');
                return;
            }

            // æ£€æŸ¥æ–¹æ¡ˆæ•°é‡
            if (schemes.length >= MAX_SCHEMES) {
                showMessage(`å·²è¾¾åˆ°æœ€å¤§æ–¹æ¡ˆæ•°ï¼ˆ${MAX_SCHEMES}ä¸ªï¼‰ï¼Œè¯·å…ˆåˆ é™¤ä¸€ä¸ªæ–¹æ¡ˆ`, 'error');
                return;
            }

            // åˆ›å»ºæ–°æ–¹æ¡ˆï¼ˆå¤åˆ¶æ•°æ®ï¼‰
            const newScheme = {
                id: Date.now().toString(),
                name: `${scheme.name} - å‰¯æœ¬`,
                saveTime: new Date().toISOString(),
                characters: JSON.parse(JSON.stringify(scheme.characters)), // æ·±æ‹·è´è§’è‰²ä¿¡æ¯ï¼ˆåŒ…å«è‹±é›„IDã€ç­‰çº§ã€å±æ€§ç­‰ï¼‰
                characterEquipment: JSON.parse(JSON.stringify(scheme.characterEquipment || {})), // æ·±æ‹·è´è£…å¤‡é…ç½®
                platformConfig: JSON.parse(JSON.stringify(scheme.platformConfig || {})), // æ·±æ‹·è´å¹³å°é…ç½®
                vehicleConfig: JSON.parse(JSON.stringify(scheme.vehicleConfig || {})), // æ·±æ‹·è´è½¦è¾†é…ç½®
                monsterConfig: JSON.parse(JSON.stringify(scheme.monsterConfig || {})), // æ·±æ‹·è´æ€ªç‰©é…ç½®
                lastDeathTime: null // æ–°æ–¹æ¡ˆä¸å¤åˆ¶æ­»äº¡æ—¶é—´
            };

            // å¦‚æœåç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
            let copyName = newScheme.name;
            let copyIndex = 1;
            while (schemes.some(s => s.name === copyName)) {
                copyName = `${scheme.name} - å‰¯æœ¬${copyIndex}`;
                copyIndex++;
            }
            newScheme.name = copyName;

            // æ·»åŠ åˆ°åˆ—è¡¨
            schemes.push(newScheme);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(schemes));

            // åŠ è½½æ–°å¤åˆ¶çš„æ–¹æ¡ˆ
            currentSchemeId = newScheme.id;
            loadScheme(newScheme.id);
            
            // æ›´æ–°æ–¹æ¡ˆåç§°è¾“å…¥æ¡†
            document.getElementById('schemeNameInput').value = copyName;

            renderSchemeList();
            showMessage(`å·²å¤åˆ¶æ–¹æ¡ˆ"${scheme.name}"ä¸º"${copyName}"`, 'success');
        };

        // ä¿å­˜è§’è‰²è£…å¤‡é…ç½®
        function saveCharacterEquipment() {
            try {
                localStorage.setItem('battleSimulatorCharacterEquipment', JSON.stringify(characterEquipment));
            } catch (error) {
                console.error('ä¿å­˜è§’è‰²è£…å¤‡é…ç½®å¤±è´¥:', error);
            }
        }

        // åŠ è½½ä¿å­˜çš„è§’è‰²è£…å¤‡é…ç½®
        function loadSavedCharacterEquipment() {
            try {
                const saved = localStorage.getItem('battleSimulatorCharacterEquipment');
                if (saved) {
                    characterEquipment = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°åŠ è½½è§’è‰²è£…å¤‡é…ç½®');
                } else {
                    // åˆå§‹åŒ–é»˜è®¤é…ç½®
                    characterEquipment = {
                        1: { head: null, body: null, hand: null, foot: null },
                        2: { head: null, body: null, hand: null, foot: null },
                        3: { head: null, body: null, hand: null, foot: null },
                        4: { head: null, body: null, hand: null, foot: null }
                    };
                }
            } catch (error) {
                console.error('åŠ è½½è§’è‰²è£…å¤‡é…ç½®å¤±è´¥:', error);
                // åˆå§‹åŒ–é»˜è®¤é…ç½®
                characterEquipment = {
                    1: { head: null, body: null, hand: null, foot: null },
                    2: { head: null, body: null, hand: null, foot: null },
                    3: { head: null, body: null, hand: null, foot: null },
                    4: { head: null, body: null, hand: null, foot: null }
                };
            }
        }

        // åŠ è½½ä¿å­˜çš„è‹±é›„è¡¨
        // åŠ è½½ä¿å­˜çš„æ€ªç‰©è¡¨
        function loadSavedMonsterTable() {
            try {
                const saved = localStorage.getItem(MONSTER_STORAGE_KEY);
                if (saved) {
                    monsterTable = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°åŠ è½½æ€ªç‰©è¡¨ï¼Œå…±', monsterTable.length, 'ä¸ªæ€ªç‰©');
                    
                    // æ›´æ–°ç•Œé¢
                    updateMonsterTableInfo();
                    updateMonsterSelect();
                    updateStageMonsterSelects(); // æ›´æ–°å…³å¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
                    updateBattleWaveMonsterSelects(); // æ›´æ–°æ³¢æ¬¡æ€ªç‰©é€‰æ‹©ä¸‹æ‹‰æ¡†
                }
            } catch (error) {
                console.error('åŠ è½½ä¿å­˜çš„æ€ªç‰©è¡¨å¤±è´¥:', error);
            }
        }

        function loadSavedHeroTable() {
            try {
                const saved = localStorage.getItem(HERO_STORAGE_KEY);
                if (saved) {
                    heroTable = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°åŠ è½½è‹±é›„è¡¨ï¼Œå…±', heroTable.length, 'ä¸ªè‹±é›„');
                    
                    // ç¡®ä¿ç±»å‹æ­£ç¡®ï¼ˆå…¼å®¹æ—§æ•°æ®å’Œæ–‡æœ¬æ ¼å¼ï¼‰
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // å¦‚æœæ˜¯æ•°å­—ï¼Œç›´æ¥è½¬æ¢
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // å¦‚æœæ˜¯æ–‡æœ¬ï¼Œè½¬æ¢ä¸ºæ•°å­—
                        const textValue = String(heroclassValue).trim();
                        if (textValue === 'å¦å…‹' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === 'æˆ˜å£«' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === 'å°„æ‰‹' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === 'è¾…åŠ©' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // é‡æ–°å¤„ç†è‹±é›„æ•°æ®ï¼Œç¡®ä¿èŒä¸šæ­£ç¡®
                    heroTable = heroTable.map(hero => {
                        let heroclass = parseHeroClass(hero.heroclass);
                        
                        // å¦‚æœèŒä¸šä¸º0ï¼Œå°è¯•ä»è‹±é›„åç§°æ¨æ–­
                        if (heroclass === 0 && hero.namecn) {
                            const nameStr = String(hero.namecn).trim();
                            if (nameStr.includes('å¦å…‹')) heroclass = 1;
                            else if (nameStr.includes('æˆ˜å£«')) heroclass = 2;
                            else if (nameStr.includes('å°„æ‰‹')) heroclass = 3;
                            else if (nameStr.includes('è¾…åŠ©')) heroclass = 4;
                        }
                        
                        // ç¡®ä¿levelså±æ€§å­˜åœ¨ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
                        if (!hero.levels) {
                            hero.levels = {};
                        }
                        
                        // ç¡®ä¿å“è´¨å­—æ®µå­˜åœ¨ï¼Œé»˜è®¤ä¸º1ï¼ˆç™½è‰²ï¼‰
                        if (!hero.quality) {
                            hero.quality = 1;
                        }
                        
                        // ç¡®ä¿åŸºç¡€å±æ€§å­˜åœ¨ï¼ˆå¦‚æœæ²¡æœ‰levelsæ•°æ®ï¼Œä½¿ç”¨ä¿å­˜çš„åŸºç¡€å±æ€§ï¼‰
                        if (!hero.baseAttack && hero.levels[1]) {
                            hero.baseAttack = hero.levels[1].baseAttack || 0;
                        }
                        if (!hero.baseDefense && hero.levels[1]) {
                            hero.baseDefense = hero.levels[1].baseDefense || 0;
                        }
                        if (!hero.baseHp && hero.levels[1]) {
                            hero.baseHp = hero.levels[1].baseHp || 0;
                        }
                        
                        return {
                            ...hero,
                            heroclass: heroclass
                        };
                    });
                    
                    updateHeroTableInfo();
                } else {
                    console.log('æœ¬åœ°æ²¡æœ‰ä¿å­˜çš„è‹±é›„è¡¨');
                }
            } catch (error) {
                console.error('åŠ è½½è‹±é›„è¡¨å¤±è´¥:', error);
            }
        }

        // åŠ è½½ä¿å­˜çš„è£…å¤‡è¡¨
        // åŠ è½½ä¿å­˜çš„è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨
        function loadSavedEquipSlotLevelTable() {
            try {
                const saved = localStorage.getItem(EQUIP_SLOT_LEVEL_STORAGE_KEY);
                if (saved) {
                    equipSlotLevelTable = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°åŠ è½½è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨ï¼Œå…±', equipSlotLevelTable.length, 'æ¡è®°å½•');
                    
                    // å¦‚æœå·²åŠ è½½å¼ºåŒ–è¡¨ï¼Œæ£€æŸ¥å¹¶æ·»åŠ è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•
                    if (equipSlotLevelTable && equipSlotLevelTable.length > 0) {
                        const hasEquipSlotEnhance = resourceConsumptionGameplayList.some(g => g.type === 'equipSlotEnhance');
                        if (!hasEquipSlotEnhance) {
                            const maxId = resourceConsumptionGameplayList.length > 0 
                                ? Math.max(...resourceConsumptionGameplayList.map(g => g.id)) 
                                : 0;
                            resourceConsumptionGameplayList.push({
                                id: maxId + 1,
                                name: 'è£…å¤‡æ§½ä½å¼ºåŒ–',
                                itemName: '',
                                type: 'equipSlotEnhance'
                            });
                            savePlayerEconomyData();
                            console.log('å·²è‡ªåŠ¨æ·»åŠ è£…å¤‡æ§½ä½å¼ºåŒ–ç©æ³•');
                        }
                    }
                }
            } catch (error) {
                console.error('åŠ è½½ä¿å­˜çš„è£…å¤‡æ§½ä½å¼ºåŒ–è¡¨å¤±è´¥:', error);
            }
        }
        
        function loadSavedEquipmentTable() {
            try {
                const saved = localStorage.getItem(EQUIPMENT_STORAGE_KEY);
                if (saved) {
                    equipmentTable = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°åŠ è½½è£…å¤‡è¡¨ï¼Œå…±', equipmentTable.length, 'ä»¶è£…å¤‡');
                    
                    // è°ƒè¯•ï¼šæ˜¾ç¤ºåŸå§‹æ•°æ®æ ¼å¼
                    if (equipmentTable.length > 0) {
                        console.log('åŠ è½½è£…å¤‡è¡¨æ—¶çš„åŸå§‹æ•°æ®ç¤ºä¾‹ï¼ˆå‰3ä»¶ï¼‰:', equipmentTable.slice(0, 3).map(eq => ({
                            id: eq.id,
                            namecn: eq.namecn,
                            heroclass: eq.heroclass,
                            heroclassType: typeof eq.heroclass,
                            type: eq.type,
                            typeType: typeof eq.type
                        })));
                        
                        // ç»Ÿè®¡æ‰€æœ‰å”¯ä¸€çš„heroclasså’Œtypeå€¼
                        const uniqueHeroclass = [...new Set(equipmentTable.map(eq => eq.heroclass))].slice(0, 20);
                        const uniqueType = [...new Set(equipmentTable.map(eq => String(eq.type || '').trim()))].slice(0, 20);
                        console.log('è£…å¤‡è¡¨ä¸­å”¯ä¸€çš„heroclasså€¼ï¼ˆå‰20ä¸ªï¼‰:', uniqueHeroclass);
                        console.log('è£…å¤‡è¡¨ä¸­å”¯ä¸€çš„typeå€¼ï¼ˆå‰20ä¸ªï¼‰:', uniqueType);
                    }
                    
                    // ç¡®ä¿ç±»å‹æ­£ç¡®ï¼ˆå…¼å®¹æ—§æ•°æ®å’Œæ–‡æœ¬æ ¼å¼ï¼‰
                    function parseHeroClass(heroclassValue) {
                        if (!heroclassValue) return 0;
                        
                        // å¦‚æœæ˜¯æ•°å­—ï¼Œç›´æ¥è½¬æ¢
                        const numValue = parseInt(heroclassValue);
                        if (!isNaN(numValue) && numValue > 0) {
                            return numValue;
                        }
                        
                        // å¦‚æœæ˜¯æ–‡æœ¬ï¼Œè½¬æ¢ä¸ºæ•°å­—
                        const textValue = String(heroclassValue).trim();
                        if (textValue === 'å¦å…‹' || textValue === 'Tank' || textValue === '1') return 1;
                        if (textValue === 'æˆ˜å£«' || textValue === 'Warrior' || textValue === '2') return 2;
                        if (textValue === 'å°„æ‰‹' || textValue === 'Archer' || textValue === '3') return 3;
                        if (textValue === 'è¾…åŠ©' || textValue === 'Support' || textValue === '4') return 4;
                        
                        return 0;
                    }
                    
                    // é‡æ–°å¤„ç†è£…å¤‡æ•°æ®ï¼Œç¡®ä¿èŒä¸šæ­£ç¡®
                    equipmentTable = equipmentTable.map(eq => {
                        let heroclass = parseHeroClass(eq.heroclass);
                        
                        // å¦‚æœèŒä¸šä¸º0ï¼Œå°è¯•ä»è£…å¤‡åç§°æ¨æ–­ï¼ˆå¦‚"å¦å…‹å¤´"ã€"æˆ˜å£«æ‰‹"ç­‰ï¼‰
                        if (heroclass === 0 && eq.namecn) {
                            const nameStr = String(eq.namecn).trim();
                            if (nameStr.includes('å¦å…‹')) heroclass = 1;
                            else if (nameStr.includes('æˆ˜å£«')) heroclass = 2;
                            else if (nameStr.includes('å°„æ‰‹')) heroclass = 3;
                            else if (nameStr.includes('è¾…åŠ©')) heroclass = 4;
                        }
                        
                        // å¦‚æœèŒä¸šä»ä¸º0ï¼Œå°è¯•ä»è£…å¤‡IDæ¨æ–­ï¼ˆå¦‚IDä¸­åŒ…å«èŒä¸šä¿¡æ¯ï¼‰
                        if (heroclass === 0 && eq.id) {
                            const idStr = String(eq.id).trim();
                            // å‡è®¾IDæ ¼å¼å¦‚ï¼š13111001ï¼Œå…¶ä¸­ç¬¬3ä½å¯èƒ½æ˜¯èŒä¸šï¼ˆ1=å¦å…‹ï¼Œ2=æˆ˜å£«ï¼Œ3=å°„æ‰‹ï¼Œ4=è¾…åŠ©ï¼‰
                            if (idStr.length >= 3) {
                                const thirdChar = parseInt(idStr[2]);
                                if (thirdChar >= 1 && thirdChar <= 4) {
                                    heroclass = thirdChar;
                                }
                            }
                        }
                        
                        return {
                            ...eq,
                            heroclass: heroclass,
                            type: String(eq.type || '').trim(),
                            quality: parseInt(eq.quality) || 1 // ç¡®ä¿å“è´¨å­—æ®µå­˜åœ¨ï¼Œé»˜è®¤ä¸º1ï¼ˆç™½è‰²ï¼‰
                        };
                    });
                    
                    // è°ƒè¯•ï¼šæ˜¾ç¤ºè½¬æ¢åçš„æ•°æ®æ ¼å¼
                    if (equipmentTable.length > 0) {
                        console.log('è½¬æ¢åçš„è£…å¤‡æ•°æ®ç¤ºä¾‹ï¼ˆå‰3ä»¶ï¼‰:', equipmentTable.slice(0, 3).map(eq => ({
                            id: eq.id,
                            namecn: eq.namecn,
                            heroclass: eq.heroclass,
                            heroclassType: typeof eq.heroclass,
                            type: eq.type,
                            typeType: typeof eq.type
                        })));
                        
                        // ç»Ÿè®¡å„èŒä¸šå’Œéƒ¨ä½çš„è£…å¤‡æ•°é‡
                        const stats = {};
                        equipmentTable.forEach(eq => {
                            const job = eq.heroclass || 0;
                            const type = eq.type || '';
                            const key = `job${job}_${type}`;
                            stats[key] = (stats[key] || 0) + 1;
                        });
                        console.log('è£…å¤‡ç»Ÿè®¡ï¼ˆèŒä¸š_éƒ¨ä½: æ•°é‡ï¼‰:', stats);
                    }
                    updateJobEquipmentPanel();
                    updateEquipmentTableInfo();
                } else {
                    console.log('æœ¬åœ°æ²¡æœ‰ä¿å­˜çš„è£…å¤‡è¡¨');
                }
            } catch (error) {
                console.error('åŠ è½½è£…å¤‡è¡¨å¤±è´¥:', error);
            }
        }

        // åˆå§‹åŒ–å‡½æ•°
        function initializeApp() {
            // ç¡®ä¿DOMå·²åŠ è½½
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeApp);
                return;
            }

            // åŠ è½½å…±äº«Gist IDé…ç½®
            loadSharedGistId();
            
            // åˆå§‹åŒ–æ ‡ç­¾é¡µï¼šå°†ä¸»é…ç½®å†…å®¹ç§»åˆ°ä¸»é…ç½®æ ‡ç­¾é¡µ
            const mainContent = document.getElementById('main-content');
            const mainTab = document.getElementById('tab-main');
            if (mainContent && mainTab) {
                mainTab.appendChild(mainContent);
            }
            
            // è®¾ç½®ç©å®¶ç»æµæ¨¡æ‹Ÿè¾“å…¥ç›‘å¬å™¨
            setupEconomyInputListeners();
            
            // åˆå§‹åŒ–è§’è‰²ç•Œé¢
            initCharacters();
            
            // åŠ è½½ä¿å­˜çš„æ•°æ®ï¼ˆå…ˆä»æœ¬åœ°åŠ è½½ï¼Œç„¶åå°è¯•ä»å…±äº«å­˜å‚¨åŒæ­¥ï¼‰
            loadSavedCharacterEquipment();
            loadSavedEquipmentTable();
            loadSavedEquipSlotLevelTable();
            loadSavedHeroTable();
            loadSavedMonsterTable();
            loadSavedUpgradeTable();
            loadSavedRecruitInfoTable();
            loadSavedAccountLevelTable();
            loadSavedResourceItemTable();

            // å¦‚æœé…ç½®äº†å…±äº«å­˜å‚¨ï¼Œè‡ªåŠ¨å°è¯•åŒæ­¥ï¼ˆé™é»˜ï¼Œä¸æ˜¾ç¤ºé”™è¯¯ï¼‰
            if (sharedGistId) {
                updateSharedStorageStatus('å·²é…ç½®ï¼Œç‚¹å‡»åŒæ­¥æŒ‰é’®åŠ è½½å…±äº«æ•°æ®');
            } else {
                updateSharedStorageStatus('æœªé…ç½®å…±äº«å­˜å‚¨');
            }
            
            // åˆå§‹åŒ–æ—¶åº”ç”¨è£…å¤‡å±æ€§
            characters.forEach(char => {
                applyJobEquipmentStats(char);
            });
            
            // åˆå§‹åŒ–èŒä¸šè£…å¤‡é¢æ¿
            updateJobEquipmentPanel();
            
            // åˆå§‹åŒ–æœ€ç»ˆå±æ€§é¢æ¿
            updateFinalAttributesPanel();
            
            // åˆå§‹åŒ–å…³å¡é…ç½®ç•Œé¢
            initStageConfig();
            
            // åˆå§‹åŒ–20æ³¢æ€ªç‰©æ•°æ®è¾“å…¥ç•Œé¢
            initBattleWaveData();
            
            // åˆå§‹åŒ–20æ³¢æ€ªç‰©æ•°æ®æ–¹æ¡ˆä¸‹æ‹‰é€‰æ‹©æ¡†
            updateBattleWaveSchemeSelect();
            
            // åˆå§‹åŒ–å¹³å°å±æ€§é…ç½®æ˜¾ç¤º
            updatePlatformAttributes();
            
            // åˆå§‹åŒ–è½¦è¾†å±æ€§é…ç½®æ˜¾ç¤º
            updateVehicleAttributes();
            
            // æ¸²æŸ“ä¸»é…ç½®è£…å¤‡å¼ºåŒ–é¢æ¿
            renderMainConfigEquipSlotEnhancePanel();
            
            // æ¸²æŸ“æ–¹æ¡ˆåˆ—è¡¨
            renderSchemeList();
            
            syncMainConfigEconomyUI();
            // æ›´æ–°å¹³å°ç»æµæ–¹æ¡ˆè‹±é›„æ˜¾ç¤º
            if (typeof updatePlatformEconomyHeroDisplay === 'function') updatePlatformEconomyHeroDisplay();

            // å°è¯•åŠ è½½ä¸Šæ¬¡ä½¿ç”¨çš„æ–¹æ¡ˆ
            const lastSchemeId = localStorage.getItem('battleSimulatorLastScheme');
            if (lastSchemeId) {
                const schemes = loadSchemes();
                const scheme = schemes.find(s => s.id === lastSchemeId);
                if (scheme) {
                    loadScheme(lastSchemeId);
                }
            }
        }

        // æ‰§è¡Œåˆå§‹åŒ–
        initializeApp();

    </script>
</body>
</html>











